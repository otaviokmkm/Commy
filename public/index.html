    <!-- Modal de Autenticação -->
    <div id="auth-modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(20,23,35,0.96);display:flex;align-items:center;justify-content:center;z-index:9999;">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-full max-w-xs flex flex-col items-center">
            <h2 class="text-2xl font-bold text-emerald-400 mb-4">Entrar no Jogo</h2>
            <form id="login-form" class="w-full flex flex-col gap-2">
                <input id="login-username" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Usuário" autocomplete="username" required>
                <input id="login-password" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Senha" type="password" autocomplete="current-password" required>
                <button type="submit" class="action-button w-full">Entrar</button>
            </form>
            <div class="text-slate-400 text-sm my-2">ou</div>
            <form id="register-form" class="w-full flex flex-col gap-2">
                <input id="register-username" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Novo usuário" autocomplete="username" required>
                <input id="register-password" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Senha" type="password" autocomplete="new-password" required>
                <button type="submit" class="action-button w-full bg-sky-600 hover:bg-sky-700">Cadastrar</button>
            </form>
            <div id="auth-error" class="text-red-400 text-sm mt-2" style="display:none"></div>
        </div>
    </div>
<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMORPG Tático com Overworld</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a202c; /* cinza escuro Tailwind */
            color: #e2e8f0; /* ardósia clara Tailwind */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #game-and-ui-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
        }
        #main-content-area {
            display: flex;
            flex-direction: row; /* Para UI lateral */
            gap: 1rem;
            width: 100%;
            justify-content: center;
            align-items: flex-start; /* Alinha o painel lateral com o topo do game-container */
        }
        #game-area-wrapper { /* Novo wrapper para canvas e hotbar */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 70vw; /* Ajustar conforme necessário */
            max-width: 800px;
        }
        #game-container {
            width: 100%; /* Ocupa toda a largura do game-area-wrapper */
            max-height: 600px; /* Mantém uma altura máxima */
            background-color: #2d3748; 
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            position: relative;
            aspect-ratio: 4 / 3; /* Exemplo de aspect ratio, ajuste conforme necessário */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 0.375rem;
            cursor: pointer;
            background-color: #374151; 
        }
        #combat-hotbar {
            display: none; /* Inicialmente escondida */
            justify-content: center;
            gap: 0.5rem; /* Espaço entre os slots */
            padding: 0.5rem;
            background-color: #2d3748; /* Cor similar aos painéis */
            border: 1px solid #4a5568;
            border-top: none; /* Para parecer conectado ao game-container se posicionado abaixo */
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
            width: 100%; /* Ocupa toda a largura do game-area-wrapper */
            box-sizing: border-box;
            margin-top: -1px; 
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background-color: #1a202c; 
            border: 1px solid #4a5568; 
            border-radius: 0.25rem; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; 
            color: #a0aec0; 
            cursor: pointer;
            position: relative; 
        }
        .hotbar-slot .slot-number {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.65rem;
            color: #718096; 
        }

        #right-ui-panel {
            width: 25vw;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .ui-panel {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        #chat-messages {
            background-color: #1e293b;
            padding: 0.5rem;
            border-radius: 0.375rem;
            height: 100px;
            overflow-y: auto;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        #chat-input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #4a5568;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .game-message {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 0.375rem;
            font-size: 0.9em;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            text-align: center;
        }
        .action-button {
            background-color: #38a169; 
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            font-weight: 600;
        }
        .action-button:hover {
            background-color: #2f855a; 
        }
        .action-button:disabled {
            background-color: #4a5568; 
            cursor: not-allowed;
        }
        .selected-action {
            background-color: #dd6b20; 
        }
        .selected-action:hover {
            background-color: #c05621; 
        }
        .combat-ui {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-slate-200 flex flex-col items-center min-h-screen p-4">

    <header class="mb-6 text-center">
        <h1 class="text-4xl font-bold text-emerald-400">MMORPG Tático</h1>
        <p class="text-slate-400" id="statusInfo">Explorando o mundo...</p>
    </header>

    <div id="game-and-ui-wrapper">
        <div id="main-content-area">
            <div id="game-area-wrapper">
                <div id="game-container" class="shadow-2xl">
                    <canvas id="gameCanvas"></canvas>
                    <div id="gameLogMessage" class="game-message hidden"></div>
                </div>
                <div id="combat-hotbar">
                    </div>
            </div>

            <div id="right-ui-panel">
                <div id="player-info-overworld" class="ui-panel">
                     <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Jogador</h2>
                     <p><strong>Nome:</strong> <span id="playerNameOverworld">Aventureiro</span></p>
                     <p><strong>HP:</strong> <span id="playerHPOverworld">100/100</span></p>
                     <p><strong>Ouro:</strong> <span id="playerGoldOverworld">0</span>g</p>
                     <p class="text-xs mt-2">Setas: Mover. Encoste em inimigos para lutar.</p>
                </div>

                <div id="combat-ui-panel" class="ui-panel combat-ui">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Combate</h2>
                    <div id="player-stats-combat" class="text-sm space-y-1">
                        <p><strong>AP:</strong> <span id="playerAPCombat">0/0</span></p>
                        <p><strong>MP:</strong> <span id="playerMPCombat">0/0</span></p>
                    </div>
                    <div class="mt-3 space-y-2">
                        <button id="moveButton" class="action-button w-full">Mover (1)</button>
                        <button id="attackButton" class="action-button w-full">Atacar (2)</button>
                        <button id="endTurnButton" class="action-button w-full bg-sky-600 hover:bg-sky-700">Passar Turno (Espaço)</button>
                    </div>
                </div>

                <div id="chat-box-container" class="ui-panel">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Chat</h2>
                    <div id="chat-messages">
                        <p><span class="font-bold text-yellow-400">[Sistema]:</span> Bem-vindo! Vá para a direita para avançar de mapa.</p>
                    </div>
                    <input type="text" id="chat-input" placeholder="Digite sua mensagem..." class="focus:outline-none focus:border-emerald-500">
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Autenticação: Modal de Login/Cadastro ---
        const authModal = document.getElementById('auth-modal');
        function showAuthModal() { authModal.style.display = 'flex'; }
        function hideAuthModal() { authModal.style.display = 'none'; }
        function setAuthError(msg) { const err = document.getElementById('auth-error'); err.textContent = msg; err.style.display = 'block'; }
        function clearAuthError() { const err = document.getElementById('auth-error'); err.textContent = ''; err.style.display = 'none'; }
        function saveSession(token, username) { localStorage.setItem('sessionToken', token); localStorage.setItem('username', username); }
        function clearSession() { localStorage.removeItem('sessionToken'); localStorage.removeItem('username'); }
        function getSession() { return { token: localStorage.getItem('sessionToken'), username: localStorage.getItem('username') }; }

        // Login
        document.getElementById('login-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            clearAuthError();
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            const res = await fetch('/api/login', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ login: username, password })
            });
            if (res.ok) {
                const data = await res.json();
                saveSession(data.token, username);
                player.name = username;
                hideAuthModal();
                startGameAfterAuth();
            } else {
                setAuthError('Usuário ou senha inválidos.');
            }
        });

        // Cadastro
        document.getElementById('register-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            clearAuthError();
            const username = document.getElementById('register-username').value.trim();
            const password = document.getElementById('register-password').value;
            const res = await fetch('/api/register', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ login: username, password })
            });
            if (res.ok) {
                const data = await res.json();
                // Após cadastro, faz login automático
                const loginRes = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ login: username, password })
                });
                if (loginRes.ok) {
                    const loginData = await loginRes.json();
                    saveSession(loginData.token, username);
                    player.name = username;
                    hideAuthModal();
                    startGameAfterAuth();
                } else {
                    setAuthError('Erro ao fazer login após cadastro.');
                }
            } else {
                let msg = 'Erro ao cadastrar.';
                try { const err = await res.json(); if (err && err.error) { msg = err.error; } } catch {}
                setAuthError(msg);
            }
        });

        // Logout (botão no painel do jogador)
        function addLogoutButton() {
            let btn = document.getElementById('logout-btn');
            if (!btn) {
                btn = document.createElement('button');
                btn.id = 'logout-btn';
                btn.textContent = 'Sair';
                btn.className = 'action-button w-full bg-red-600 hover:bg-red-700 mt-3';
                btn.onclick = async () => {
                    clearSession();
                    showAuthModal();
                    location.reload();
                };
                playerInfoOverworldPanel.appendChild(btn);
            }
        }

        // Bloqueia inicialização do jogo até autenticar
        let gameInitialized = false;
        function startGameAfterAuth() {
            if (gameInitialized) return;
            gameInitialized = true;
            player.name = getSession().username || 'Aventureiro';
            addLogoutButton();
            initGame();
        }

        // Ao carregar a página, verifica sessão
        document.addEventListener('DOMContentLoaded', () => {
            const session = getSession();
            if (session.token && session.username) {
                hideAuthModal();
                startGameAfterAuth();
            } else {
                showAuthModal();
            }
        });
        // --- Elementos do DOM ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const combatHotbarElement = document.getElementById('combat-hotbar'); 
        const chatInput = document.getElementById('chat-input');
        const chatMessages = document.getElementById('chat-messages');
        const gameLogMessage = document.getElementById('gameLogMessage');
        const statusInfoDisplay = document.getElementById('statusInfo');

        const playerNameOverworldDisplay = document.getElementById('playerNameOverworld');
        const playerHPOverworldDisplay = document.getElementById('playerHPOverworld');
        const playerGoldOverworldDisplay = document.getElementById('playerGoldOverworld');
        
        const playerAPCombatDisplay = document.getElementById('playerAPCombat');
        const playerMPCombatDisplay = document.getElementById('playerMPCombat');
        const combatUiPanel = document.getElementById('combat-ui-panel');
        const playerInfoOverworldPanel = document.getElementById('player-info-overworld');


        const moveButton = document.getElementById('moveButton');
        const attackButton = document.getElementById('attackButton');
        const endTurnButton = document.getElementById('endTurnButton');

        // --- Configurações do Jogo ---
        const TILE_SIZE = 40; 
        let GRID_COLS, GRID_ROWS; 
        
        let gameState = 'overworld'; 
        const HOTBAR_SLOTS = 5; 
        let currentMapId = 'mapa1'; // Mapa inicial
        let lastAiUpdateTime = 0;
        const AI_UPDATE_INTERVAL = 500; 

        // --- Open World (grande) ---
        const OPEN_WORLD_ID = 'open_world';
        const OPEN_WORLD_SIZE = 200;
        let openWorldMap = null; // 2D array
        let openWorldEnemies = [];
        let cameraX = 0, cameraY = 0;
        let cameraWidth = 0, cameraHeight = 0;

        // --- Dados do Mapa Overworld ---
        const MAP_TILES = {
            EMPTY: 0,
            OBSTACLE_ROCK: 1,
            DECORATION_TREE: 2,
            DECORATION_BUSH: 3,
        };
        const mapConnections = {
            'mapa1': { right: 'mapa2' },
            'mapa2': { left: 'mapa1', right: 'mapa_chefe' },
            'mapa_chefe': { left: 'mapa2' }
        };

        let mapData = []; 

        function generateMapFor(mapId) {
            if (mapId === OPEN_WORLD_ID) {
                // Large open world map
                if (!openWorldMap) {
                    openWorldMap = [];
                    for (let r = 0; r < OPEN_WORLD_SIZE; r++) {
                        openWorldMap[r] = [];
                        for (let c = 0; c < OPEN_WORLD_SIZE; c++) {
                            // Border walls
                            if (r === 0 || r === OPEN_WORLD_SIZE - 1 || c === 0 || c === OPEN_WORLD_SIZE - 1) {
                                openWorldMap[r][c] = MAP_TILES.OBSTACLE_ROCK;
                            } else if (Math.random() < 0.07) {
                                openWorldMap[r][c] = MAP_TILES.OBSTACLE_ROCK;
                            } else if (Math.random() < 0.10) {
                                openWorldMap[r][c] = Math.random() < 0.5 ? MAP_TILES.DECORATION_TREE : MAP_TILES.DECORATION_BUSH;
                            } else {
                                openWorldMap[r][c] = MAP_TILES.EMPTY;
                            }
                        }
                    }
                    // Place monsters
                    openWorldEnemies = [];
                    for (let i = 0; i < 40; i++) {
                        let placed = false;
                        while (!placed) {
                            let x = 2 + Math.floor(Math.random() * (OPEN_WORLD_SIZE - 4));
                            let y = 2 + Math.floor(Math.random() * (OPEN_WORLD_SIZE - 4));
                            if (openWorldMap[y][x] === MAP_TILES.EMPTY) {
                                openWorldEnemies.push({
                                    id: 1000 + i,
                                    overworldX: x,
                                    overworldY: y,
                                    aggroRange: 5 + Math.floor(Math.random() * 5),
                                    isAliveOverworld: true,
                                    combatStats: {
                                        size: TILE_SIZE * 0.9,
                                        color: ['#eab308', '#f87171', '#34d399', '#818cf8'][i % 4],
                                        hp: 60 + Math.floor(Math.random() * 60),
                                        maxHp: 60 + Math.floor(Math.random() * 60),
                                        ap: 4 + Math.floor(Math.random() * 3),
                                        mp: 2 + Math.floor(Math.random() * 2),
                                        attackPower: 10 + Math.floor(Math.random() * 10),
                                        attackRange: 1,
                                        name: 'Monstro Selvagem',
                                        loot: { gold: 10 + Math.floor(Math.random() * 20) }
                                    }
                                });
                                placed = true;
                            }
                        }
                    }
                }
                // No need to regenerate each time
                mapData = openWorldMap;
            } else {
                mapData = [];
                if (GRID_ROWS <= 0 || GRID_COLS <= 0) {
                    return; 
                }
                for (let r = 0; r < GRID_ROWS; r++) {
                    mapData[r] = [];
                    for (let c = 0; c < GRID_COLS; c++) {
                        mapData[r][c] = MAP_TILES.EMPTY;
                    }
                }
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        if (r === 0 || r === GRID_ROWS - 1 || c === 0 || c === GRID_COLS - 1) {
                            const connections = mapConnections[mapId] || {};
                            let isConnectionTile = false;
                            if (r === 0 && connections.up) isConnectionTile = true;
                            else if (r === GRID_ROWS - 1 && connections.down) isConnectionTile = true;
                            else if (c === 0 && connections.left) isConnectionTile = true;
                            else if (c === GRID_COLS - 1 && connections.right) isConnectionTile = true;
                            if (!isConnectionTile) {
                                mapData[r][c] = MAP_TILES.OBSTACLE_ROCK;
                            }
                        }
                    }
                }
                let rockDensity = 0.05;
                let decorDensity = 0.1;
                if (mapId === 'mapa_chefe') {
                    rockDensity = 0.1;
                    decorDensity = 0.05;
                }
                for (let r = 1; r < GRID_ROWS - 1; r++) { 
                    for (let c = 1; c < GRID_COLS - 1; c++) {
                        let isEntitySpawn = (r === player.overworldY && c === player.overworldX);
                        if (!isEntitySpawn) {
                            for (const enemy of enemies) {
                                if (enemy.mapId === mapId && enemy.isAliveOverworld && enemy.overworldY === r && enemy.overworldX === c) {
                                    isEntitySpawn = true;
                                    break;
                                }
                            }
                        }
                        if (isEntitySpawn) continue; 
                        if (Math.random() < rockDensity) { 
                            mapData[r][c] = MAP_TILES.OBSTACLE_ROCK;
                        } else if (Math.random() < decorDensity) {
                            mapData[r][c] = Math.random() < 0.5 ? MAP_TILES.DECORATION_TREE : MAP_TILES.DECORATION_BUSH;
                        }
                    }
                }
                if (isValidOverworldTile(player.overworldX, player.overworldY) && mapData[player.overworldY]) { 
                    mapData[player.overworldY][player.overworldX] = MAP_TILES.EMPTY;
                }
                enemies.forEach(enemy => {
                    if (enemy.mapId === mapId && enemy.isAliveOverworld && isValidOverworldTile(enemy.overworldX, enemy.overworldY)) {
                        if(mapData[enemy.overworldY]) { 
                            mapData[enemy.overworldY][enemy.overworldX] = MAP_TILES.EMPTY;
                        }
                    }
                });
            }
        }


        let player = {
            overworldX: 1, overworldY: 1, 
            gridX: 0, gridY: 0,
            size: TILE_SIZE * 0.8,
            color: 'deepskyblue',
            hp: 100, maxHp: 100,
            ap: 60, maxAp: 60,
            mp: 30, maxMp: 30,
            attackPower: 15,
            attackRange: 2, 
            isAlive: true,
            name: "Aventureiro",
            gold: 0,
        };

        let enemies = [ 
            { id: 1, mapId: 'mapa1', overworldX: 8, overworldY: 5, aggroRange: 4, isAliveOverworld: true, combatStats: { size: TILE_SIZE * 0.8, color: 'tomato', hp: 70, maxHp: 70, ap: 4, mp: 2, attackPower: 10, attackRange: 1, name: "Goblin Batedor", loot: { gold: 10 } } },
            { id: 2, mapId: 'mapa1', overworldX: 12, overworldY: 10, aggroRange: 4, isAliveOverworld: true, combatStats: { size: TILE_SIZE * 0.8, color: 'tomato', hp: 70, maxHp: 70, ap: 4, mp: 2, attackPower: 10, attackRange: 1, name: "Goblin Batedor", loot: { gold: 10 } } },
            { id: 3, mapId: 'mapa2', overworldX: 3, overworldY: 8, aggroRange: 5, isAliveOverworld: true, combatStats: { size: TILE_SIZE * 0.85, color: 'darkorange', hp: 90, maxHp: 90, ap: 5, mp: 3, attackPower: 12, attackRange: 1, name: "Orc Brutamontes", loot: { gold: 15 } } },
            { id: 4, mapId: 'mapa2', overworldX: 10, overworldY: 4, aggroRange: 5, isAliveOverworld: true, combatStats: { size: TILE_SIZE * 0.85, color: 'darkorange', hp: 90, maxHp: 90, ap: 5, mp: 3, attackPower: 12, attackRange: 1, name: "Orc Brutamontes", loot: { gold: 15 } } },
            { id: 5, mapId: 'mapa_chefe', overworldX: 10, overworldY: 7, aggroRange: 7, isAliveOverworld: true, combatStats: { size: TILE_SIZE * 1.2, color: 'purple', hp: 200, maxHp: 200, ap: 6, mp: 3, attackPower: 25, attackRange: 2, name: "Rei Goblin", loot: { gold: 100 } } },
            { id: -1, mapId: 'combate_apenas', overworldX: -1, overworldY: -1, isAliveOverworld: false, combatStats: { size: TILE_SIZE * 0.7, color: 'crimson', hp: 50, maxHp: 50, ap: 4, mp: 2, attackPower: 8, attackRange: 1, name: "Guarda Goblin" } },
        ];
        let activeCombatEnemy = null; 

        let currentTurn = 'player'; 
        let selectedAction = null; 
        let highlightedTiles = []; 

        // --- Inicialização ---
        function initGame() {
            if (!ctx) {
                alert("Erro crítico: Não foi possível renderizar o jogo. Verifique o console.");
                return;
            }
            resizeCanvas(); 
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleGlobalKeyDown); 
            canvas.addEventListener('click', handleCanvasClick);
            moveButton.addEventListener('click', () => setSelectedAction('move'));
            attackButton.addEventListener('click', () => setSelectedAction('attack'));
            endTurnButton.addEventListener('click', endPlayerTurn);
            chatInput.addEventListener('keypress', handleChatInput);
            createHotbarSlots(); 
            gameLoop(); 
        }

        function loadMap(mapId, entrySide) {
            currentMapId = mapId;
            if (mapId === OPEN_WORLD_ID) {
                // Teleport to open world spawn
                player.overworldX = Math.floor(OPEN_WORLD_SIZE / 2);
                player.overworldY = Math.floor(OPEN_WORLD_SIZE / 2);
                cameraX = player.overworldX;
                cameraY = player.overworldY;
                cameraWidth = Math.floor(canvas.width / TILE_SIZE);
                cameraHeight = Math.floor(canvas.height / TILE_SIZE);
                generateMapFor(mapId);
                updateUIBasedOnState();
                updatePlayerOverworldInfo();
                return;
            }
            if (GRID_COLS <= 0 || GRID_ROWS <= 0) { 
                player.overworldX = 0;
                player.overworldY = 0;
            } else if (entrySide) {
                switch(entrySide) {
                    case 'left': player.overworldX = GRID_COLS > 1 ? GRID_COLS - 2 : 0; break;
                    case 'right': player.overworldX = GRID_COLS > 1 ? 1 : 0; break;
                    case 'up': player.overworldY = GRID_ROWS > 1 ? GRID_ROWS - 2 : 0; break;
                    case 'down': player.overworldY = GRID_ROWS > 1 ? 1 : 0; break;
                    default: 
                        player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                        player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
                        break;
                }
                 player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                 player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
            } else { 
                 player.overworldX = (GRID_COLS > 1) ? 1 : 0;
                 player.overworldY = (GRID_ROWS > 1) ? 1 : 0;
            }
            generateMapFor(currentMapId); 
            updateUIBasedOnState();
            updatePlayerOverworldInfo();
        }

        function resizeCanvas() {
            if (!gameContainer || gameContainer.clientWidth === 0 || gameContainer.clientHeight === 0) {
                canvas.width = canvas.width || 320; 
                canvas.height = canvas.height || 240;
                if (ctx) { 
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(0,0,255,0.5)'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.fillText("Aguardando dimensões...", 10, 20);
                }
                return; 
            }
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            GRID_COLS = Math.floor(canvas.width / TILE_SIZE);
            GRID_ROWS = Math.floor(canvas.height / TILE_SIZE);
            GRID_COLS = Math.max(0, GRID_COLS); 
            GRID_ROWS = Math.max(0, GRID_ROWS);
            if (currentMapId === OPEN_WORLD_ID) {
                cameraWidth = Math.floor(canvas.width / TILE_SIZE);
                cameraHeight = Math.floor(canvas.height / TILE_SIZE);
            } else {
                if (GRID_COLS > 0 && GRID_ROWS > 0) {
                    player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                    player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
                    enemies.forEach(enemy => {
                        if (enemy.mapId === currentMapId) { 
                            enemy.overworldX = Math.max(0, Math.min(enemy.overworldX, GRID_COLS - 1));
                            enemy.overworldY = Math.max(0, Math.min(enemy.overworldY, GRID_ROWS - 1));
                        }
                    });
                } else {
                    player.overworldX = 0;
                    player.overworldY = 0;
                    enemies.forEach(enemy => { enemy.overworldX = 0; enemy.overworldY = 0; });
                }
            }
            loadMap(currentMapId); 
        }

        // --- Lógica de Estados de Jogo e UI ---
        function updateUIBasedOnState() {
            if (gameState === 'overworld') {
                combatUiPanel.style.display = 'none';
                combatHotbarElement.style.display = 'none'; 
                playerInfoOverworldPanel.style.display = 'block';
                statusInfoDisplay.textContent = `Explorando: ${currentMapId}`;
                statusInfoDisplay.className = 'text-slate-400';
                selectedAction = null; 
                highlightedTiles = []; 
            } else if (gameState === 'combat') {
                combatUiPanel.style.display = 'block';
                combatHotbarElement.style.display = 'flex'; 
                playerInfoOverworldPanel.style.display = 'none';
                updateTurnInfo(); 
            }
        }
        
        function createHotbarSlots() {
            combatHotbarElement.innerHTML = ''; 
            for (let i = 1; i <= HOTBAR_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.classList.add('hotbar-slot');
                const slotNumber = document.createElement('span');
                slotNumber.classList.add('slot-number');
                slotNumber.textContent = i;
                slot.appendChild(slotNumber);
                slot.addEventListener('click', () => handleHotbarClick(i));
                combatHotbarElement.appendChild(slot);
            }
        }

        function handleHotbarClick(slotNumber) {
            if (gameState !== 'combat' || currentTurn !== 'player' || !player.isAlive) return;
            logGameMessage(`Slot ${slotNumber} da hotbar clicado (sem ação ainda).`, 2000);
        }

        function initiateCombat(enemyData) {
            activeCombatEnemy = JSON.parse(JSON.stringify(enemyData)); 
            gameState = 'combat';
            logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name}!`, 3000);
            
            player.gridX = (GRID_COLS > 1) ? 1 : 0; 
            player.gridY = GRID_ROWS > 0 ? Math.floor(GRID_ROWS / 2) : 0; 
            player.gridY = Math.max(0, Math.min(player.gridY, GRID_ROWS > 0 ? GRID_ROWS - 1 : 0));


            player.ap = player.maxAp;
            player.mp = player.maxMp;

            activeCombatEnemy.gridX = (GRID_COLS > 2) ? GRID_COLS - 2 : Math.max(0, GRID_COLS -1); 
            activeCombatEnemy.gridY = GRID_ROWS > 0 ? Math.floor(GRID_ROWS / 2) : 0;
            activeCombatEnemy.gridY = Math.max(0, Math.min(activeCombatEnemy.gridY, GRID_ROWS > 0 ? GRID_ROWS - 1 : 0));


            activeCombatEnemy.hp = activeCombatEnemy.combatStats.maxHp; 
            activeCombatEnemy.ap = activeCombatEnemy.combatStats.maxAp; 
            activeCombatEnemy.mp = activeCombatEnemy.combatStats.maxMp;
            activeCombatEnemy.isAliveCombat = true; 
            
            updateUIBasedOnState();
            startPlayerTurn();
        }

        function endCombat(victory) {
            if (victory) {
                const loot = activeCombatEnemy.combatStats.loot || {gold: 0};
                logGameMessage(`Você derrotou ${activeCombatEnemy.combatStats.name}! Recebeu ${loot.gold}g.`, 3000);
                player.gold += loot.gold;
                const originalEnemy = enemies.find(e => e.id === activeCombatEnemy.id);
                if(originalEnemy) originalEnemy.isAliveOverworld = false; 
                player.hp = player.maxHp; 
                // If defeated Rei Goblin, teleport to open world
                if (activeCombatEnemy.combatStats.name === 'Rei Goblin') {
                    setTimeout(() => {
                        logGameMessage('Você derrotou o Rei Goblin! O portal para o mundo aberto se abre...', 3500);
                        setTimeout(() => {
                            currentMapId = OPEN_WORLD_ID;
                            gameState = 'overworld';
                            loadMap(OPEN_WORLD_ID);
                        }, 3500);
                    }, 1000);
                    activeCombatEnemy = null;
                    return;
                }
            } else {
                logGameMessage("Você foi derrotado...", 5000);
                player.hp = Math.max(1, Math.floor(player.maxHp / 2)); 
                loadMap('mapa1', null); 
            }
            activeCombatEnemy = null;
            gameState = 'overworld';
            updateUIBasedOnState();
            updatePlayerOverworldInfo();
        }


        // --- Lógica de Turnos (Combate) ---
        function startPlayerTurn() {
            currentTurn = 'player';
            selectedAction = null;
            highlightedTiles = [];
            updatePlayerCombatInfo();
            updateTurnInfo();
            enableActionButtons(true);
        }

        function endPlayerTurn() {
            if (currentTurn !== 'player' || gameState !== 'combat' || !player.isAlive) return; 
            selectedAction = null;
            highlightedTiles = [];
            enableActionButtons(false);
            setTimeout(startEnemyTurn, 500); 
        }

        function startEnemyTurn() {
            if (gameState !== 'combat' || !activeCombatEnemy || activeCombatEnemy.hp <= 0 || !player.isAlive) {
                if (player.isAlive && activeCombatEnemy && activeCombatEnemy.hp <= 0) {
                    // console.log("[EnemyTurn] Inimigo já derrotado, finalizando combate (vitória).");
                    endCombat(true); 
                } else if (!player.isAlive) {
                    // console.log("[EnemyTurn] Jogador derrotado, finalizando combate (derrota).");
                    endCombat(false); 
                } else {
                    // console.log("[EnemyTurn] Condição inesperada, voltando para overworld.");
                    if (activeCombatEnemy && activeCombatEnemy.hp <=0) endCombat(true); // Garantir que vitória seja registrada se inimigo morreu
                    else gameState = 'overworld'; // Fallback para evitar loop infinito
                }
                return;
            }

            currentTurn = 'enemy';
            updateTurnInfo();
            
            const enemy = activeCombatEnemy;
            enemy.ap = enemy.combatStats.maxAp; 
            enemy.mp = enemy.combatStats.maxMp; 
            // console.log(`[EnemyTurn] Iniciado para ${enemy.combatStats.name}. HP: ${enemy.hp}, AP: ${enemy.ap}, MP: ${enemy.mp}`);

            let actionTakenThisTurn = false; 

            const distToPlayer = getGridDistance(enemy.gridX, enemy.gridY, player.gridX, player.gridY);
            // console.log(`[EnemyTurn] Distância para jogador: ${distToPlayer}, Alcance de ataque: ${enemy.combatStats.attackRange}, AP Inimigo: ${enemy.ap}`);

            // 1. Tentar Atacar
            if (distToPlayer <= enemy.combatStats.attackRange && enemy.ap > 0) {
                // console.log(`[EnemyTurn] ${enemy.combatStats.name} ATACANDO.`);
                player.hp -= enemy.combatStats.attackPower;
                enemy.ap--; 
                actionTakenThisTurn = true;
                if (player.hp <= 0) { player.hp = 0; player.isAlive = false; }
                logGameMessage(`${enemy.combatStats.name} ataca ${player.name} causando ${enemy.combatStats.attackPower} de dano! HP Jogador: ${player.hp}`, 2500);
                updatePlayerOverworldInfo(); 
                if (!player.isAlive) {
                    logGameMessage(`${player.name} foi derrotado!`, 4000);
                    setTimeout(() => endCombat(false), 1500);
                    return; 
                }
            } else {
                // if (distToPlayer > enemy.combatStats.attackRange) console.log(`[EnemyTurn] ${enemy.combatStats.name} não pode atacar: Fora de alcance.`);
                // if (enemy.ap <= 0) console.log(`[EnemyTurn] ${enemy.combatStats.name} não pode atacar: Sem AP.`);
            }

            // 2. Se não atacou, Tentar Mover
            if (!actionTakenThisTurn && enemy.mp > 0 && distToPlayer > 0) { 
                // console.log(`[EnemyTurn] ${enemy.combatStats.name} TENTANDO MOVER. MP: ${enemy.mp}.`);
                let bestMove = {x: enemy.gridX, y: enemy.gridY};
                let currentMinDistanceToPlayer = distToPlayer;
                let foundValidMove = false;

                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue; 

                        const newX = enemy.gridX + dx;
                        const newY = enemy.gridY + dy;

                        if (isValidCombatTile(newX, newY) && !isCombatTileOccupied(newX,newY, enemy)) {
                            const distanceToPlayerFromNewPos = getGridDistance(newX, newY, player.gridX, player.gridY);
                            if (distanceToPlayerFromNewPos < currentMinDistanceToPlayer) {
                                currentMinDistanceToPlayer = distanceToPlayerFromNewPos;
                                bestMove = {x: newX, y: newY};
                                foundValidMove = true;
                            }
                        }
                    }
                }
                
                if(foundValidMove){ 
                    // console.log(`[EnemyTurn] ${enemy.combatStats.name} MOVENDO de ${enemy.gridX},${enemy.gridY} para ${bestMove.x},${bestMove.y}`);
                    enemy.gridX = bestMove.x;
                    enemy.gridY = bestMove.y;
                    enemy.mp--;
                    actionTakenThisTurn = true; 
                    logGameMessage(`${enemy.combatStats.name} moveu-se.`, 1500);
                } else {
                    // console.log(`[EnemyTurn] ${enemy.combatStats.name} não encontrou movimento válido para se aproximar.`);
                }
            } else if (actionTakenThisTurn) {
                // console.log(`[EnemyTurn] ${enemy.combatStats.name} já agiu (atacou), não moverá.`);
            } else if (enemy.mp <= 0) {
                // console.log(`[EnemyTurn] ${enemy.combatStats.name} sem MP para mover.`);
            } else if (distToPlayer === 0) {
                // console.log(`[EnemyTurn] ${enemy.combatStats.name} já está no jogador, não moveu (ou deveria ter atacado).`);
            }
            
            player.ap = player.maxAp; 
            player.mp = player.maxMp;
            // console.log(`[EnemyTurn] Encerrando. Próximo turno: Jogador. AP Jogador: ${player.ap}, MP Jogador: ${player.mp}`);
            setTimeout(startPlayerTurn, 1000); 
        }
        
        function isCombatTileOccupied(gridX, gridY, selfEntity = null) {
            // Verifica se o jogador está na célula (e não é a própria entidade se selfEntity for o jogador)
            if (player.isAlive && player.gridX === gridX && player.gridY === gridY && player !== selfEntity) return true;
            // Verifica se o inimigo ativo está na célula (e não é a própria entidade se selfEntity for o inimigo ativo)
            if (activeCombatEnemy && activeCombatEnemy.hp > 0 && activeCombatEnemy.gridX === gridX && activeCombatEnemy.gridY === gridY && activeCombatEnemy !== selfEntity) return true;
            return false;
        }

        // --- Ações e Input ---
        function handleGlobalKeyDown(e) {
            if (document.activeElement === chatInput) return;
            if (gameState === 'overworld' && player.isAlive) handleOverworldKeyDown(e);
            else if (gameState === 'combat' && player.isAlive && currentTurn === 'player') handleCombatKeyDown(e);
        }

        function handleOverworldKeyDown(e) {
            let dx = 0, dy = 0;
            switch (e.key.toLowerCase()) {
                case 'arrowup': case 'w': dy = -1; break;
                case 'arrowdown': case 's': dy = 1; break;
                case 'arrowleft': case 'a': dx = -1; break;
                case 'arrowright': case 'd': dx = 1; break;
                default: return; 
            }
            e.preventDefault(); 

            if (currentMapId === OPEN_WORLD_ID) {
                const newX = player.overworldX + dx;
                const newY = player.overworldY + dy;
                if (!isValidOpenWorldTile(newX, newY)) return;
                // Monster collision
                for (const enemy of openWorldEnemies) {
                    if (enemy.isAliveOverworld && enemy.overworldX === newX && enemy.overworldY === newY) {
                        initiateOpenWorldCombat(enemy);
                        return;
                    }
                }
                if (openWorldMap && openWorldMap[newY] && openWorldMap[newY][newX] !== MAP_TILES.OBSTACLE_ROCK) {
                    player.overworldX = newX;
                    player.overworldY = newY;
                    // Camera follows
                    cameraX = player.overworldX;
                    cameraY = player.overworldY;
                }
            } else {
                const newOverworldX = player.overworldX + dx;
                const newOverworldY = player.overworldY + dy;
                const connections = mapConnections[currentMapId] || {};
                if (newOverworldX >= GRID_COLS && connections.right) { loadMap(connections.right, 'right'); return; }
                if (newOverworldX < 0 && connections.left) { loadMap(connections.left, 'left'); return; }
                if (newOverworldY >= GRID_ROWS && connections.down) { loadMap(connections.down, 'down'); return; }
                if (newOverworldY < 0 && connections.up) { loadMap(connections.up, 'up'); return; }
                if (!isValidOverworldTile(newOverworldX, newOverworldY)) return; 
                for (const enemy of enemies) {
                    if (enemy.isAliveOverworld && enemy.mapId === currentMapId && enemy.overworldX === newOverworldX && enemy.overworldY === newOverworldY) {
                        initiateCombat(enemy);
                        return; 
                    }
                }
                if (mapData && mapData.length > newOverworldY && mapData[newOverworldY] && mapData[newOverworldY].length > newOverworldX && mapData[newOverworldY][newOverworldX] !== MAP_TILES.OBSTACLE_ROCK) {
                    player.overworldX = newOverworldX;
                    player.overworldY = newOverworldY;
                }
            }
        }
        // --- Open World Camera/Tile helpers ---
        function isValidOpenWorldTile(x, y) {
            return x >= 0 && x < OPEN_WORLD_SIZE && y >= 0 && y < OPEN_WORLD_SIZE;
        }

        function initiateOpenWorldCombat(enemyData) {
            activeCombatEnemy = JSON.parse(JSON.stringify(enemyData));
            gameState = 'combat';
            logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name}!`, 3000);
            player.gridX = 1;
            player.gridY = Math.floor(GRID_ROWS / 2);
            player.ap = player.maxAp;
            player.mp = player.maxMp;
            activeCombatEnemy.gridX = GRID_COLS - 2;
            activeCombatEnemy.gridY = Math.floor(GRID_ROWS / 2);
            activeCombatEnemy.hp = activeCombatEnemy.combatStats.maxHp;
            activeCombatEnemy.ap = activeCombatEnemy.combatStats.ap;
            activeCombatEnemy.mp = activeCombatEnemy.combatStats.mp;
            activeCombatEnemy.isAliveCombat = true;
            updateUIBasedOnState();
            startPlayerTurn();
        }

        function handleCombatKeyDown(e) {
            switch (e.key.toLowerCase()) {
                case '1': e.preventDefault(); setSelectedAction('move'); break;
                case '2': e.preventDefault(); setSelectedAction('attack'); break;
                case ' ': e.preventDefault(); endPlayerTurn(); break;
                case 'w': case 'arrowup':
                case 's': case 'arrowdown':
                case 'a': case 'arrowleft':
                case 'd': case 'arrowright':
                    if (selectedAction === 'move') {
                        e.preventDefault();
                        let dx = 0, dy = 0;
                        if (e.key === 'w' || e.key === 'arrowup') dy = -1;
                        if (e.key === 's' || e.key === 'arrowdown') dy = 1;
                        if (e.key === 'a' || e.key === 'arrowleft') dx = -1;
                        if (e.key === 'd' || e.key === 'arrowright') dx = 1;
                        handleMoveActionCombat(player.gridX + dx, player.gridY + dy);
                    }
                    break;
            }
        }

        function setSelectedAction(action) {
            if (currentTurn !== 'player' || !player.isAlive || gameState !== 'combat') return;
            if (selectedAction === action) selectedAction = null;
            else selectedAction = action;
            updateHighlightedTiles();
            moveButton.classList.toggle('selected-action', selectedAction === 'move');
            attackButton.classList.toggle('selected-action', selectedAction === 'attack');
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const gridX = Math.floor((event.clientX - rect.left) / TILE_SIZE);
            const gridY = Math.floor((event.clientY - rect.top) / TILE_SIZE);

            if (gameState === 'overworld') {
                if (!isValidOverworldTile(gridX, gridY)) return; 
                for (const enemy of enemies) {
                    if (enemy.isAliveOverworld && enemy.mapId === currentMapId && enemy.overworldX === gridX && enemy.overworldY === gridY) {
                        initiateCombat(enemy); 
                        return;
                    }
                }
            } else if (gameState === 'combat') {
                if (currentTurn !== 'player' || !player.isAlive || !selectedAction) return;
                if (!isValidCombatTile(gridX, gridY)) return;
                if (selectedAction === 'move') handleMoveActionCombat(gridX, gridY);
                else if (selectedAction === 'attack') handleAttackActionCombat(gridX, gridY);
            }
        }

        function handleMoveActionCombat(targetGridX, targetGridY) {
            const distance = getGridDistance(player.gridX, player.gridY, targetGridX, targetGridY);
            if (player.mp >= distance && distance > 0 && !isCombatTileOccupied(targetGridX, targetGridY)) {
                player.gridX = targetGridX;
                player.gridY = targetGridY;
                player.mp -= distance; 
                if (player.mp <= 0) selectedAction = null; 
                updatePlayerCombatInfo();
                updateHighlightedTiles();
            }
        }

        function handleAttackActionCombat(targetGridX, targetGridY) {
            if (activeCombatEnemy && activeCombatEnemy.hp > 0 && activeCombatEnemy.gridX === targetGridX && activeCombatEnemy.gridY === targetGridY) {
                const distance = getGridDistance(player.gridX, player.gridY, targetGridX, targetGridY);
                if (distance <= player.attackRange && player.ap > 0) { 
                    activeCombatEnemy.hp -= player.attackPower;
                    player.ap--;
                    logGameMessage(`Atacou ${activeCombatEnemy.combatStats.name}! Dano: ${player.attackPower}.`, 2000);
                    if (activeCombatEnemy.hp <= 0) {
                        activeCombatEnemy.hp = 0;
                        setTimeout(() => endCombat(true), 1000); 
                    }
                    if (player.ap <= 0) selectedAction = null;
                    updatePlayerCombatInfo();
                    updateHighlightedTiles();
                } else {
                    logGameMessage("Fora de alcance ou sem AP!", 1500);
                }
            }
        }
        
        function updateHighlightedTiles() { 
            highlightedTiles = [];
            if (!selectedAction || gameState !== 'combat' || !player.isAlive) return; 
            const range = (selectedAction === 'move') ? player.mp : player.attackRange;
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const dist = getGridDistance(player.gridX, player.gridY, c, r);
                    if (dist > 0 && dist <= range) {
                        if (selectedAction === 'move' && !isCombatTileOccupied(c,r)) highlightedTiles.push({ x: c, y: r, type: 'move' });
                        else if (selectedAction === 'attack') highlightedTiles.push({ x: c, y: r, type: 'attack' });
                    }
                }
            }
        }
        
        function updateOverworldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld') return;
            lastAiUpdateTime = now;

            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);
                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) { 
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        
                        let newX = enemy.overworldX + dx;
                        let newY = enemy.overworldY; 

                        if (dx !== 0 && isValidOverworldTile(newX, newY) && mapData[newY] && mapData[newY][newX] !== MAP_TILES.OBSTACLE_ROCK && !(newX === player.overworldX && newY === player.overworldY)) {
                            enemy.overworldX = newX;
                        } else if (dy !== 0) { 
                            newX = enemy.overworldX; 
                            newY = enemy.overworldY + dy;
                            if (isValidOverworldTile(newX, newY) && mapData[newY] && mapData[newY][newX] !== MAP_TILES.OBSTACLE_ROCK && !(newX === player.overworldX && newY === player.overworldY)) {
                                enemy.overworldY = newY;
                            }
                        }
                    }
                }
            });
        }

        // --- Desenho ---
        function gameLoop() {
            if (!ctx) {
                 return; 
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (gameState === 'overworld') {
                if (currentMapId === OPEN_WORLD_ID) {
                    updateOpenWorldAI();
                    drawOpenWorld();
                } else {
                    updateOverworldAI();
                    drawOverworld();
                }
            } else if (gameState === 'combat') {
                drawCombat();
            }
            requestAnimationFrame(gameLoop);
        }

        function updateOpenWorldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld') return;
            lastAiUpdateTime = now;
            openWorldEnemies.forEach(enemy => {
                if (enemy.isAliveOverworld) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);
                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) {
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        let newX = enemy.overworldX + dx;
                        let newY = enemy.overworldY;
                        if (dx !== 0 && isValidOpenWorldTile(newX, newY) && openWorldMap[newY][newX] !== MAP_TILES.OBSTACLE_ROCK && !(newX === player.overworldX && newY === player.overworldY)) {
                            enemy.overworldX = newX;
                        } else if (dy !== 0) {
                            newX = enemy.overworldX;
                            newY = enemy.overworldY + dy;
                            if (isValidOpenWorldTile(newX, newY) && openWorldMap[newY][newX] !== MAP_TILES.OBSTACLE_ROCK && !(newX === player.overworldX && newY === player.overworldY)) {
                                enemy.overworldY = newY;
                            }
                        }
                    }
                }
            });
        }

        function drawOpenWorld() {
            // Camera center
            let halfW = Math.floor(cameraWidth / 2);
            let halfH = Math.floor(cameraHeight / 2);
            let camLeft = Math.max(0, Math.min(player.overworldX - halfW, OPEN_WORLD_SIZE - cameraWidth));
            let camTop = Math.max(0, Math.min(player.overworldY - halfH, OPEN_WORLD_SIZE - cameraHeight));
            // Draw visible tiles
            for (let r = 0; r < cameraHeight; r++) {
                for (let c = 0; c < cameraWidth; c++) {
                    let mapY = camTop + r;
                    let mapX = camLeft + c;
                    if (!isValidOpenWorldTile(mapX, mapY)) continue;
                    const tileType = openWorldMap[mapY][mapX];
                    const x = c * TILE_SIZE, y = r * TILE_SIZE;
                    switch (tileType) {
                        case MAP_TILES.OBSTACLE_ROCK: ctx.fillStyle = '#848b98'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case MAP_TILES.DECORATION_TREE:
                            ctx.fillStyle = '#225336'; ctx.fillRect(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.5, TILE_SIZE * 0.6, TILE_SIZE * 0.5);
                            ctx.fillStyle = '#38a169'; ctx.beginPath(); ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE * 0.35, TILE_SIZE * 0.35, 0, Math.PI * 2); ctx.fill();
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            ctx.fillStyle = '#48bb78'; ctx.beginPath();
                            ctx.arc(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.7, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5, TILE_SIZE * 0.25, 0, Math.PI * 2); ctx.fill();
                            break;
                    }
                }
            }
            // Draw monsters
            openWorldEnemies.forEach(enemy => {
                if (enemy.isAliveOverworld) {
                    let relX = enemy.overworldX - camLeft;
                    let relY = enemy.overworldY - camTop;
                    if (relX >= 0 && relX < cameraWidth && relY >= 0 && relY < cameraHeight) {
                        drawOpenWorldEntity(relX, relY, enemy.combatStats.color, enemy.combatStats.size);
                    }
                }
            });
            // Draw player
            let relPX = player.overworldX - camLeft;
            let relPY = player.overworldY - camTop;
            if (relPX >= 0 && relPX < cameraWidth && relPY >= 0 && relPY < cameraHeight) {
                drawOpenWorldEntity(relPX, relPY, player.color, player.size);
            }
        }

        function drawOpenWorldEntity(gridX, gridY, color, size) {
            const pixelX = gridX * TILE_SIZE + (TILE_SIZE - size) / 2;
            const pixelY = gridY * TILE_SIZE + (TILE_SIZE - size) / 2;
            ctx.fillStyle = color;
            ctx.fillRect(pixelX, pixelY, size, size);
        }

        function drawOverworld() {
            drawGrid(); 
            drawMapElements(); 
            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    drawOverworldEntity(enemy.overworldX, enemy.overworldY, enemy.combatStats.color, enemy.combatStats.size); 
                }
            });
            if (player.isAlive) drawOverworldEntity(player.overworldX, player.overworldY, player.color, player.size);
        }
        
        function drawMapElements() {
            if (!mapData || mapData.length === 0 || GRID_ROWS === 0 || GRID_COLS === 0) {
                return;
            }
            for (let r = 0; r < GRID_ROWS; r++) {
                if (!mapData[r]) continue; 
                for (let c = 0; c < GRID_COLS; c++) {
                    const tileType = mapData[r][c];
                    const x = c * TILE_SIZE, y = r * TILE_SIZE;
                    switch (tileType) {
                        case MAP_TILES.OBSTACLE_ROCK: ctx.fillStyle = '#848b98'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case MAP_TILES.DECORATION_TREE:
                            ctx.fillStyle = '#225336'; ctx.fillRect(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.5, TILE_SIZE * 0.6, TILE_SIZE * 0.5);
                            ctx.fillStyle = '#38a169'; ctx.beginPath(); ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE * 0.35, TILE_SIZE * 0.35, 0, Math.PI * 2); ctx.fill();
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            ctx.fillStyle = '#48bb78'; ctx.beginPath();
                            ctx.arc(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.7, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5, TILE_SIZE * 0.25, 0, Math.PI * 2); ctx.fill();
                            break;
                    }
                }
            }
        }

        function drawOverworldEntity(gridX, gridY, color, size) {
            const pixelX = gridX * TILE_SIZE + (TILE_SIZE - size) / 2;
            const pixelY = gridY * TILE_SIZE + (TILE_SIZE - size) / 2;
            ctx.fillStyle = color;
            ctx.fillRect(pixelX, pixelY, size, size);
        }

        function drawCombat() {
            drawGrid();
            drawHighlightedTiles();
            if (activeCombatEnemy && activeCombatEnemy.hp > 0) drawCombatCharacter(activeCombatEnemy, true);
            if (player.isAlive) drawCombatCharacter(player, false);
        }

        function drawGrid() { 
            if (GRID_COLS <=0 || GRID_ROWS <=0) return; 
            ctx.strokeStyle = '#4a5568'; ctx.lineWidth = 0.5; 
            for (let c = 0; c < GRID_COLS; c++) for (let r = 0; r < GRID_ROWS; r++) ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
        
        function drawHighlightedTiles() { highlightedTiles.forEach(tile => { ctx.fillStyle = tile.type === 'move' ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 0, 0, 0.2)'; ctx.fillRect(tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE); }); }

        function drawCombatCharacter(charData, isEnemy) {
            const entity = isEnemy ? charData : player;
            const combatStats = isEnemy ? entity.combatStats : player; 
            const displayColor = isEnemy ? (entity.colorFlash || combatStats.color) : player.color;
            const displaySize = combatStats.size;

            const pixelX = entity.gridX * TILE_SIZE + (TILE_SIZE - displaySize) / 2;
            const pixelY = entity.gridY * TILE_SIZE + (TILE_SIZE - displaySize) / 2;
            ctx.fillStyle = displayColor;
            ctx.fillRect(pixelX, pixelY, displaySize, displaySize);
            const hp = entity.hp, maxHp = combatStats.maxHp;
            const hpBarWidth = displaySize, hpBarHeight = 6, hpBarX = pixelX, hpBarY = pixelY - hpBarHeight - 3, hpRatio = maxHp > 0 ? hp / maxHp : 0;
            ctx.fillStyle = '#4b5563'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
            ctx.fillStyle = isEnemy ? 'red' : 'limegreen'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpRatio, hpBarHeight);
        }

        // --- Utilitários ---
        function isValidOverworldTile(gridX, gridY) { return gridX >= 0 && gridX < GRID_COLS && gridY >= 0 && gridY < GRID_ROWS; }
        function isValidCombatTile(gridX, gridY) { return gridX >= 0 && gridX < GRID_COLS && gridY >= 0 && gridY < GRID_ROWS; }
        function getGridDistance(x1, y1, x2, y2) { return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2)); }
        function logGameMessage(message, duration = 3000) { gameLogMessage.textContent = message; gameLogMessage.classList.remove('hidden'); if (gameLogMessage.timeoutId) clearTimeout(gameLogMessage.timeoutId); gameLogMessage.timeoutId = setTimeout(() => gameLogMessage.classList.add('hidden'), duration); }
        function updatePlayerOverworldInfo() { playerNameOverworldDisplay.textContent = player.name; playerHPOverworldDisplay.textContent = `${player.hp}/${player.maxHp}`; playerGoldOverworldDisplay.textContent = player.gold; }
        function updatePlayerCombatInfo() { playerAPCombatDisplay.textContent = `${player.ap}/${player.maxAp}`; playerMPCombatDisplay.textContent = `${player.mp}/${player.maxMp}`; }
        function updateTurnInfo() { if (gameState === 'combat') { statusInfoDisplay.textContent = currentTurn === 'player' ? "Seu Turno!" : `Turno de ${activeCombatEnemy ? activeCombatEnemy.combatStats.name : 'Inimigo'}...`; statusInfoDisplay.className = currentTurn === 'player' ? 'text-green-400 font-semibold' : 'text-red-400 font-semibold'; } }
        function enableActionButtons(enabled) { moveButton.disabled = !enabled; attackButton.disabled = !enabled; endTurnButton.disabled = !enabled; if (!enabled) { moveButton.classList.remove('selected-action'); attackButton.classList.remove('selected-action');} }
        function handleChatInput(event) { if (event.key === 'Enter' && chatInput.value.trim() !== '') { addChatMessage(player.name, chatInput.value.trim()); chatInput.value = ''; event.stopPropagation(); } }
        function addChatMessage(sender, message) { const p = document.createElement('p'); const esc = (str) => { const d=document.createElement('div'); d.appendChild(document.createTextNode(str)); return d.innerHTML; }; p.innerHTML = `<span class="font-semibold ${sender === player.name ? 'text-green-300' : 'text-sky-300'}">[${esc(sender)}]:</span> ${esc(message)}`; chatMessages.appendChild(p); chatMessages.scrollTop = chatMessages.scrollHeight; }

        // --- Patch: Remove defeated open world monsters ---
        // After combat, if in open world, mark monster as dead
        const _oldEndCombat = endCombat;
        endCombat = function(victory) {
            if (currentMapId === OPEN_WORLD_ID && activeCombatEnemy && victory) {
                // Remove monster from open world
                const idx = openWorldEnemies.findIndex(e => e.id === activeCombatEnemy.id);
                if (idx !== -1) openWorldEnemies[idx].isAliveOverworld = false;
            }
            _oldEndCombat.apply(this, arguments);
        }

        // --- Iniciar o Jogo ---
        document.addEventListener('DOMContentLoaded', initGame);
    </script>
</body>
</html>
