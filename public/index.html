<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMORPG T√°tico com Overworld</title>
    <!-- Replace Tailwind CSS CDN with locally compiled CSS -->
    <link href="/tailwind.css" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a202c; /* cinza escuro Tailwind */
            color: #e2e8f0; /* ard√≥sia clara Tailwind */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #game-and-ui-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
        }
        #main-content-area {
            display: flex;
            flex-direction: row; /* Para UI lateral */
            gap: 1rem;
            width: 100%;
            justify-content: center;
            align-items: flex-start; /* Alinha o painel lateral com o topo do game-container */
        }
        #game-area-wrapper { /* Novo wrapper para canvas e hotbar */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 70vw; /* Ajustar conforme necess√°rio */
            max-width: 800px;
        }
        #game-container {
            width: 100%; /* Ocupa toda a largura do game-area-wrapper */
            max-height: 600px; /* Mant√©m uma altura m√°xima */
            background-color: #2d3748; 
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            position: relative;
            aspect-ratio: 4 / 3; /* Exemplo de aspect ratio, ajuste conforme necess√°rio */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 0.375rem;
            cursor: pointer;
            background-color: #374151; 
        }
        #combat-hotbar {
            display: none; /* Inicialmente escondida */
            justify-content: center;
            gap: 0.5rem; /* Espa√ßo entre os slots */
            padding: 0.5rem;
            background-color: #2d3748; /* Cor similar aos pain√©is */
            border: 1px solid #4a5568;
            border-top: none; /* Para parecer conectado ao game-container se posicionado abaixo */
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
            width: 100%; /* Ocupa toda a largura do game-area-wrapper */
            box-sizing: border-box;
            margin-top: -1px; 
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background-color: #1a202c; 
            border: 1px solid #4a5568; 
            border-radius: 0.25rem; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; 
            color: #a0aec0; 
            cursor: pointer;
            position: relative; 
        }
        .hotbar-slot .slot-number {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.65rem;
            color: #718096; 
        }

        #right-ui-panel {
            width: 25vw;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .ui-panel {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        #chat-messages {
            background-color: #1e293b;
            padding: 0.5rem;
            border-radius: 0.375rem;
            height: 100px;
            overflow-y: auto;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        #chat-input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #4a5568;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .game-message {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 0.375rem;
            font-size: 0.9em;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            text-align: center;
        }
        .action-button {
            background-color: #38a169; 
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            font-weight: 600;
        }
        .action-button:hover {
            background-color: #2f855a; 
        }
        .action-button:disabled {
            background-color: #4a5568; 
            cursor: not-allowed;
        }
        .selected-action {
            background-color: #dd6b20; 
        }
        .selected-action:hover {
            background-color: #c05621; 
        }
        .combat-ui {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-slate-200 flex flex-col items-center min-h-screen p-4">
    <div id="auth-modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(20,23,35,0.96);display:flex;align-items:center;justify-content:center;z-index:9999;">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-full max-w-xs flex flex-col items-center">
            <h2 class="text-2xl font-bold text-emerald-400 mb-4">Entrar no Jogo</h2>
            <form id="login-form" class="w-full flex flex-col gap-2">
                <input id="login-username" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Usu√°rio" autocomplete="username" required>
                <input id="login-password" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Senha" type="password" autocomplete="current-password" required>
                <button type="submit" class="action-button w-full">Entrar</button>
            </form>
            <div class="text-slate-400 text-sm my-2">ou</div>
            <form id="register-form" class="w-full flex flex-col gap-2">
                <input id="register-username" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Novo usu√°rio" autocomplete="username" required>
                <input id="register-password" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Senha" type="password" autocomplete="new-password" required>
                <button type="submit" class="action-button w-full bg-sky-600 hover:bg-sky-700">Cadastrar</button>
            </form>
            <div id="auth-error" class="text-red-400 text-sm mt-2" style="display:none"></div>
        </div>
    </div>

    <header class="mb-6 text-center">
        <h1 class="text-4xl font-bold text-emerald-400">MMORPG T√°tico</h1>
        <p class="text-slate-400" id="statusInfo">Explorando o mundo...</p>
    </header>

    <div id="game-and-ui-wrapper">
        <div id="main-content-area">
            <div id="game-area-wrapper">
                <div id="game-container" class="shadow-2xl">
                    <canvas id="gameCanvas"></canvas>
                    <div id="gameLogMessage" class="game-message hidden"></div>
                </div>
                <div id="combat-hotbar">
                    </div>
            </div>

            <div id="right-ui-panel">                <div id="player-info-overworld" class="ui-panel">
                        <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Jogador</h2>
                        <p><strong>Nome:</strong> <span id="playerNameOverworld">Aventureiro</span></p>
                        <p><strong>HP:</strong> <span id="playerHPOverworld">100/100</span></p>                        <p><strong>Ouro:</strong> <span id="playerGoldOverworld">0</span>g</p>
                        <div class="mt-3 space-y-2">
                            <button id="stats-btn" class="action-button w-full bg-purple-600 hover:bg-purple-700 text-sm">üìä Estat√≠sticas</button>
                        </div>
                        <div id="save-status" class="text-xs mt-2 text-slate-400">
                            <span id="auto-save-indicator">üîÑ Auto-save ativo</span>
                            <br><span id="last-save-time">√öltimo save: nunca</span>
                        </div>
                        <p class="text-xs mt-2">Setas: Mover. Encoste em inimigos para lutar.</p>
                </div>

                <div id="combat-ui-panel" class="ui-panel combat-ui">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Combate</h2>
                    <div id="player-stats-combat" class="text-sm space-y-1">
                        <p><strong>AP:</strong> <span id="playerAPCombat">0/0</span></p>
                        <p><strong>MP:</strong> <span id="playerMPCombat">0/0</span></p>
                    </div>
                    <div class="mt-3 space-y-2">
                        <button id="moveButton" class="action-button w-full">Mover (1)</button>
                        <button id="attackButton" class="action-button w-full">Atacar (2)</button>
                        <button id="endTurnButton" class="action-button w-full bg-sky-600 hover:bg-sky-700">Passar Turno (Espa√ßo)</button>
                    </div>
                </div>

                <div id="chat-box-container" class="ui-panel">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Chat</h2>
                    <div id="chat-messages">
                        <p><span class="font-bold text-yellow-400">[Sistema]:</span> Bem-vindo! V√° para a direita para avan√ßar de mapa.</p>
                    </div>
                    <input type="text" id="chat-input" placeholder="Digite sua mensagem..." class="focus:outline-none focus:border-emerald-500">
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Multiplayer: Socket.IO instance ---
        const socket = io(); // Conecta ao servidor Socket.IO (mesmo host/porta por padr√£o)
        let localPlayerId = null; // Ser√° definido ap√≥s login/conex√£o
        let otherPlayers = {}; // Armazena dados de outros jogadores: { playerId: {x, y, name, color, mapId} }


        // --- Autentica√ß√£o: Modal de Login/Cadastro ---
        const authModal = document.getElementById('auth-modal');
        function showAuthModal() { authModal.style.display = 'flex'; }
        function hideAuthModal() { authModal.style.display = 'none'; }
        function setAuthError(msg) { const err = document.getElementById('auth-error'); err.textContent = msg; err.style.display = 'block'; }
        function clearAuthError() { const err = document.getElementById('auth-error'); err.textContent = ''; err.style.display = 'none'; }
        function saveSession(token, username) { localStorage.setItem('sessionToken', token); localStorage.setItem('username', username); }
        function clearSession() { localStorage.removeItem('sessionToken'); localStorage.removeItem('username'); }
        function getSession() { return { token: localStorage.getItem('sessionToken'), username: localStorage.getItem('username') }; }

        // Login
        document.getElementById('login-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            clearAuthError();
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            try {
                const res = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ login: username, password })
                });
                if (res.ok) {
                    const data = await res.json();
                    saveSession(data.token, username);
                    player.name = username;
                    localPlayerId = username; // Multiplayer: Define o ID do jogador local
                    hideAuthModal();
                    startGameAfterAuth();
                } else {
                    const errorData = await res.json().catch(() => ({ error: 'Usu√°rio ou senha inv√°lidos.' }));
                    setAuthError(errorData.error || 'Usu√°rio ou senha inv√°lidos.');
                }
            } catch (error) {
                // console.error("Erro no login:", error);
                setAuthError('Erro de conex√£o ao tentar fazer login.');
            }
        });

        // Cadastro
        document.getElementById('register-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            clearAuthError();
            const username = document.getElementById('register-username').value.trim();
            const password = document.getElementById('register-password').value;
            try {
                const res = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ login: username, password })
                });
                if (res.ok) {
                    // Ap√≥s cadastro, faz login autom√°tico
                    const loginRes = await fetch('/api/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ login: username, password })
                    });
                    if (loginRes.ok) {
                        const loginData = await loginRes.json();
                        saveSession(loginData.token, username);
                        player.name = username;
                        localPlayerId = username; // Multiplayer: Define o ID do jogador local
                        hideAuthModal();
                        startGameAfterAuth();
                    } else {
                        setAuthError('Erro ao fazer login autom√°tico ap√≥s cadastro.');
                    }
                } else {
                    let msg = 'Erro ao cadastrar.';
                    try { const err = await res.json(); if (err && err.error) { msg = err.error; } } catch {}
                    setAuthError(msg);
                }
            } catch (error) {
                // console.error("Erro no cadastro:", error);
                setAuthError('Erro de conex√£o ao tentar cadastrar.');
            }
        });

        // Logout (bot√£o no painel do jogador)
        function addLogoutButton() {
            let btn = document.getElementById('logout-btn');
            if (!btn) {
                btn = document.createElement('button');
                btn.id = 'logout-btn';
                btn.textContent = 'Sair';
                btn.className = 'action-button w-full bg-red-600 hover:bg-red-700 mt-3';                btn.onclick = async () => {
                    // No save before logout - SIMPLIFIED: Only save after combat
                    // showSaveNotification('Saving progress before logout...');
                    // await savePlayerData('logout');
                    
                    if (socket && localPlayerId) { // Multiplayer: Notifica o servidor sobre a sa√≠da
                        socket.emit('playerDisconnecting', { playerId: localPlayerId, mapId: currentMapId });
                    }
                    clearSession();
                    localPlayerId = null;
                    otherPlayers = {};
                    showAuthModal();
                    location.reload(); // Recarrega a p√°gina para limpar o estado do jogo
                };
                playerInfoOverworldPanel.appendChild(btn);
            }
        }

        // Bloqueia inicializa√ß√£o do jogo at√© autenticar
        let gameInitialized = false;        function startGameAfterAuth() {
            if (gameInitialized) return;
            gameInitialized = true;
            player.name = getSession().username || 'Aventureiro';
            if (!localPlayerId && player.name !== 'Aventureiro') { // Garante que localPlayerId seja definido
                localPlayerId = player.name;
            }            addLogoutButton();
            
            // Initialize auto-save system
            hookAutoSaveTriggers();
            startPeriodicSave();
            initializeSaveUI();
            
            // Load player data immediately after authentication
            console.log('üéÆ Starting game after auth, loading player data...');
            loadPlayerData();
            
            initGame(); // initGame agora tamb√©m configura os listeners do socket
            // Load the map once after auth so we have initial map data
            loadMap(currentMapId);
        }        // --- Elementos do DOM ---
        let canvas, ctx, gameContainer; // Declare variables but don't initialize them yet
        let combatHotbarElement, chatInput, chatMessages, gameLogMessage, statusInfoDisplay;
        let playerNameOverworldDisplay, playerHPOverworldDisplay, playerGoldOverworldDisplay;
        let playerAPCombatDisplay, playerMPCombatDisplay, combatUiPanel, playerInfoOverworldPanel;
        let moveButton, attackButton, endTurnButton;

        // Ao carregar a p√°gina, verifica sess√£o
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize DOM elements after DOM is fully loaded
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            gameContainer = document.getElementById('game-container');
            combatHotbarElement = document.getElementById('combat-hotbar'); 
            chatInput = document.getElementById('chat-input');
            chatMessages = document.getElementById('chat-messages');
            gameLogMessage = document.getElementById('gameLogMessage');
            statusInfoDisplay = document.getElementById('statusInfo');

            playerNameOverworldDisplay = document.getElementById('playerNameOverworld');
            playerHPOverworldDisplay = document.getElementById('playerHPOverworld');
            playerGoldOverworldDisplay = document.getElementById('playerGoldOverworld');
            
            playerAPCombatDisplay = document.getElementById('playerAPCombat');
            playerMPCombatDisplay = document.getElementById('playerMPCombat');
            combatUiPanel = document.getElementById('combat-ui-panel');
            playerInfoOverworldPanel = document.getElementById('player-info-overworld');

            moveButton = document.getElementById('moveButton');
            attackButton = document.getElementById('attackButton');
            endTurnButton = document.getElementById('endTurnButton');
            
            // Verify canvas and context are properly initialized
            if (!canvas) {
                console.error('‚ùå Canvas element not found!');
                return;
            }
            if (!ctx) {
                console.error('‚ùå Canvas context not found!');
                return;
            }
            console.log('‚úÖ Canvas and context initialized successfully');
            
            const session = getSession();
            if (session.token && session.username) {
                localPlayerId = session.username; // Multiplayer: Define o ID do jogador local
                hideAuthModal();
                startGameAfterAuth();
            } else {
                showAuthModal();
            }        });

        // --- Configura√ß√µes do Jogo ---
        const TILE_SIZE = 40; 
        let GRID_COLS, GRID_ROWS; 
        
        let gameState = 'overworld'; 
        const HOTBAR_SLOTS = 5; 
        let currentMapId = 'open_world'; // Mapa inicial - Open World
        let lastAiUpdateTime = 0;
        const AI_UPDATE_INTERVAL = 500; 

        // --- Open World (grande) ---
        const OPEN_WORLD_ID = 'open_world';
        const OPEN_WORLD_SIZE = 200;
        let openWorldMap = null; // 2D array
        let openWorldEnemies = [];
        let cameraX = 0, cameraY = 0;
        let cameraWidth = 0, cameraHeight = 0;

        // --- Dados do Mapa Overworld ---
        const MAP_TILES = {
            EMPTY: 0,
            OBSTACLE_ROCK: 1,
            DECORATION_TREE: 2,
            DECORATION_BUSH: 3,
        };        const mapConnections = {
            // Tutorial maps removed - game starts in open world
        };

        let mapData = [];        function generateMapFor(mapId) {
            // Multiplayer: Now using server-generated map data when available
            // The client will receive map layout from server via 'mapState' event
              if (mapId === OPEN_WORLD_ID) {
                // Don't generate open world locally anymore - wait for server data
                // The server will send the persistent map layout via mapState event
                if (!openWorldMap) {
                    // Temporary fallback while waiting for server data
                    console.log('‚è≥ Waiting for server map data for open world...');
                    openWorldMap = [];
                    for (let r = 0; r < OPEN_WORLD_SIZE; r++) {
                        openWorldMap[r] = [];
                        for (let c = 0; c < OPEN_WORLD_SIZE; c++) {
                            openWorldMap[r][c] = MAP_TILES.EMPTY; // Empty until server sends data
                        }
                    }
                    openWorldEnemies = []; // Will be populated by server data
                }
                mapData = openWorldMap;
                console.log('üåç Open world map prepared - awaiting server data...');
            } else { // Mapas menores
                mapData = [];
                if (GRID_ROWS <= 0 || GRID_COLS <= 0) return; 
                for (let r = 0; r < GRID_ROWS; r++) {
                    mapData[r] = [];
                    for (let c = 0; c < GRID_COLS; c++) mapData[r][c] = MAP_TILES.EMPTY;
                }
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        if (r === 0 || r === GRID_ROWS - 1 || c === 0 || c === GRID_COLS - 1) {
                            const connections = mapConnections[mapId] || {};
                            let isConnectionTile = false;
                            if (r === 0 && connections.up) isConnectionTile = true;
                            else if (r === GRID_ROWS - 1 && connections.down) isConnectionTile = true;
                            else if (c === 0 && connections.left) isConnectionTile = true;
                            else if (c === GRID_COLS - 1 && connections.right) isConnectionTile = true;
                            if (!isConnectionTile) mapData[r][c] = MAP_TILES.OBSTACLE_ROCK;
                        }
                    }
                }
                let rockDensity = 0.05, decorDensity = 0.1;
                if (mapId === 'mapa_chefe') { rockDensity = 0.1; decorDensity = 0.05; }
                for (let r = 1; r < GRID_ROWS - 1; r++) { 
                    for (let c = 1; c < GRID_COLS - 1; c++) {
                        let isEntitySpawn = (r === player.overworldY && c === player.overworldX);
                        if (!isEntitySpawn) {
                            for (const enemy of enemies) { // Usa a lista 'enemies' para mapas normais
                                if (enemy.mapId === mapId && enemy.isAliveOverworld && enemy.overworldY === r && enemy.overworldX === c) {
                                    isEntitySpawn = true; break;
                                }
                            }
                        }
                        if (isEntitySpawn) continue; 
                        if (Math.random() < rockDensity) mapData[r][c] = MAP_TILES.OBSTACLE_ROCK;
                        else if (Math.random() < decorDensity) mapData[r][c] = Math.random() < 0.5 ? MAP_TILES.DECORATION_TREE : MAP_TILES.DECORATION_BUSH;
                    }
                }
                if (isValidOverworldTile(player.overworldX, player.overworldY) && mapData[player.overworldY]) { 
                    mapData[player.overworldY][player.overworldX] = MAP_TILES.EMPTY;
                }
                enemies.forEach(enemy => {
                    if (enemy.mapId === mapId && enemy.isAliveOverworld && isValidOverworldTile(enemy.overworldX, enemy.overworldY)) {
                        if(mapData[enemy.overworldY]) mapData[enemy.overworldY][enemy.overworldX] = MAP_TILES.EMPTY;
                    }
                });
            }
        }


        let player = {
            overworldX: 1, overworldY: 1, 
            gridX: 0, gridY: 0,
            size: TILE_SIZE * 0.8,
            color: 'deepskyblue', // Cor padr√£o do jogador local
            hp: 100, maxHp: 100,
            ap: 60, maxAp: 60,
            mp: 30, maxMp: 30,
            attackPower: 15,
            attackRange: 2, 
            isAlive: true,
            name: "Aventureiro",
            gold: 0,
        };        let enemies = [ 
            // Tutorial enemies removed - game starts in open world
            // Only combat-only enemies remain for special encounters
            { id: -1, mapId: 'combate_apenas', overworldX: -1, overworldY: -1, isAliveOverworld: false, combatStats: { size: TILE_SIZE * 0.7, color: 'crimson', hp: 50, maxHp: 50, ap: 4, maxAp: 4, mp: 2, maxMp: 2, attackPower: 8, attackRange: 1, name: "Guarda Goblin" } },
        ];
        let activeCombatEnemy = null; 

        let currentTurn = 'player'; 
        let selectedAction = null; 
        let highlightedTiles = []; 

        // --- Inicializa√ß√£o ---
        function initGame() {
            if (!ctx) {
                // console.error("Contexto do canvas n√£o encontrado. O jogo n√£o pode ser iniciado.");
                return;
            }
            resizeCanvas(); 
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleGlobalKeyDown); 
            canvas.addEventListener('click', handleCanvasClick);
            moveButton.addEventListener('click', () => setSelectedAction('move'));
            attackButton.addEventListener('click', () => setSelectedAction('attack'));
            endTurnButton.addEventListener('click', endPlayerTurn);
            chatInput.addEventListener('keypress', handleChatInput);
            createHotbarSlots(); 

            // Multiplayer: Configurar listeners do Socket.IO
            setupSocketListeners();

            gameLoop(); 
        }

        // Multiplayer: Fun√ß√£o para configurar listeners do Socket.IO
        function setupSocketListeners() {
            if (!socket) {
                // console.error("Socket n√£o inicializado.");
                return;
            }

            // Enhanced connection handling
            socket.on('connect', () => {
                console.log('üîó Connected to server');
                showSaveNotification('Connected to server');
                
                // Authenticate with server
                const session = getSession();
                if (session.token && session.username) {
                    socket.emit('authenticate', {
                        login: session.username,
                        sessionToken: session.token
                    });
                }
                
                if (localPlayerId) { 
                    loadMap(currentMapId); 
                }
            });            socket.on('disconnect', (reason) => {
                console.log('‚ùå Disconnected from server:', reason);
                addChatMessage('[Sistema]', 'Conex√£o perdida. Tentando reconectar...');
                otherPlayers = {}; 
                
                // Don't attempt to save on disconnect as connection is already lost
                console.log('üíæ Skipping save on disconnect to prevent connection errors');
            });

            socket.on('reconnect', (attemptNumber) => {
                console.log('üîÑ Reconnected to server after', attemptNumber, 'attempts');
                showSaveNotification('Reconnected to server!');
                addChatMessage('[Sistema]', 'Conex√£o reestabelecida!');
                
                // Re-authenticate after reconnection
                const session = getSession();
                if (session.token && session.username) {
                    socket.emit('authenticate', {
                        login: session.username,
                        sessionToken: session.token
                    });
                }
            });

            socket.on('reconnect_error', (error) => {
                console.error('‚ùå Reconnection failed:', error);
                addChatMessage('[Sistema]', 'Falha ao reconectar. Tente atualizar a p√°gina.');
            });            socket.on('mapState', (data) => {
                if (data.mapId === currentMapId) {
                    otherPlayers = {}; 
                    data.players.forEach(p => {
                        if (p.playerId !== localPlayerId) {
                            otherPlayers[p.playerId] = {
                                x: p.x,
                                y: p.y,
                                name: p.name || `Jogador ${p.playerId.substring(0,4)}`,
                                color: p.color || '#cccccc', 
                                mapId: p.mapId 
                            };
                        }
                    });
                    
                    // Apply server-provided map layout and enemies data
                    if (data.mapLayoutData) {
                        console.log('‚úÖ Received server map layout for', currentMapId);
                        if (currentMapId === OPEN_WORLD_ID) {
                            openWorldMap = data.mapLayoutData;
                            mapData = openWorldMap;
                        } else {
                            mapData = data.mapLayoutData;
                        }
                    }
                      // Apply server-provided enemies data
                    if (data.enemies) {
                        console.log('‚úÖ Received server enemies data for', currentMapId, '- Count:', data.enemies.length);
                        console.log('[DEBUG] First enemy loot data:', data.enemies[0]?.combatStats?.loot);                        if (currentMapId === OPEN_WORLD_ID) {
                            openWorldEnemies = data.enemies.map(e => ({
                                id: e.id,
                                overworldX: e.overworldX,
                                overworldY: e.overworldY,
                                isAliveOverworld: e.isAliveOverworld,
                                aggroRange: e.aggroRange,
                                combatStats: e.combatStats,
                                inCombat: e.inCombat || false,
                                combatPlayerId: e.combatPlayerId || null
                            }));
                            console.log('[DEBUG] First openWorldEnemy loot:', openWorldEnemies[0]?.combatStats?.loot);
                            // Additional debug: Test combat simulation
                            if (openWorldEnemies.length > 0) {
                                console.log('[DEBUG] Enemy 0 full combatStats:', openWorldEnemies[0].combatStats);
                                const testLoot = openWorldEnemies[0].combatStats.loot;
                                console.log('[DEBUG] Test loot extraction:', testLoot);
                                console.log('[DEBUG] Test loot gold value:', testLoot?.gold);
                            }
                        } else {
                            // Update enemies list for regular maps
                            enemies = enemies.filter(e => e.mapId !== currentMapId);                            data.enemies.forEach(serverEnemy => {
                                enemies.push({
                                    id: serverEnemy.id,
                                    mapId: currentMapId,
                                    overworldX: serverEnemy.overworldX,
                                    overworldY: serverEnemy.overworldY,
                                    isAliveOverworld: serverEnemy.isAliveOverworld,
                                    aggroRange: serverEnemy.aggroRange,
                                    combatStats: serverEnemy.combatStats,
                                    inCombat: serverEnemy.inCombat || false,
                                    combatPlayerId: serverEnemy.combatPlayerId || null
                                });
                            });
                        }
                    }
                    
                    console.log('üìä Map state updated for', currentMapId, '- Players:', Object.keys(otherPlayers).length);
                }
            });

            socket.on('playerJoined', (newPlayerData) => {
                if (newPlayerData.mapId === currentMapId && newPlayerData.playerId !== localPlayerId) {
                    otherPlayers[newPlayerData.playerId] = {
                        x: newPlayerData.x,
                        y: newPlayerData.y,
                        name: newPlayerData.name || `Jogador ${newPlayerData.playerId.substring(0,4)}`,
                        color: newPlayerData.color || '#cccccc',
                        mapId: newPlayerData.mapId
                    };
                    addChatMessage('[Sistema]', `${otherPlayers[newPlayerData.playerId].name} entrou no mapa.`);
                    // console.log('Jogador entrou:', newPlayerData.playerId, "em", newPlayerData.mapId);
                }
            });

            socket.on('playerMoved', (moveData) => {
                if (moveData.mapId === currentMapId && moveData.playerId !== localPlayerId) {
                    if (otherPlayers[moveData.playerId]) {
                        otherPlayers[moveData.playerId].x = moveData.x;
                        otherPlayers[moveData.playerId].y = moveData.y;
                    } else {
                        otherPlayers[moveData.playerId] = {
                            x: moveData.x, y: moveData.y, name: `Jogador ${moveData.playerId.substring(0,4)}`, color: '#cccccc', mapId: moveData.mapId
                        };
                    }
                    // console.log('Jogador moveu:', moveData.playerId, "para", moveData.x, moveData.y);
                }
            });

            socket.on('playerLeft', (leaveData) => {
                if (leaveData.mapId === currentMapId && otherPlayers[leaveData.playerId]) {
                    addChatMessage('[Sistema]', `${otherPlayers[leaveData.playerId].name || 'Um jogador'} saiu do mapa.`);
                    delete otherPlayers[leaveData.playerId];
                    // console.log('Jogador saiu:', leaveData.playerId);
                }
            });
            
            socket.on('chatMessage', (data) => {
                if (data.senderId !== localPlayerId) { 
                    addChatMessage(data.senderName, data.message);
                }
            });            socket.on('combatStarted', (data) => {
                console.log(`[DEBUG] Received combatStarted event:`, data);
                const { opponent } = data;
                activeCombatEnemy = opponent;
                gameState = 'combat';
                logGameMessage(`Combate iniciado com ${opponent.combatStats.name}!`, 3000);
                initiateCombat(opponent);
            });

            // Handle enemy combat status changes for multiplayer visibility
            socket.on('enemyCombatStatusChanged', (data) => {
                const { enemyId, inCombat, combatPlayerId } = data;
                console.log(`[COMBAT] Enemy ${enemyId} combat status changed: inCombat=${inCombat}, player=${combatPlayerId}`);
                
                // Update enemy combat status in both enemy lists
                if (currentMapId === OPEN_WORLD_ID) {
                    const enemy = openWorldEnemies.find(e => e.id === enemyId);
                    if (enemy) {
                        enemy.inCombat = inCombat;
                        enemy.combatPlayerId = combatPlayerId;
                    }
                } else {
                    const enemy = enemies.find(e => e.id === enemyId && e.mapId === currentMapId);
                    if (enemy) {
                        enemy.inCombat = inCombat;
                        enemy.combatPlayerId = combatPlayerId;
                    }
                }            });

            // Handle enemy defeated broadcast from server
            socket.on('enemyDefeated', (data) => {
                const { enemyId, mapId } = data;
                console.log(`[ENEMY DEFEATED] Enemy ${enemyId} defeated in map ${mapId} - removing from local game world`);
                
                if (mapId === currentMapId) {
                    if (currentMapId === OPEN_WORLD_ID) {
                        // Immediately remove defeated open world enemy
                        openWorldEnemies = openWorldEnemies.filter(e => e.id !== enemyId);
                        console.log(`[ENEMY DEFEATED] Open world enemy ${enemyId} removed from local game world`);
                    } else {
                        // Immediately remove defeated regular map enemy
                        enemies = enemies.filter(e => !(e.id === enemyId && e.mapId === currentMapId));
                        console.log(`[ENEMY DEFEATED] Regular map enemy ${enemyId} removed from local game world`);
                    }
                }
            });

            // Server-side monster position updates
            socket.on('monsterPositionUpdate', (data) => {
                if (data.mapId === currentMapId) {
                    data.monsters.forEach(monsterUpdate => {
                        // Update open world enemies
                        if (currentMapId === OPEN_WORLD_ID) {
                            const enemy = openWorldEnemies.find(e => e.id === monsterUpdate.id);
                            if (enemy) {
                                enemy.overworldX = monsterUpdate.overworldX;
                                enemy.overworldY = monsterUpdate.overworldY;
                            }
                        } else {
                            // Update regular map enemies
                            const enemy = enemies.find(e => e.id === monsterUpdate.id && e.mapId === currentMapId);
                            if (enemy) {
                                enemy.overworldX = monsterUpdate.overworldX;
                                enemy.overworldY = monsterUpdate.overworldY;
                            }
                        }
                    });
                }
            });// Enhanced Auto-Save Integration
            socket.on('authenticationSuccess', () => {
                console.log('‚úÖ Authentication successful via socket');
                // Only load data if it hasn't been loaded yet (fallback protection)
                if (player.gold === undefined || player.gold === 0) {
                    console.log('üîÑ Loading player data via socket authentication success...');
                    loadPlayerData();
                } else {
                    console.log('üìä Player data already loaded, skipping duplicate load');
                }
            });

            socket.on('authenticationFailed', (data) => {
                console.log('‚ùå Authentication failed:', data);
                const { message, code, userExists, login } = data;
                
                if (code === 'TOKEN_MISMATCH') {
                    console.log('üîß Token mismatch detected, cleaning up session...');
                    cleanupSession().then(() => {
                        alert('Session expired. Please login again.');
                        clearSession();
                        location.reload();
                    }).catch(err => {
                        console.error('Failed to cleanup session:', err);
                        alert('Session error. Please login again.');
                        clearSession();
                        location.reload();
                    });
                } else if (code === 'USER_NOT_FOUND') {
                    console.log('üë§ User not found, attempting to create user...');
                    createUser(login).then(() => {
                        alert('User created successfully. Please login again.');
                        clearSession();
                        location.reload();
                    }).catch(err => {
                        console.error('Failed to create user:', err);
                        alert('Failed to create user. Please contact support.');
                        clearSession();
                        location.reload();
                    });
                } else {
                    alert(message || 'Authentication failed. Please login again.');
                    clearSession();
                    location.reload();
                }
            });

            socket.on('playerStatsUpdate', (stats) => {
                // Update local player statistics
                playerStatistics = stats;
                updateStatsDisplay();
            });

            socket.on('saveConfirmation', (data) => {
                const { triggerType, message } = data;
                showSaveNotification(message || `Progress saved (${triggerType})`);
            });            socket.on('sessionInvalidated', (data) => {
                alert(data.message || 'Your session has been invalidated.');
                clearSession();
                location.reload();
            });

            // Handle periodic map state synchronization from server
            socket.on('mapStateSync', (data) => {
                if (data.mapId === currentMapId) {
                    console.log(`üîÑ [MAP SYNC] Received periodic map state sync for ${currentMapId}`);
                    
                    // Update other players
                    otherPlayers = {};
                    data.players.forEach(p => {
                        if (p.playerId !== localPlayerId) {
                            otherPlayers[p.playerId] = {
                                x: p.x,
                                y: p.y,
                                name: p.name || `Jogador ${p.playerId.substring(0,4)}`,
                                color: p.color || '#cccccc',
                                mapId: p.mapId
                            };
                        }
                    });
                    
                    // Update map layout if provided
                    if (data.mapLayoutData) {
                        if (currentMapId === OPEN_WORLD_ID) {
                            openWorldMap = data.mapLayoutData;
                            mapData = openWorldMap;
                        } else {
                            mapData = data.mapLayoutData;
                        }
                    }
                    
                    // Critical: Update enemies state to force synchronization
                    if (data.enemies) {
                        console.log(`üîÑ [MAP SYNC] Synchronizing ${data.enemies.length} enemies`);
                        
                        if (currentMapId === OPEN_WORLD_ID) {
                            // Update open world enemies
                            data.enemies.forEach(serverEnemy => {
                                const localEnemy = openWorldEnemies.find(e => e.id === serverEnemy.id);
                                if (localEnemy) {
                                    // Update all critical state properties
                                    localEnemy.overworldX = serverEnemy.overworldX;
                                    localEnemy.overworldY = serverEnemy.overworldY;
                                    localEnemy.isAliveOverworld = serverEnemy.isAliveOverworld;
                                    localEnemy.hp = serverEnemy.hp;
                                    localEnemy.inCombat = serverEnemy.inCombat || false;
                                    localEnemy.combatPlayerId = serverEnemy.combatPlayerId || null;
                                } else {
                                    // Add new enemy if not found locally
                                    openWorldEnemies.push({
                                        id: serverEnemy.id,
                                        overworldX: serverEnemy.overworldX,
                                        overworldY: serverEnemy.overworldY,
                                        isAliveOverworld: serverEnemy.isAliveOverworld,
                                        hp: serverEnemy.hp,
                                        aggroRange: serverEnemy.aggroRange,
                                        combatStats: serverEnemy.combatStats,
                                        inCombat: serverEnemy.inCombat || false,
                                        combatPlayerId: serverEnemy.combatPlayerId || null
                                    });
                                }
                            });
                            
                            // Remove local enemies not found on server
                            openWorldEnemies = openWorldEnemies.filter(localEnemy => 
                                data.enemies.some(serverEnemy => serverEnemy.id === localEnemy.id)
                            );
                        } else {
                            // Update regular map enemies
                            const currentMapEnemies = enemies.filter(e => e.mapId === currentMapId);
                            
                            data.enemies.forEach(serverEnemy => {
                                const localEnemy = currentMapEnemies.find(e => e.id === serverEnemy.id);
                                if (localEnemy) {
                                    // Update all critical state properties
                                    localEnemy.overworldX = serverEnemy.overworldX;
                                    localEnemy.overworldY = serverEnemy.overworldY;
                                    localEnemy.isAliveOverworld = serverEnemy.isAliveOverworld;
                                    localEnemy.hp = serverEnemy.hp;
                                    localEnemy.inCombat = serverEnemy.inCombat || false;
                                    localEnemy.combatPlayerId = serverEnemy.combatPlayerId || null;
                                } else {
                                    // Add new enemy if not found locally
                                    enemies.push({
                                        id: serverEnemy.id,
                                        mapId: currentMapId,
                                        overworldX: serverEnemy.overworldX,
                                        overworldY: serverEnemy.overworldY,
                                        isAliveOverworld: serverEnemy.isAliveOverworld,
                                        hp: serverEnemy.hp,
                                        aggroRange: serverEnemy.aggroRange,
                                        combatStats: serverEnemy.combatStats,
                                        inCombat: serverEnemy.inCombat || false,
                                        combatPlayerId: serverEnemy.combatPlayerId || null
                                    });
                                }
                            });
                            
                            // Remove local enemies not found on server (for current map only)
                            enemies = enemies.filter(localEnemy => 
                                localEnemy.mapId !== currentMapId || 
                                data.enemies.some(serverEnemy => serverEnemy.id === localEnemy.id)
                            );
                        }
                        
                        const aliveEnemies = data.enemies.filter(e => e.isAliveOverworld).length;
                        console.log(`üîÑ [MAP SYNC] Enemy sync complete - ${aliveEnemies}/${data.enemies.length} enemies alive`);
                    }
                    
                    console.log(`üîÑ [MAP SYNC] Map sync complete for ${currentMapId} - ${data.players.length} players, ${data.enemies?.length || 0} enemies`);
                }
            });
        }


        function loadMap(mapId, entrySide) {
            const oldMapId = currentMapId;
            currentMapId = mapId;
            otherPlayers = {}; // Multiplayer: Limpa os jogadores do mapa antigo ao mudar de mapa

            if (mapId === OPEN_WORLD_ID) {
                player.overworldX = Math.floor(OPEN_WORLD_SIZE / 2);
                player.overworldY = Math.floor(OPEN_WORLD_SIZE / 2);
                cameraX = player.overworldX; 
                cameraY = player.overworldY;
                cameraWidth = Math.floor(canvas.width / TILE_SIZE);
                cameraHeight = Math.floor(canvas.height / TILE_SIZE);
            } else {
                if (GRID_COLS <= 0 || GRID_ROWS <= 0) { 
                    player.overworldX = 0; player.overworldY = 0;
                } else if (entrySide) {
                    switch(entrySide) {
                        case 'left': player.overworldX = GRID_COLS - 2; break;
                        case 'right': player.overworldX = 1; break;
                        case 'up': player.overworldY = GRID_ROWS - 2; break;
                        case 'down': player.overworldY = 1; break;
                        default: 
                            player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                            player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
                            break;
                    }
                    player.overworldX = Math.max(1, Math.min(player.overworldX, GRID_COLS - 2)); 
                    player.overworldY = Math.max(1, Math.min(player.overworldY, GRID_ROWS - 2));
                } else { 
                    player.overworldX = 1; player.overworldY = 1;
                }
            }
            generateMapFor(currentMapId); 
            updateUIBasedOnState();
            updatePlayerOverworldInfo();

            // Multiplayer: Notifica o servidor sobre a mudan√ßa de mapa
            if (socket && localPlayerId && gameInitialized) {
                if (oldMapId && oldMapId !== currentMapId) { 
                    socket.emit('leaveMap', { playerId: localPlayerId, mapId: oldMapId });
                }
                socket.emit('joinMap', {
                    mapId: currentMapId,
                    playerId: localPlayerId,
                    x: player.overworldX,
                    y: player.overworldY,
                    name: player.name,
                    color: player.color 
                });
                // console.log(`Emitindo joinMap: ${currentMapId}, Player: ${localPlayerId}`);
            }
        }

        function resizeCanvas() {
            if (!gameContainer || gameContainer.clientWidth === 0 || gameContainer.clientHeight === 0) {
                canvas.width = canvas.width || 320; 
                canvas.height = canvas.height || 240;
                if (ctx) { 
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(0,0,255,0.5)'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.fillText("Aguardando dimens√µes...", 10, 20);
                }
                return; 
            }
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            GRID_COLS = Math.floor(canvas.width / TILE_SIZE);
            GRID_ROWS = Math.floor(canvas.height / TILE_SIZE);
            GRID_COLS = Math.max(1, GRID_COLS); 
            GRID_ROWS = Math.max(1, GRID_ROWS);

            if (currentMapId === OPEN_WORLD_ID) {
                cameraWidth = Math.floor(canvas.width / TILE_SIZE);
                cameraHeight = Math.floor(canvas.height / TILE_SIZE);
            } else {
                if (GRID_COLS > 0 && GRID_ROWS > 0) {
                    player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                    player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
                    enemies.forEach(enemy => {
                        if (enemy.mapId === currentMapId) { 
                            enemy.overworldX = Math.max(0, Math.min(enemy.overworldX, GRID_COLS - 1));
                            enemy.overworldY = Math.max(0, Math.min(enemy.overworldY, GRID_ROWS - 1));
                        }
                    });
                } else { 
                    player.overworldX = 0; player.overworldY = 0;
                    enemies.forEach(enemy => { enemy.overworldX = 0; enemy.overworldY = 0; });
                }
            }
            if (gameInitialized) {
                 // Don't re-join the map on resize (that teleports the player!)
                 // Just regenerate the in-memory map and update the UI
                 generateMapFor(currentMapId);
                 updateUIBasedOnState();
            }
        }

        // --- L√≥gica de Estados de Jogo e UI ---
        function updateUIBasedOnState() {
            if (gameState === 'overworld') {
                combatUiPanel.style.display = 'none';
                combatHotbarElement.style.display = 'none'; 
                playerInfoOverworldPanel.style.display = 'block';
                statusInfoDisplay.textContent = `Explorando: ${currentMapId === OPEN_WORLD_ID ? 'Mundo Aberto' : currentMapId}`;
                statusInfoDisplay.className = 'text-slate-400';
                selectedAction = null; 
                highlightedTiles = []; 
            } else if (gameState === 'combat') {
                combatUiPanel.style.display = 'block';
                combatHotbarElement.style.display = 'flex'; 
                playerInfoOverworldPanel.style.display = 'none';
                updateTurnInfo(); 
            }
        }
        
        function createHotbarSlots() {
            combatHotbarElement.innerHTML = ''; 
            for (let i = 1; i <= HOTBAR_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.classList.add('hotbar-slot');
                const slotNumber = document.createElement('span');
                slotNumber.classList.add('slot-number');
                slotNumber.textContent = i;
                slot.appendChild(slotNumber);
                slot.addEventListener('click', () => handleHotbarClick(i));
                combatHotbarElement.appendChild(slot);
            }
        }

        function handleHotbarClick(slotNumber) {
            if (gameState !== 'combat' || currentTurn !== 'player' || !player.isAlive) return;
            logGameMessage(`Slot ${slotNumber} da hotbar clicado (sem a√ß√£o ainda).`, 2000);
        }        function initiateCombat(enemyData) {
            activeCombatEnemy = JSON.parse(JSON.stringify(enemyData)); 
            gameState = 'combat';
            logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name}!`, 3000);
            
            // Notify server that combat started with this enemy
            if (socket && localPlayerId) {
                socket.emit('enemyCombatStarted', {
                    enemyId: enemyData.id,
                    mapId: currentMapId,
                    playerId: localPlayerId
                });
            }
            
            player.gridX = (GRID_COLS > 1) ? 1 : 0; 
            player.gridY = GRID_ROWS > 0 ? Math.floor(GRID_ROWS / 2) : 0; 
            player.gridY = Math.max(0, Math.min(player.gridY, GRID_ROWS > 0 ? GRID_ROWS - 1 : 0));

            player.ap = player.maxAp;
            player.mp = player.maxMp;

            activeCombatEnemy.gridX = (GRID_COLS > 2) ? GRID_COLS - 2 : Math.max(0, GRID_COLS -1); 
            activeCombatEnemy.gridY = GRID_ROWS > 0 ? Math.floor(GRID_ROWS / 2) : 0;
            activeCombatEnemy.gridY = Math.max(0, Math.min(activeCombatEnemy.gridY, GRID_ROWS > 0 ? GRID_ROWS - 1 : 0));

            activeCombatEnemy.hp = activeCombatEnemy.combatStats.maxHp; 
            activeCombatEnemy.ap = activeCombatEnemy.combatStats.ap; 
            activeCombatEnemy.mp = activeCombatEnemy.combatStats.mp;
            activeCombatEnemy.isAliveCombat = true; 
            
            updateUIBasedOnState();
            startPlayerTurn();
        }        function endCombat(victory) {
            // Store enemy data before any code that might set activeCombatEnemy to null
            const combatEnemyData = activeCombatEnemy ? {
                id: activeCombatEnemy.id,
                combatStats: activeCombatEnemy.combatStats
            } : null;
            
            // Notify server that combat ended with this enemy
            if (socket && localPlayerId && combatEnemyData) {
                socket.emit('enemyCombatEnded', {
                    enemyId: combatEnemyData.id,
                    mapId: currentMapId,
                    victory: victory
                });
            }            if (victory && combatEnemyData) {
                const loot = combatEnemyData.combatStats.loot || {gold: 0};
                console.log(`[DEBUG] Enemy defeated:`, combatEnemyData.combatStats.name);
                console.log(`[DEBUG] Enemy loot data:`, loot);
                console.log(`[DEBUG] Player gold before:`, player.gold);
                logGameMessage(`Voc√™ derrotou ${combatEnemyData.combatStats.name}! Recebeu ${loot.gold}g.`, 3000);
                player.gold += loot.gold;
                console.log(`[DEBUG] Player gold after:`, player.gold);
                  // Trigger auto-save for combat victory - ONLY SAVE TRIGGER
                const damageDealt = player.attackPower || 10; // Calculate actual damage dealt
                triggerCombatVictorySave(combatEnemyData, damageDealt);

                // Marca o inimigo como morto no overworld (se for um inimigo da lista 'enemies')
                const originalEnemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                const originalEnemy = originalEnemyList.find(e => e.id === combatEnemyData.id);
                if(originalEnemy) originalEnemy.isAliveOverworld = false; 
                
                player.hp = player.maxHp; 
                  // Check for experience gain and level up
                const experienceGained = combatEnemyData.combatStats.experience || 10;
                const oldLevel = player.level;
                player.experience += experienceGained;
                
                if (player.experience >= player.experienceToNext) {
                    const newLevel = player.level + 1;
                    player.level = newLevel;
                    player.experience = 0;
                    player.experienceToNext = Math.floor(player.experienceToNext * 1.5);
                    player.skillPoints += 2;
                      logGameMessage(`üéâ Level Up! You are now level ${newLevel}!`, 4000);
                    // Removed triggerLevelUpSave - ONLY save after combat
                }
                  // No more item acquisition saves - ONLY save after combat
                // if (loot.gold > 0) {
                //     triggerItemAcquisitionSave('gold', 'currency', loot.gold);
                // }
                
 
            }
            activeCombatEnemy = null;
            gameState = 'overworld';
            updateUIBasedOnState();
            updatePlayerOverworldInfo();
        }


        // --- L√≥gica de Turnos (Combate) ---
        function startPlayerTurn() {
            currentTurn = 'player';
            selectedAction = null;
            highlightedTiles = [];
            updatePlayerCombatInfo();
            updateTurnInfo();
            enableActionButtons(true);
        }

        function endPlayerTurn() {
            if (currentTurn !== 'player' || gameState !== 'combat' || !player.isAlive) return; 
            selectedAction = null;
            highlightedTiles = [];
            enableActionButtons(false);
            setTimeout(startEnemyTurn, 500); 
        }

        function startEnemyTurn() {
            if (gameState !== 'combat' || !activeCombatEnemy || activeCombatEnemy.hp <= 0 || !player.isAlive) {
                if (player.isAlive && activeCombatEnemy && activeCombatEnemy.hp <= 0) {
                    endCombat(true); 
                } else if (!player.isAlive) {
                    endCombat(false); 
                } else {
                    if (activeCombatEnemy && activeCombatEnemy.hp <=0) endCombat(true); 
                    else gameState = 'overworld'; 
                }
                return;
            }

            currentTurn = 'enemy';
            updateTurnInfo();
            
            const enemy = activeCombatEnemy;
            enemy.ap = enemy.combatStats.maxAp; 
            enemy.mp = enemy.combatStats.maxMp; 

            let actionTakenThisTurn = false; 
            const distToPlayer = getGridDistance(enemy.gridX, enemy.gridY, player.gridX, player.gridY);

            if (distToPlayer <= enemy.combatStats.attackRange && enemy.ap > 0) {
                player.hp -= enemy.combatStats.attackPower;
                enemy.ap--; 
                actionTakenThisTurn = true;
                if (player.hp <= 0) { player.hp = 0; player.isAlive = false; }
                logGameMessage(`${enemy.combatStats.name} ataca ${player.name} causando ${enemy.combatStats.attackPower} de dano! HP Jogador: ${player.hp}`, 2500);
                updatePlayerOverworldInfo(); 
                if (!player.isAlive) {
                    logGameMessage(`${player.name} foi derrotado!`, 4000);
                    setTimeout(() => endCombat(false), 1500);
                    return; 
                }
            }
            if (!actionTakenThisTurn && enemy.mp > 0 && distToPlayer > 0) { 
                let bestMove = {x: enemy.gridX, y: enemy.gridY};
                let currentMinDistanceToPlayer = distToPlayer;
                let foundValidMove = false;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue; 
                        const newX = enemy.gridX + dx;
                        const newY = enemy.gridY + dy;
                        if (isValidCombatTile(newX, newY) && !isCombatTileOccupied(newX,newY, enemy)) {
                            const distanceToPlayerFromNewPos = getGridDistance(newX, newY, player.gridX, player.gridY);
                            if (distanceToPlayerFromNewPos < currentMinDistanceToPlayer) {
                                currentMinDistanceToPlayer = distanceToPlayerFromNewPos;
                                bestMove = {x: newX, y: newY};
                                foundValidMove = true;
                            }
                        }
                    }
                }
                if(foundValidMove){ 
                    enemy.gridX = bestMove.x;
                    enemy.gridY = bestMove.y;
                    enemy.mp--;
                    actionTakenThisTurn = true; 
                    logGameMessage(`${enemy.combatStats.name} moveu-se.`, 1500);
                }
            } 
            player.ap = player.maxAp; 
            player.mp = player.maxMp;
            setTimeout(startPlayerTurn, 1000); 
        }
        
        function isCombatTileOccupied(gridX, gridY, selfEntity = null) {
            if (player.isAlive && player.gridX === gridX && player.gridY === gridY && player !== selfEntity) return true;
            if (activeCombatEnemy && activeCombatEnemy.hp > 0 && activeCombatEnemy.gridX === gridX && activeCombatEnemy.gridY === gridY && activeCombatEnemy !== selfEntity) return true;
            return false;
        }

        // --- A√ß√µes e Input ---
        function handleGlobalKeyDown(e) {
            if (document.activeElement === chatInput) return; 
            if (gameState === 'overworld' && player.isAlive) handleOverworldKeyDown(e);
            else if (gameState === 'combat' && player.isAlive && currentTurn === 'player') handleCombatKeyDown(e);
        }        function handleOverworldKeyDown(e) {
            if (!e || !e.key) return; // Add safety check for undefined key
            let dx = 0, dy = 0;
            switch (e.key.toLowerCase()) {
                case 'arrowup': case 'w': dy = -1; break;
                case 'arrowdown': case 's': dy = 1; break;
                case 'arrowleft': case 'a': dx = -1; break;
                case 'arrowright': case 'd': dx = 1; break;
                default: return; 
            }
            e.preventDefault(); 

            const prevPlayerX = player.overworldX;
            const prevPlayerY = player.overworldY;

            if (currentMapId === OPEN_WORLD_ID) {
                const newX = player.overworldX + dx;
                const newY = player.overworldY + dy;
                if (!isValidOpenWorldTile(newX, newY)) return;
                for (const enemy of openWorldEnemies) {
                    if (enemy.isAliveOverworld && enemy.overworldX === newX && enemy.overworldY === newY) {
                        initiateOpenWorldCombat(enemy);
                        return;
                    }
                }
                // Multiplayer: Verificar colis√£o com outros jogadores no mundo aberto
                for (const pId in otherPlayers) {
                    if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === newX && otherPlayers[pId].y === newY) {
                        return; // Bloqueia movimento se outro jogador estiver l√°
                    }
                }
                if (openWorldMap && openWorldMap[newY] && openWorldMap[newY][newX] !== MAP_TILES.OBSTACLE_ROCK) {
                    player.overworldX = newX;
                    player.overworldY = newY;
                    cameraX = player.overworldX;
                    cameraY = player.overworldY;
                }
            } else { // Mapas normais
                const newOverworldX = player.overworldX + dx;
                const newOverworldY = player.overworldY + dy;
                const connections = mapConnections[currentMapId] || {};
                if (newOverworldX >= GRID_COLS && connections.right) { loadMap(connections.right, 'right'); return; }
                if (newOverworldX < 0 && connections.left) { loadMap(connections.left, 'left'); return; }
                if (newOverworldY >= GRID_ROWS && connections.down) { loadMap(connections.down, 'down'); return; }
                if (newOverworldY < 0 && connections.up) { loadMap(connections.up, 'up'); return; }
                if (!isValidOverworldTile(newOverworldX, newOverworldY)) return; 
                for (const enemy of enemies) {
                    if (enemy.isAliveOverworld && enemy.mapId === currentMapId && enemy.overworldX === newOverworldX && enemy.overworldY === newOverworldY) {
                        initiateCombat(enemy);
                        return; 
                    }
                }
                // Multiplayer: Verificar colis√£o com outros jogadores em mapas normais
                for (const pId in otherPlayers) {
                    if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === newOverworldX && otherPlayers[pId].y === newOverworldY) {
                        return; // Bloqueia movimento
                    }
                }
                if (mapData && mapData.length > newOverworldY && mapData[newOverworldY] && mapData[newOverworldY].length > newOverworldX && mapData[newOverworldY][newOverworldX] !== MAP_TILES.OBSTACLE_ROCK) {
                    player.overworldX = newOverworldX;
                    player.overworldY = newOverworldY;
                }
            }
            // Multiplayer: Emitir movimento se a posi√ß√£o mudou
            if ((player.overworldX !== prevPlayerX || player.overworldY !== prevPlayerY) && socket && localPlayerId) {
                socket.emit('playerMoved', {
                    playerId: localPlayerId,
                    mapId: currentMapId,
                    x: player.overworldX,
                    y: player.overworldY
                });
            }
        }
        // --- Open World Camera/Tile helpers ---
        function isValidOpenWorldTile(x, y) {
            return x >= 0 && x < OPEN_WORLD_SIZE && y >= 0 && y < OPEN_WORLD_SIZE;
        }        function initiateOpenWorldCombat(enemyData) {
            activeCombatEnemy = JSON.parse(JSON.stringify(enemyData));
            gameState = 'combat';
            logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name}!`, 3000);
            
            // Notify server that combat started with this enemy
            if (socket && localPlayerId) {
                socket.emit('enemyCombatStarted', {
                    enemyId: enemyData.id,
                    mapId: currentMapId,
                    playerId: localPlayerId
                });
            }
            
            player.gridX = 1;
            player.gridY = Math.floor(GRID_ROWS / 2);
            player.ap = player.maxAp;
            player.mp = player.maxMp;
            activeCombatEnemy.gridX = GRID_COLS - 2;
            activeCombatEnemy.gridY = Math.floor(GRID_ROWS / 2);
            activeCombatEnemy.hp = activeCombatEnemy.combatStats.maxHp;
            activeCombatEnemy.ap = activeCombatEnemy.combatStats.ap; 
            activeCombatEnemy.mp = activeCombatEnemy.combatStats.mp;
            activeCombatEnemy.isAliveCombat = true;
            updateUIBasedOnState();
            startPlayerTurn();
        }

        function handleCombatKeyDown(e) {
            switch (e.key.toLowerCase()) {
                case '1': e.preventDefault(); setSelectedAction('move'); break;
                case '2': e.preventDefault(); setSelectedAction('attack'); break;
                case ' ': e.preventDefault(); endPlayerTurn(); break;
                case 'w': case 'arrowup':
                case 's': case 'arrowdown':
                case 'a': case 'arrowleft':
                case 'd': case 'arrowright':
                    if (selectedAction === 'move') {
                        e.preventDefault();
                        let dx = 0, dy = 0;
                        if (e.key === 'w' || e.key === 'arrowup') dy = -1;
                        if (e.key === 's' || e.key === 'arrowdown') dy = 1;
                        if (e.key === 'a' || e.key === 'arrowleft') dx = -1;
                        if (e.key === 'd' || e.key === 'arrowright') dx = 1;
                        handleMoveActionCombat(player.gridX + dx, player.gridY + dy);
                    }
                    break;
            }
        }

        function setSelectedAction(action) {
            if (currentTurn !== 'player' || !player.isAlive || gameState !== 'combat') return;
            if (selectedAction === action) selectedAction = null; 
            else selectedAction = action;
            updateHighlightedTiles();
            moveButton.classList.toggle('selected-action', selectedAction === 'move');
            attackButton.classList.toggle('selected-action', selectedAction === 'attack');
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const gridX = Math.floor((event.clientX - rect.left) / TILE_SIZE);
            const gridY = Math.floor((event.clientY - rect.top) / TILE_SIZE);

            if (gameState === 'overworld') {
                if (!isValidOverworldTile(gridX, gridY)) return; 
                const targetEnemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                for (const enemy of targetEnemyList) {
                    if (enemy.isAliveOverworld && 
                        ((currentMapId !== OPEN_WORLD_ID && enemy.mapId === currentMapId) || currentMapId === OPEN_WORLD_ID) &&
                        enemy.overworldX === gridX && enemy.overworldY === gridY) {
                        if (currentMapId === OPEN_WORLD_ID) initiateOpenWorldCombat(enemy);
                        else initiateCombat(enemy); 
                        return;
                    }
                }
            } else if (gameState === 'combat') {
                if (currentTurn !== 'player' || !player.isAlive || !selectedAction) return;
                if (!isValidCombatTile(gridX, gridY)) return;
                if (selectedAction === 'move') handleMoveActionCombat(gridX, gridY);
                else if (selectedAction === 'attack') handleAttackActionCombat(gridX, gridY);
            } else if (gameState === 'overworld' && player.isAlive) {
                // Multiplayer: Check if a player was clicked
                for (const playerId in otherPlayers) {
                    const otherPlayer = otherPlayers[playerId];
                    if (
                        otherPlayer.mapId === currentMapId &&
                        otherPlayer.x === gridX &&
                        otherPlayer.y === gridY
                    ) {
                        console.log(`Clicked on player: ${otherPlayer.name} (ID: ${playerId})`);
                        // Emit initiateCombat event to the server
                        socket.emit('initiateCombat', {
                            attackerId: localPlayerId,
                            defenderId: playerId,
                            mapId: currentMapId
                        });
                        logGameMessage(`Voc√™ desafiou ${otherPlayer.name} para um combate!`, 3000);
                        return;
                    }
                }
            }
        }

        function handleMoveActionCombat(targetGridX, targetGridY) {
            const distance = getGridDistance(player.gridX, player.gridY, targetGridX, targetGridY);
            if (player.mp >= distance && distance > 0 && !isCombatTileOccupied(targetGridX, targetGridY)) {
                player.gridX = targetGridX;
                player.gridY = targetGridY;
                player.mp -= distance; 
                if (player.mp <= 0) selectedAction = null; 
                updatePlayerCombatInfo();
                updateHighlightedTiles();
            }
        }

        function handleAttackActionCombat(targetGridX, targetGridY) {
            if (activeCombatEnemy && activeCombatEnemy.hp > 0 && activeCombatEnemy.gridX === targetGridX && activeCombatEnemy.gridY === targetGridY) {
                const distance = getGridDistance(player.gridX, player.gridY, targetGridX, targetGridY);
                if (distance <= player.attackRange && player.ap > 0) { 
                    activeCombatEnemy.hp -= player.attackPower;
                    player.ap--;
                    logGameMessage(`Atacou ${activeCombatEnemy.combatStats.name}! Dano: ${player.attackPower}.`, 2000);
                    if (activeCombatEnemy.hp <= 0) {
                        activeCombatEnemy.hp = 0;
                        setTimeout(() => endCombat(true), 1000); 
                    }
                    if (player.ap <= 0) selectedAction = null; 
                    updatePlayerCombatInfo();
                    updateHighlightedTiles();
                } else {
                    logGameMessage("Fora de alcance ou sem AP!", 1500);
                }
            }
        }
        
        function updateHighlightedTiles() { 
            highlightedTiles = [];
            if (!selectedAction || gameState !== 'combat' || !player.isAlive) return; 
            const range = (selectedAction === 'move') ? player.mp : player.attackRange;
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const dist = getGridDistance(player.gridX, player.gridY, c, r);
                    if (dist > 0 && dist <= range) {
                        if (selectedAction === 'move' && !isCombatTileOccupied(c,r)) highlightedTiles.push({ x: c, y: r, type: 'move' });
                        else if (selectedAction === 'attack') highlightedTiles.push({ x: c, y: r, type: 'attack' });
                    }
                }
            }
        }
        
        function updateOverworldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld' || !player.isAlive) return;
            lastAiUpdateTime = now;

            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);

                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) { 
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        
                        let movedThisTick = false;

                        if (dx !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX + dx;
                            let nextY = enemy.overworldY; 

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true; 
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEnemy = false;
                                for ( const otherEnemy of enemies) {
                                    if (otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                for (const pId in otherPlayers) {
                                     if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEnemy) {
                                    enemy.overworldX = nextX;
                                    movedThisTick = true;
                                }
                            }
                        }

                        if (dy !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX; 
                            let nextY = enemy.overworldY + dy;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEnemy = false;
                                for (const otherEnemy of enemies) {
                                    if ( otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                for (const pId in otherPlayers) {
                                     if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEnemy) {
                                    enemy.overworldY = nextY;
                                    movedThisTick = true;
                                }
                            }
                        }
                    }
                }
            });        }

        // --- Desenho ---
        function gameLoop() {
            if (!ctx) {
                return; 
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (gameState === 'overworld') {
                if (currentMapId === OPEN_WORLD_ID) {
                    // Server handles monster AI now - removed updateOpenWorldAI()
                    drawOpenWorld();
                } else {
                    // Server handles monster AI now - removed updateOverworldAI()
                    drawOverworld();
                }
            } else if (gameState === 'combat') {
                drawCombat();
            }
            requestAnimationFrame(gameLoop);
        }

        // Client-side AI functions removed - now handled server-side
        /*
        function updateOpenWorldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld' || !player.isAlive) return;
            lastAiUpdateTime = now;

            openWorldEnemies.forEach(enemy => {
                if (enemy.isAliveOverworld) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);

                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) {
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        let movedThisTick = false;

                        if (dx !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX + dx;
                            let nextY = enemy.overworldY;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateOpenWorldCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOpenWorldTile(nextX, nextY) && openWorldMap[nextY] && openWorldMap[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOther = false;
                                for (const otherE of openWorldEnemies) { if (otherE !== enemy && otherE.isAliveOverworld && otherE.overworldX === nextX && otherE.overworldY === nextY) { isOccupiedByOther = true; break; } }
                                if (!isOccupiedByOther) {
                                     for (const pId in otherPlayers) { if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) { isOccupiedByOther = true; break;}}
                                }
                                if (!isOccupiedByOther) {
                                    enemy.overworldX = nextX;
                                    movedThisTick = true;
                                }
                            }
                        }

                        if (dy !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX; 
                            let nextY = enemy.overworldY + dy;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateOpenWorldCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOpenWorldTile(nextX, nextY) && openWorldMap[nextY] && openWorldMap[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOther = false;
                                for (const otherE of openWorldEnemies) { if (otherE !== enemy && otherE.isAliveOverworld && otherE.overworldX === nextX && otherE.overworldY === nextY) { isOccupiedByOther = true; break; } }
                                if (!isOccupiedByOther) {
                                     for (const pId in otherPlayers) { if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) { isOccupiedByOther = true; break;}}
                                }
                                if (!isOccupiedByOther) {
                                    enemy.overworldY = nextY;
                                    movedThisTick = true;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateOverworldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld' || !player.isAlive) return;
            lastAiUpdateTime = now;

            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);

                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) { 
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        
                        let movedThisTick = false;

                        if (dx !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX + dx;
                            let nextY = enemy.overworldY; 

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true; 
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEnemy = false;
                                for ( const otherEnemy of enemies) {
                                    if (otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                for (const pId in otherPlayers) {
                                     if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEnemy) {
                                    enemy.overworldX = nextX;
                                    movedThisTick = true;
                                }
                            }
                        }

                        if (dy !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX; 
                            let nextY = enemy.overworldY + dy;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEnemy = false;
                                for (const otherEnemy of enemies) {
                                    if (otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                for (const pId in otherPlayers) {
                                     if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEnemy) {
                                    enemy.overworldY = nextY;
                                    movedThisTick = true;
                                }
                            }
                        }
                    }
                }
            });        }
        */

        function drawOpenWorld() {
            let halfW = Math.floor(cameraWidth / 2);
            let halfH = Math.floor(cameraHeight / 2);
            let camLeft = Math.max(0, Math.min(player.overworldX - halfW, OPEN_WORLD_SIZE - cameraWidth));
            let camTop = Math.max(0, Math.min(player.overworldY - halfH, OPEN_WORLD_SIZE - cameraHeight));

            for (let r = 0; r < cameraHeight; r++) {
                for (let c = 0; c < cameraWidth; c++) {
                    let mapY = camTop + r;
                    let mapX = camLeft + c;
                    if (!isValidOpenWorldTile(mapX, mapY) || !openWorldMap || !openWorldMap[mapY]) continue; // Check if openWorldMap and row exist

                    const tileType = openWorldMap[mapY][mapX];
                    const x = c * TILE_SIZE, y = r * TILE_SIZE;
                    switch (tileType) {
                        case MAP_TILES.OBSTACLE_ROCK: ctx.fillStyle = '#848b98'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case MAP_TILES.DECORATION_TREE:
                            ctx.fillStyle = '#225336'; ctx.fillRect(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.5, TILE_SIZE * 0.6, TILE_SIZE * 0.5); 
                            ctx.fillStyle = '#38a169'; ctx.beginPath(); ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE * 0.35, TILE_SIZE * 0.35, 0, Math.PI * 2); ctx.fill(); 
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            ctx.fillStyle = '#48bb78'; ctx.beginPath();
                            ctx.arc(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.7, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5, TILE_SIZE * 0.25, 0, Math.PI * 2); ctx.fill();
                            break;
                    }
                }
            }            openWorldEnemies.forEach(enemy => {
                if (enemy.isAliveOverworld) {
                    // Hide enemy if it's in combat with another player
                    if (enemy.inCombat && enemy.combatPlayerId && enemy.combatPlayerId !== localPlayerId) {
                        return; // Skip drawing this enemy
                    }
                    
                    let relX = enemy.overworldX - camLeft;
                    let relY = enemy.overworldY - camTop;
                    if (relX >= 0 && relX < cameraWidth && relY >= 0 && relY < cameraHeight) {
                        drawOverworldEntity(relX, relY, enemy.combatStats.color, enemy.combatStats.size, enemy.combatStats.name, true);
                    }
                }
            });
            // Multiplayer: Desenhar outros jogadores no mundo aberto
            for (const playerId in otherPlayers) {
                const p = otherPlayers[playerId];
                if (p.mapId === OPEN_WORLD_ID) {
                    let relX = p.x - camLeft;
                    let relY = p.y - camTop;
                    if (relX >= 0 && relX < cameraWidth && relY >= 0 && relY < cameraHeight) {
                        drawOverworldEntity(relX, relY, p.color, TILE_SIZE * 0.8, p.name);
                    }
                }
            }
            let relPX = player.overworldX - camLeft;
            let relPY = player.overworldY - camTop;
            if (relPX >= 0 && relPX < cameraWidth && relPY >= 0 && relPY < cameraHeight) {
                drawOverworldEntity(relPX, relPY, player.color, player.size, player.name);
            }
        }

        function drawOverworldEntity(gridX, gridY, color, size, name = null, isEnemy = false) {
            const pixelX = gridX * TILE_SIZE + (TILE_SIZE - size) / 2;
            const pixelY = gridY * TILE_SIZE + (TILE_SIZE - size) / 2;
            ctx.fillStyle = color;
            ctx.fillRect(pixelX, pixelY, size, size);

            if (name) {
                ctx.fillStyle = isEnemy ? '#fca5a5' : '#93c5fd'; // Cor diferente para nome de inimigo e jogador
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(name, pixelX + size / 2, pixelY - 5);
            }
        }

        function drawOverworld() {
            drawGrid(); 
            drawMapElements();            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    // Hide enemy if it's in combat with another player
                    if (enemy.inCombat && enemy.combatPlayerId && enemy.combatPlayerId !== localPlayerId) {
                        return; // Skip drawing this enemy
                    }
                    
                    drawOverworldEntity(enemy.overworldX, enemy.overworldY, enemy.combatStats.color, enemy.combatStats.size, enemy.combatStats.name, true); 
                }
            });
            // Multiplayer: Desenhar outros jogadores em mapas normais
            for (const playerId in otherPlayers) {
                const p = otherPlayers[playerId];
                if (p.mapId === currentMapId && p.playerId !== localPlayerId) { // Garante que n√£o desenhe o jogador local como "outro"
                    drawOverworldEntity(p.x, p.y, p.color, TILE_SIZE * 0.8, p.name);
                }
            }
            if (player.isAlive) drawOverworldEntity(player.overworldX, player.overworldY, player.color, player.size, player.name);
        }
        
        function drawMapElements() {
            if (!mapData || mapData.length === 0 || GRID_ROWS === 0 || GRID_COLS === 0) {
                return;
            }
            for (let r = 0; r < GRID_ROWS; r++) {
                if (!mapData[r]) continue; 
                for (let c = 0; c < GRID_COLS; c++) {
                    const tileType = mapData[r][c];
                    const x = c * TILE_SIZE, y = r * TILE_SIZE;
                    switch ( tileType) {
                        case MAP_TILES.OBSTACLE_ROCK: ctx.fillStyle = '#848b98'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case MAP_TILES.DECORATION_TREE:
                            ctx.fillStyle = '#225336'; ctx.fillRect(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.5, TILE_SIZE * 0.6, TILE_SIZE * 0.5); 
                            ctx.fillStyle = '#38a169'; ctx.beginPath(); ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE * 0.35, TILE_SIZE * 0.35, 0, Math.PI * 2); ctx.fill(); 
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            ctx.fillStyle = '#48bb78'; ctx.beginPath();
                            ctx.arc(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.7, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5, TILE_SIZE * 0.25, 0, Math.PI * 2); ctx.fill();
                            break;
                    }
                }
            }
        }

        // drawOverworldEntity j√° foi definida e modificada para incluir nome e flag 'isEnemy'

        function drawCombat() {
            drawGrid();
            drawHighlightedTiles();
            if (activeCombatEnemy && activeCombatEnemy.hp > 0) drawCombatCharacter(activeCombatEnemy, true);
            if (player.isAlive) drawCombatCharacter(player, false);
        }

        function drawGrid() { 
            if (GRID_COLS <=0 || GRID_ROWS <=0) return; 
            ctx.strokeStyle = '#4a5568'; ctx.lineWidth = 0.5; 
            for (let c = 0; c < GRID_COLS; c++) for (let r = 0; r < GRID_ROWS; r++) ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
        
        function drawHighlightedTiles() { highlightedTiles.forEach(tile => { ctx.fillStyle = tile.type === 'move' ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 0, 0, 0.2)'; ctx.fillRect(tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE); }); }

        function drawCombatCharacter(charData, isEnemy) {
            const entity = isEnemy ? charData : player;
            const combatStats = isEnemy ? entity.combatStats : player; 
            const displayColor = isEnemy ? (entity.colorFlash || combatStats.color) : player.color;
            const displaySize = combatStats.size;

            const pixelX = entity.gridX * TILE_SIZE + (TILE_SIZE - displaySize) / 2;
            const pixelY = entity.gridY * TILE_SIZE + (TILE_SIZE - displaySize) / 2;
            ctx.fillStyle = displayColor;
            ctx.fillRect(pixelX, pixelY, displaySize, displaySize);
            const hp = entity.hp, maxHp = combatStats.maxHp;
            const hpBarWidth = displaySize, hpBarHeight = 6, hpBarX = pixelX, hpBarY = pixelY - hpBarHeight - 3, hpRatio = maxHp > 0 ? hp / maxHp : 0;
            ctx.fillStyle = '#4b5563'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
            ctx.fillStyle = isEnemy ? 'red' : 'limegreen'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpRatio, hpBarHeight);
            // Multiplayer: Desenhar nome do personagem em combate
            if (combatStats.name) {
                ctx.fillStyle = isEnemy ? '#fca5a5' : '#93c5fd';
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(combatStats.name, pixelX + displaySize / 2, hpBarY - 3);
            }
        }

        // --- Utilit√°rios ---
        function isValidOverworldTile(gridX, gridY) { return gridX >= 0 && gridX < GRID_COLS && gridY >= 0 && gridY < GRID_ROWS; }
        function isValidCombatTile(gridX, gridY) { return gridX >= 0 && gridX < GRID_COLS && gridY >= 0 && gridY < GRID_ROWS; }
        function getGridDistance(x1, y1, x2, y2) { return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2)); } 
        function logGameMessage(message, duration = 3000) { gameLogMessage.textContent = message; gameLogMessage.classList.remove('hidden'); if (gameLogMessage.timeoutId) clearTimeout(gameLogMessage.timeoutId); gameLogMessage.timeoutId = setTimeout(() => gameLogMessage.classList.add('hidden'), duration); }
        function updatePlayerOverworldInfo() { playerNameOverworldDisplay.textContent = player.name; playerHPOverworldDisplay.textContent = `${player.hp}/${player.maxHp}`; playerGoldOverworldDisplay.textContent = player.gold; }
        function updatePlayerCombatInfo() { playerAPCombatDisplay.textContent = `${player.ap}/${player.maxAp}`; playerMPCombatDisplay.textContent = `${player.mp}/${player.maxMp}`; }
        function updateTurnInfo() { if (gameState === 'combat') { statusInfoDisplay.textContent = currentTurn === 'player' ? "Seu Turno!" : `Turno de ${activeCombatEnemy ? activeCombatEnemy.combatStats.name : 'Inimigo'}...`; statusInfoDisplay.className = currentTurn === 'player' ? 'text-green-400 font-semibold' : 'text-red-400 font-semibold'; } }
        function enableActionButtons(enabled) { moveButton.disabled = !enabled; attackButton.disabled = !enabled; endTurnButton.disabled = !enabled; if (!enabled) { moveButton.classList.remove('selected-action'); attackButton.classList.remove('selected-action');} }
        
        function handleChatInput(event) { 
            if (event.key === 'Enter' && chatInput.value.trim() !== '') { 
                const message = chatInput.value.trim();
                console.log(`[DEBUG] Sending chat message: ${message}`);
                addChatMessage(player.name, message); // Mostra a mensagem localmente imediatamente

                // Multiplayer: Envia mensagem para o servidor
                if (socket && localPlayerId) {
                    socket.emit('chatMessage', {
                        senderId: localPlayerId,
                        senderName: player.name,
                        message: message,
                        mapId: currentMapId // Envia o mapId para que o servidor possa rotear para a sala correta
                    });
                    console.log(`[DEBUG] Emitted chatMessage event to server: ${message}`);
                } else {
                    console.log(`[DEBUG] Socket or localPlayerId is not defined`);
                }
                chatInput.value = ''; 
                event.stopPropagation(); 
            } 
        }
        function addChatMessage(sender, message) { const p = document.createElement('p'); const esc = (str) => { const d=document.createElement('div'); d.appendChild(document.createTextNode(str)); return d.innerHTML; }; p.innerHTML = `<span class="font-semibold ${sender === player.name ? 'text-green-300' : 'text-sky-300'}">[${esc(sender)}]:</span> ${esc(message)}`; chatMessages.appendChild(p); chatMessages.scrollTop = chatMessages.scrollHeight; }

        // --- Patch: Remove defeated open world monsters ---
        const _oldEndCombat = endCombat;
        endCombat = function(victory) {
            if (currentMapId === OPEN_WORLD_ID && activeCombatEnemy && victory) {
                const idx = openWorldEnemies.findIndex(e => e.id === activeCombatEnemy.id);
                if (idx !== -1) openWorldEnemies[idx].isAliveOverworld = false;
            }
            _oldEndCombat.apply(this, arguments);
        }

        // --- Enhanced Player Data Management System ---
        let playerStatistics = null;
        let lastSaveTime = 0;
        let saveNotificationTimeout = null;

        // Player Data Management Functions
        async function loadPlayerData() {
            try {
                const session = getSession();
                if (!session.username) return;

                console.log('[LOAD DEBUG] Loading player data for:', session.username);
                const response = await fetch(`/api/load-progress/${session.username}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('[LOAD DEBUG] Data received from server:', data);
                    
                    // Load player progress
                    if (data.progress) {
                        console.log('[LOAD DEBUG] Progress data found:', data.progress);
                        console.log('[LOAD DEBUG] Gold in progress data:', data.progress.gold);
                        applyPlayerProgress(data.progress);
                    } else {
                        console.log('[LOAD DEBUG] No progress data found');
                    }
                    
                    // Load player statistics
                    if (data.statistics) {
                        playerStatistics = data.statistics;
                        updateStatsDisplay();
                    }
                    
                    console.log('‚úÖ Player data loaded successfully');
                    console.log('[LOAD DEBUG] Final player gold after loading:', player.gold);
                    showSaveNotification('Game data loaded!');
                } else {
                    console.warn('‚ö†Ô∏è Failed to load player data, starting with defaults');
                }
            } catch (error) {
                console.error('‚ùå Error loading player data:', error);
            }
        }function applyPlayerProgress(progress) {
            console.log('[LOAD DEBUG] Applying player progress:', progress);
            console.log('[LOAD DEBUG] Progress gold value:', progress.gold);
            console.log('[LOAD DEBUG] Player gold before loading:', player.gold);
            
            // Apply loaded progress to player object
            if (progress.hp !== undefined) player.hp = progress.hp;
            if (progress.maxHp !== undefined) player.maxHp = progress.maxHp;
            if (progress.ap !== undefined) player.ap = progress.ap;
            if (progress.maxAp !== undefined) player.maxAp = progress.maxAp;
            if (progress.mp !== undefined) player.mp = progress.mp;
            if (progress.maxMp !== undefined) player.maxMp = progress.maxMp;
            if (progress.attackPower !== undefined) player.attackPower = progress.attackPower;
            if (progress.attackRange !== undefined) player.attackRange = progress.attackRange;
            if (progress.gold !== undefined) {
                player.gold = progress.gold;
                console.log('[LOAD DEBUG] Gold loaded successfully:', player.gold);
            } else {
                console.log('[LOAD DEBUG] No gold data in progress, keeping current:', player.gold);
            }
            if (progress.overworldX !== undefined) player.overworldX = progress.overworldX;
            if (progress.overworldY !== undefined) player.overworldY = progress.overworldY;
            if (progress.mapId !== undefined) currentMapId = progress.mapId;
            if (progress.level !== undefined) player.level = progress.level;
            if (progress.experience !== undefined) player.experience = progress.experience;
            if (progress.experienceToNext !== undefined) player.experienceToNext = progress.experienceToNext;
            if (progress.skillPoints !== undefined) player.skillPoints = progress.skillPoints;
            
            // Apply skills
            if (progress.strength !== undefined) player.strength = progress.strength;
            if (progress.vitality !== undefined) player.vitality = progress.vitality;
            if (progress.agility !== undefined) player.agility = progress.agility;
            if (progress.intelligence !== undefined) player.intelligence = progress.intelligence;
            if (progress.luck !== undefined) player.luck = progress.luck;
            
            // Apply equipment
            if (progress.weapon !== undefined) player.weapon = progress.weapon;
            if (progress.armor !== undefined) player.armor = progress.armor;
            if (progress.helmet !== undefined) player.helmet = progress.helmet;
            if (progress.boots !== undefined) player.boots = progress.boots;
            if (progress.ring !== undefined) player.ring = progress.ring;
            if (progress.amulet !== undefined) player.amulet = progress.amulet;
            
            // Apply other data
            if (progress.skins) player.skins = progress.skins;
            if (progress.currentSkin !== undefined) player.currentSkin = progress.currentSkin;
            if (progress.inventory) player.inventory = progress.inventory;
            if (progress.spells) player.spells = progress.spells;
            
            updatePlayerOverworldInfo();
        }

        async function savePlayerData(triggerType = 'manual', additionalData = {}) {
            try {
                const session = getSession();
                if (!session.username) return false;

                const currentTime = Date.now();
                
                // Prevent too frequent saves (unless critical triggers)
                const criticalTriggers = ['levelUp', 'combatVictory', 'disconnect'];
                if (!criticalTriggers.includes(triggerType) && currentTime - lastSaveTime < 5000) {
                    return false;
                }

                const progressData = {
                    hp: player.hp,
                    maxHp: player.maxHp,
                    ap: player.ap,
                    maxAp: player.maxAp,
                    mp: player.mp,
                    maxMp: player.maxMp,
                    attackPower: player.attackPower,
                    attackRange: player.attackRange,
                    gold: player.gold,
                    overworldX: player.overworldX,
                    overworldY: player.overworldY,
                    mapId: currentMapId,
                    level: player.level,
                    experience: player.experience,
                    experienceToNext: player.experienceToNext,
                    skillPoints: player.skillPoints,
                    strength: player.strength,
                    vitality: player.vitality,
                    agility: player.agility,
                    intelligence: player.intelligence,
                    luck: player.luck,
                    weapon: player.weapon,
                    armor: player.armor,
                    helmet: player.helmet,
                    boots: player.boots,
                    ring: player.ring,
                    amulet: player.amulet,
                    skins: player.skins,
                    currentSkin: player.currentSkin,
                    inventory: player.inventory,
                    spells: player.spells,
                    ...additionalData
                };

                const response = await fetch('/api/save-progress', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        login: session.username,
                        progress: progressData,
                        triggerType: triggerType
                    })
                });

                if (response.ok) {
                    lastSaveTime = currentTime;
                    console.log(`‚úÖ Progress saved (${triggerType})`);
                    
                    if (triggerType !== 'periodicSave') {
                        showSaveNotification(`Progress saved! (${triggerType})`);
                    }
                    
                    return true;
                } else {
                    console.error('‚ùå Failed to save progress:', await response.text());
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error saving player data:', error);
                return false;
            }
        }

        // Auto-save trigger functions
        function triggerLevelUpSave(newLevel, experienceGained, skillPointsEarned) {
            const levelUpData = {
                newLevel: newLevel,
                experience: experienceGained,
                skillPoints: skillPointsEarned,
                playerData: getCurrentPlayerData()
            };
            
            if (socket) {
                socket.emit('levelUp', levelUpData);
            }
            
            savePlayerData('levelUp', { levelUpTimestamp: Date.now() });
            showSaveNotification(`üéâ Level ${newLevel} reached! Progress saved.`);
        }

        function triggerCombatVictorySave(enemyData, damageDealt) {
            const combatData = {
                enemyId: enemyData.id,
                enemyName: enemyData.combatStats?.name,
                damageDealt: damageDealt,
                playerData: getCurrentPlayerData()
            };
            
            if (socket) {
                socket.emit('enemyDefeated', {
                    enemyId: enemyData.id,
                    mapId: currentMapId,
                    playerData: combatData
                });
            }
            
            savePlayerData('combatVictory', { lastCombatVictory: Date.now() });
        }

        function triggerItemAcquisitionSave(itemId, itemType, quantity = 1) {
            const itemData = {
                itemId: itemId,
                itemType: itemType,
                quantity: quantity,
                playerData: getCurrentPlayerData()
            };
            
            if (socket) {
                socket.emit('itemAcquired', itemData);
            }
            
            savePlayerData('itemAcquisition', { lastItemAcquired: itemId });
            showSaveNotification(`üíé Item acquired: ${itemId}`);
        }

        function triggerSignificantProgressSave(progressType, value) {
            const progressData = {
                progressType: progressType,
                value: value,
                playerData: getCurrentPlayerData()
            };
            
            if (socket) {
                socket.emit('significantProgress', progressData);
            }
            
            savePlayerData('significantProgress', { 
                lastSignificantProgress: { type: progressType, value: value, timestamp: Date.now() }
            });
        }

        function getCurrentPlayerData() {
            return {
                hp: player.hp,
                maxHp: player.maxHp,
                ap: player.ap,
                maxAp: player.maxAp,
                mp: player.mp,
                maxMp: player.maxMp,
                overworldX: player.overworldX,
                overworldY: player.overworldY,
                mapId: currentMapId,
                level: player.level,
                experience: player.experience,
                gold: player.gold,
                timestamp: Date.now()
            };
        }

        // UI Functions
        function showSaveNotification(message) {
            // Clear existing notification
            if (saveNotificationTimeout) {
                clearTimeout(saveNotificationTimeout);
            }
            
            // Create or update notification element
            let notification = document.getElementById('save-notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'save-notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background-color: rgba(34, 197, 94, 0.9);
                    color: white;
                    padding: 12px 16px;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 600;
                    z-index: 1000;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                    transform: translateX(100%);
                    transition: transform 0.3s ease-in-out;
                `;
                document.body.appendChild(notification);
            }
            
            notification.textContent = message;
            notification.style.transform = 'translateX(0)';
            
            saveNotificationTimeout = setTimeout(() => {
                notification.style.transform = 'translateX(100%)';
            }, 3000);
        }

        function updateStatsDisplay() {
            if (!playerStatistics) return;
            
            // You can add a stats panel to display player statistics
            // For now, we'll just log to console
            console.log('üìä Player Statistics Updated:', playerStatistics);        }

        // Add manual save and stats button functionality
        function initializeSaveUI() {
            const statsBtn = document.getElementById('stats-btn');
            const autoSaveIndicator = document.getElementById('auto-save-indicator');
            const lastSaveTimeElement = document.getElementById('last-save-time');

            if (statsBtn) {
                statsBtn.addEventListener('click', () => {
                    showPlayerStatsModal();
                });
            }

            // Update auto-save indicator periodically
            setInterval(() => {
                if (autoSaveIndicator) {
                    const now = Date.now();
                    const timeSinceLastSave = now - lastSaveTime;
                    
                    if (timeSinceLastSave < 35000) { // 35 seconds
                        autoSaveIndicator.textContent = 'üîÑ Auto-save ativo';
                        autoSaveIndicator.className = 'text-green-400';
                    } else {
                        autoSaveIndicator.textContent = '‚ö†Ô∏è Auto-save atrasado';
                        autoSaveIndicator.className = 'text-yellow-400';
                    }
                }
            }, 5000);
        }

        function updateLastSaveTime() {
            const lastSaveTimeElement = document.getElementById('last-save-time');
            if (lastSaveTimeElement) {
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                lastSaveTimeElement.textContent = `√öltimo save: ${timeString}`;
                lastSaveTime = Date.now();
            }
        }

        function showPlayerStatsModal() {
            if (!playerStatistics) {
                showSaveNotification('Carregando estat√≠sticas...');
                if (socket) {
                    socket.emit('requestPlayerStats');
                }
                return;
            }

            // Create modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background: rgba(0, 0, 0, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 9999;
            `;

            const modalContent = document.createElement('div');
            modalContent.className = 'bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl max-h-96 overflow-y-auto';
            
            modalContent.innerHTML = `
                <h2 class="text-2xl font-bold text-emerald-400 mb-4">üìä Estat√≠sticas do Jogador</h2>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm">
                    <div class="bg-gray-700 p-3 rounded">
                        <h3 class="font-semibold text-emerald-300 mb-2">‚öîÔ∏è Combate</h3>
                        <p>Batalhas vencidas: ${playerStatistics.combat?.battlesWon || 0}</p>
                        <p>Batalhas perdidas: ${playerStatistics.combat?.battlesLost || 0}</p>
                        <p>Inimigos derrotados: ${playerStatistics.combat?.enemiesDefeated || 0}</p>
                        <p>Dano total causado: ${playerStatistics.combat?.totalDamageDealt || 0}</p>
                        <p>Dano total recebido: ${playerStatistics.combat?.totalDamageTaken || 0}</p>
                    </div>
                    
                    <div class="bg-gray-700 p-3 rounded">
                        <h3 class="font-semibold text-emerald-300 mb-2">üó∫Ô∏è Explora√ß√£o</h3>
                        <p>Mapas visitados: ${playerStatistics.exploration?.mapsVisited?.length || 0}</p>
                        <p>√Åreas descobertas: ${playerStatistics.exploration?.areasDiscovered || 0}</p>
                        <p>Tesouros coletados: ${playerStatistics.exploration?.treasuresCollected || 0}</p>
                        <p>Segredos encontrados: ${playerStatistics.exploration?.secretsFound || 0}</p>
                    </div>
                    
                    <div class="bg-gray-700 p-3 rounded">
                        <h3 class="font-semibold text-emerald-300 mb-2">üìà Progress√£o</h3>
                        <p>N√≠veis ganhos: ${playerStatistics.progression?.levelsGained || 0}</p>
                        <p>Experi√™ncia ganha: ${playerStatistics.progression?.experienceGained || 0}</p>
                        <p>Ouro ganho: ${playerStatistics.progression?.goldEarned || 0}</p>
                        <p>Itens adquiridos: ${playerStatistics.progression?.itemsAcquired || 0}</p>
                    </div>
                    
                    <div class="bg-gray-700 p-3 rounded">
                        <h3 class="font-semibold text-emerald-300 mb-2">‚è±Ô∏è Sess√£o</h3>
                        <p>Tempo total: ${formatPlayTime(playerStatistics.session?.totalPlayTime || 0)}</p>
                        <p>Tempo desta sess√£o: ${formatPlayTime(playerStatistics.session?.sessionPlayTime || 0)}</p>
                        <p>Login: ${new Date(playerStatistics.session?.loginTime || 0).toLocaleString()}</p>
                    </div>
                </div>
                
                <button id="close-stats-modal" class="action-button w-full mt-4 bg-red-600 hover:bg-red-700">Fechar</button>
            `;

            modal.appendChild(modalContent);
            document.body.appendChild(modal);

            document.getElementById('close-stats-modal').addEventListener('click', () => {
                document.body.removeChild(modal);
            });

            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }

        function formatPlayTime(milliseconds) {
            const seconds = Math.floor(milliseconds / 1000);
            const minutes = Math.floor(seconds / 60);
            const hours = Math.floor(minutes / 60);
            
            if (hours > 0) {
                return `${hours}h ${minutes % 60}m`;
            } else if (minutes > 0) {
                return `${minutes}m ${seconds % 60}s`;
            } else {
                return `${seconds}s`;
            }
        }
        
        // --- Patch: Enhanced Player Data Management System ---
        // Hook into existing functions for auto-save triggers
        function hookAutoSaveTriggers() {
            // You'll need to modify existing functions to call these triggers
            // For example, in level up logic, call triggerLevelUpSave()
            // In combat victory logic, call triggerCombatVictorySave()
            // In item acquisition logic, call triggerItemAcquisitionSave()
        }        // Periodic save function - DISABLED: Server handles this now
        function startPeriodicSave() {
            // Disabled: Server-side auto-save now handles position updates
            // Client-side periodic save was overriding gold and other progress data
            console.log('üì± Client-side periodic save disabled - server handles auto-save');
            // setInterval(() => {
            //     if (gameInitialized && localPlayerId) {
            //         savePlayerData('periodicSave');
            //     }
            // }, 30000); // Save every 30 seconds
        }

        // Session management and authentication helper functions
        async function cleanupSession() {
            try {
                const session = getSession();
                if (!session.sessionToken) {
                    console.log('No session token to cleanup');
                    return;
                }

                const response = await fetch('/api/cleanup-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionToken: session.sessionToken
                    })
                });

                if (response.ok) {
                    console.log('‚úÖ Session cleaned up successfully');
                } else {
                    console.warn('‚ö†Ô∏è Session cleanup failed:', await response.text());
                }
            } catch (error) {
                console.error('‚ùå Error during session cleanup:', error);
                throw error;
            }
        }

        async function createUser(login) {
            try {
                const response = await fetch('/api/create-user', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        login: login
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ User created successfully:', data);
                    return data;
                } else {
                    const errorText = await response.text();
                    console.error('‚ùå Failed to create user:', errorText);
                    throw new Error(errorText);
                }
            } catch (error) {
                console.error('‚ùå Error creating user:', error);
                throw error;
            }
        }

        // UI Functions
    </script>
</body>
</html>
