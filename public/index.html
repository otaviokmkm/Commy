<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Commy</title>
    <!-- Replace Tailwind CSS CDN with locally compiled CSS -->
    <link href="/tailwind.css" rel="stylesheet">
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a202c; /* cinza escuro Tailwind */
            color: #e2e8f0; /* ard√≥sia clara Tailwind */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #game-and-ui-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
        }
        #main-content-area {
            display: flex;
            flex-direction: row; /* Para UI lateral */
            gap: 1rem;
            width: 100%;
            justify-content: center;
            align-items: flex-start; /* Alinha o painel lateral com o topo do game-container */
        }
        #game-area-wrapper { /* Novo wrapper para canvas e hotbar */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 70vw; /* Ajustar conforme necess√°rio */
            max-width: 800px;
        }
        #game-container {
            width: 100%; /* Ocupa toda a largura do game-area-wrapper */
            max-height: 600px; /* Mant√©m uma altura m√°xima */
            background-color: #2d3748; 
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            position: relative;
            aspect-ratio: 4 / 3; /* Exemplo de aspect ratio, ajuste conforme necess√°rio */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 0.375rem;
            cursor: pointer;
            background-color: #374151; 
        }
        #combat-hotbar {
            display: none; /* Inicialmente escondida */
            justify-content: center;
            gap: 0.5rem; /* Espa√ßo entre os slots */
            padding: 0.5rem;
            background-color: #2d3748; /* Cor similar aos pain√©is */
            border: 1px solid #4a5568;
            border-top: none; /* Para parecer conectado ao game-container se posicionado abaixo */
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
            width: 100%; /* Ocupa toda a largura do game-area-wrapper */
            box-sizing: border-box;
            margin-top: -1px; 
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background-color: #1a202c; 
            border: 1px solid #4a5568; 
            border-radius: 0.25rem; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; 
            color: #a0aec0; 
            cursor: pointer;
            position: relative; 
        }
        .hotbar-slot .slot-number {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.65rem;
            color: #718096; 
        }

        #right-ui-panel {
            width: 25vw;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .ui-panel {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        #chat-messages {
            background-color: #1e293b;
            padding: 0.5rem;
            border-radius: 0.375rem;
            height: 100px;
            overflow-y: auto;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        #chat-input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #4a5568;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .game-message {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 0.375rem;
            font-size: 0.9em;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            text-align: center;
        }
        .action-button {
            background-color: #38a169; 
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            font-weight: 600;
        }
        .action-button:hover {
            background-color: #2f855a; 
        }
        .action-button:disabled {
            background-color: #4a5568; 
            cursor: not-allowed;
        }
        .selected-action {
            background-color: #dd6b20; 
        }
        .selected-action:hover {
            background-color: #c05621; 
        }
        .combat-ui {
            display: none;
        }

        /* Minimap styles */
        #left-ui-panel {
            width: 25vw;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        #minimapCanvas {
            width: 100%;
            height: auto;
            aspect-ratio: 4 / 3;
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
        }
    </style>
</head>
<body class="bg-gray-900 text-slate-200 flex flex-col items-center min-h-screen p-4">
    <div id="auth-modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(20,23,35,0.96);display:flex;align-items:center;justify-content:center;z-index:9999;">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-full max-w-xs flex flex-col items-center">
            <h2 class="text-2xl font-bold text-emerald-400 mb-4">Entrar no Jogo</h2>
            <form id="login-form" class="w-full flex flex-col gap-2">
                <input id="login-username" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Usu√°rio" autocomplete="username" required>
                <input id="login-password" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Senha" type="password" autocomplete="current-password" required>
                <button type="submit" class="action-button w-full">Entrar</button>
            </form>
            <div class="text-slate-400 text-sm my-2">ou</div>
            <form id="register-form" class="w-full flex flex-col gap-2">
                <input id="register-username" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Novo usu√°rio" autocomplete="username" required>
                <input id="register-password" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Senha" type="password" autocomplete="new-password" required>
                <button type="submit" class="action-button w-full bg-sky-600 hover:bg-sky-700">Cadastrar</button>
            </form>
            <div id="auth-error" class="text-red-400 text-sm mt-2" style="display:none"></div>
        </div>
    </div>

    <header class="mb-6 text-center">
        <h1 class="text-4xl font-bold text-emerald-400">MMORPG T√°tico</h1>
        <p class="text-slate-400" id="statusInfo">Explorando o mundo...</p>
    </header>

    <div id="game-and-ui-wrapper">
        <div id="main-content-area">
            <!-- Left panel with minimap -->
            <div id="left-ui-panel">
                <div class="ui-panel">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">üó∫Ô∏è Minimapa</h2>
                    <div id="minimap-container">
                        <canvas id="minimapCanvas" width="200" height="150"></canvas>
                        <div id="minimap-info" class="text-xs text-slate-400 mt-2">
                            <p>Mapa: <span id="minimap-current-map">Mundo Aberto</span></p>
                            <p>Posi√ß√£o: <span id="minimap-position">0, 0</span></p>
                        </div>
                    </div>
                </div>
            </div>

            <div id="game-area-wrapper">
                <div id="game-container" class="shadow-2xl">
                    <canvas id="gameCanvas"></canvas>
                    <div id="gameLogMessage" class="game-message hidden"></div>
                </div>
                <div id="combat-hotbar">
                    </div>
            </div>

            <div id="right-ui-panel">                <div id="player-info-overworld" class="ui-panel">
                        <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Jogador</h2>
                        <p><strong>Nome:</strong> <span id="playerNameOverworld">Aventureiro</span></p>
                        <p><strong>HP:</strong> <span id="playerHPOverworld">100/100</span></p>                        <p><strong>Ouro:</strong> <span id="playerGoldOverworld">0</span>g</p>
                        <div class="mt-3 space-y-2">
                            <button id="stats-btn" class="action-button w-full bg-purple-600 hover:bg-purple-700 text-sm">üìä Estat√≠sticas</button>
                        </div>
                        <div id="save-status" class="text-xs mt-2 text-slate-400">
                            <span id="auto-save-indicator">üîÑ Auto-save ativo</span>
                            <br><span id="last-save-time">√öltimo save: nunca</span>
                        </div>
                        <p class="text-xs mt-2">Setas: Mover. Encoste em inimigos para lutar.</p>
                </div>

                <!-- Party Management Panel -->
                <div id="party-panel" class="ui-panel">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">üéâ Party</h2>
                    <div id="party-content">                        <div id="no-party-state">
                            <p class="text-sm text-slate-400 mb-3">Voc√™ n√£o est√° em uma party.</p>
                            <div class="space-y-2">
                                <p class="text-xs text-slate-300">üí° Para convidar jogadores para uma party, ande em dire√ß√£o a eles para "esbarrar"!</p>
                            </div>
                        </div>
                          <div id="party-state" style="display: none;">
                            <div id="party-members-list" class="space-y-1 mb-3">
                                <!-- Party members will be dynamically added here -->
                            </div>
                            <div class="space-y-2">
                                <p class="text-xs text-slate-300">üí° Para convidar mais jogadores, ande em dire√ß√£o a eles para "esbarrar"!</p>
                                <button id="leave-party-btn" class="action-button w-full bg-red-600 hover:bg-red-700 text-sm">üö™ Deixar Party</button>
                            </div>
                        </div>
                        
                        <div id="party-invites" style="display: none;">
                            <div class="border-t border-slate-600 pt-2 mt-2">
                                <p class="text-xs text-slate-400 mb-2">Convites recebidos:</p>
                                <div id="party-invites-list" class="space-y-1">
                                    <!-- Party invites will be dynamically added here -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="combat-ui-panel" class="ui-panel combat-ui">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Combate</h2>
                    <div id="player-stats-combat" class="text-sm space-y-1">
                        <p><strong>AP:</strong> <span id="playerAPCombat">0/0</span></p>
                        <p><strong>MP:</strong> <span id="playerMPCombat">0/0</span></p>
                    </div>
                    <div class="mt-3 space-y-2">
                        <button id="moveButton" class="action-button w-full">Mover (1)</button>
                        <button id="attackButton" class="action-button w-full">Atacar (2)</button>
                        <button id="endTurnButton" class="action-button w-full bg-sky-600 hover:bg-sky-700">Passar Turno (Espa√ßo)</button>
                    </div>
                </div>

                <div id="chat-box-container" class="ui-panel">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Chat</h2>
                    <div id="chat-messages">
                        <p><span class="font-bold text-yellow-400">[Sistema]:</span> Bem-vindo! V√° para a direita para avan√ßar de mapa.</p>
                    </div>
                    <input type="text" id="chat-input" placeholder="Digite sua mensagem..." class="focus:outline-none focus:border-emerald-500">
                </div>
            </div>
        </div>
    </div>    <script>
        // --- Multiplayer: Socket.IO instance ---
        const socket = io(); // Conecta ao servidor Socket.IO (mesmo host/porta por padr√£o)
        let localPlayerId = null; // Ser√° definido ap√≥s login/conex√£o
        let otherPlayers = {}; // Armazena dados de outros jogadores: { playerId: {x, y, name, color, mapId} }

        // --- Enhanced Player Data Management System ---
        let playerStatistics = null;

        // Update stats display in UI (for statistics panel)
        function updateStatsDisplay() {
            try {
                console.log('üìä Updating stats display...');
                
                // Check if stats panel exists and if playerStatistics is available
                if (!playerStatistics) {
                    console.log('No player statistics available yet');
                    return;
                }
                
                // Find or create stats display elements
                let statsPanel = document.getElementById('stats-panel');
                if (!statsPanel) {
                    // Create stats panel if it doesn't exist
                    statsPanel = document.createElement('div');
                    statsPanel.id = 'stats-panel';
                    statsPanel.className = 'ui-panel hidden';
                    statsPanel.innerHTML = `
                        <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">üìä Estat√≠sticas</h2>
                        <div id="stats-content" class="text-sm space-y-2">
                            <div class="border-b border-slate-600 pb-2 mb-2">
                                <p class="text-emerald-300 font-semibold">Combat:</p>
                                <p>Battles Won: <span id="stat-battles-won">0</span></p>
                                <p>Enemies Defeated: <span id="stat-enemies-defeated">0</span></p>
                                <p>Total Damage: <span id="stat-total-damage">0</span></p>
                            </div>
                            <div class="border-b border-slate-600 pb-2 mb-2">
                                <p class="text-emerald-300 font-semibold">Exploration:</p>
                                <p>Maps Visited: <span id="stat-maps-visited">0</span></p>
                                <p>Distance Traveled: <span id="stat-distance-traveled">0</span></p>
                                <p>Treasures: <span id="stat-treasures">0</span></p>
                            </div>
                            <div>
                                <p class="text-emerald-300 font-semibold">Economy:</p>
                                <p>Gold Earned: <span id="stat-gold-earned">0</span></p>
                                <p>Items Acquired: <span id="stat-items-acquired">0</span></p>
                            </div>
                        </div>
                    `;
                    // Append to a suitable parent (try multiple options)
                    const rightPanel = document.getElementById('right-ui-panel') || document.getElementById('player-info-panel') || document.body;
                    rightPanel.appendChild(statsPanel);
                }
                
                // Update stats values if playerStatistics is available
                if (playerStatistics) {
                    // Combat stats
                    if (playerStatistics.combat) {
                        const battlesWonEl = document.getElementById('stat-battles-won');
                        const enemiesDefeatedEl = document.getElementById('stat-enemies-defeated');
                        const totalDamageEl = document.getElementById('stat-total-damage');
                        
                        if (battlesWonEl) battlesWonEl.textContent = playerStatistics.combat.battlesWon || 0;
                        if (enemiesDefeatedEl) enemiesDefeatedEl.textContent = playerStatistics.combat.enemiesDefeated || 0;
                        if (totalDamageEl) totalDamageEl.textContent = playerStatistics.combat.totalDamageDealt || 0;
                    }
                    
                    // Exploration stats
                    if (playerStatistics.exploration) {
                        const mapsVisitedEl = document.getElementById('stat-maps-visited');
                        const distanceTraveledEl = document.getElementById('stat-distance-traveled');
                        const treasuresEl = document.getElementById('stat-treasures');
                        
                        if (mapsVisitedEl) {
                            const mapsCount = Array.isArray(playerStatistics.exploration.mapsVisited) 
                                ? playerStatistics.exploration.mapsVisited.length 
                                : (playerStatistics.exploration.mapsVisited?.size || 0);
                            mapsVisitedEl.textContent = mapsCount;
                        }
                        if (distanceTraveledEl) distanceTraveledEl.textContent = Math.floor(playerStatistics.exploration.distanceTraveled || 0);
                        if (treasuresEl) treasuresEl.textContent = playerStatistics.exploration.treasuresCollected || 0;
                    }
                    
                    // Economy stats
                    if (playerStatistics.progression) {
                        const goldEarnedEl = document.getElementById('stat-gold-earned');
                        const itemsAcquiredEl = document.getElementById('stat-items-acquired');
                        
                        if (goldEarnedEl) goldEarnedEl.textContent = playerStatistics.progression.goldEarned || 0;
                        if (itemsAcquiredEl) itemsAcquiredEl.textContent = playerStatistics.progression.itemsAcquired || 0;
                    }
                }
                
                console.log('üìä Stats display updated successfully');
            } catch (error) {
                console.error('‚ùå Error updating stats display:', error);
            }
        }

        // --- Minimap System ---
        let minimapCanvas, minimapCtx;
        let minimapCurrentMapEl, minimapPositionEl;
        const MINIMAP_SCALE = 0.15; // Scale factor for minimap (smaller = more zoomed out)
        const MINIMAP_TILE_SIZE = 2; // Size of each tile on minimap

        // Initialize minimap elements
        function initMinimap() {
            minimapCanvas = document.getElementById('minimapCanvas');
            minimapCtx = minimapCanvas.getContext('2d');
            minimapCurrentMapEl = document.getElementById('minimap-current-map');
            minimapPositionEl = document.getElementById('minimap-position');
            
            console.log('üó∫Ô∏è Minimap initialized');
        }

        // Update minimap info display
        function updateMinimapInfo() {
            if (minimapCurrentMapEl) {
                const mapName = currentMapId === OPEN_WORLD_ID ? 'Mundo Aberto' : `Mapa ${currentMapId}`;
                minimapCurrentMapEl.textContent = mapName;
            }
            
            if (minimapPositionEl) {
                minimapPositionEl.textContent = `${player.overworldX}, ${player.overworldY}`;
            }
        }

        // Draw minimap
        function drawMinimap() {
            if (!minimapCanvas || !minimapCtx) return;
            
            // Clear minimap
            minimapCtx.clearRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Draw border
            minimapCtx.strokeStyle = '#4a5568';
            minimapCtx.lineWidth = 1;
            minimapCtx.strokeRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            if (currentMapId === OPEN_WORLD_ID) {
                drawOpenWorldMinimap();
            } else {
                drawRegularMapMinimap();
            }
            
            // Update minimap info
            updateMinimapInfo();
        }

        // Draw open world on minimap
        function drawOpenWorldMinimap() {
            const viewportSize = 30; // How many tiles to show around player
            const centerX = minimapCanvas.width / 2;
            const centerY = minimapCanvas.height / 2;
            
            // Draw background
            minimapCtx.fillStyle = '#2d3748';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Calculate visible area around player
            const startX = Math.max(0, player.overworldX - viewportSize);
            const endX = Math.min(OPEN_WORLD_SIZE, player.overworldX + viewportSize);
            const startY = Math.max(0, player.overworldY - viewportSize);
            const endY = Math.min(OPEN_WORLD_SIZE, player.overworldY + viewportSize);
            
            // Draw terrain
            for (let y = startY; y < endY; y++) {
                for (let x = startX; x < endX; x++) {
                    if (!openWorldMap || !openWorldMap[y] || !openWorldMap[y][x]) continue;
                    
                    const tileType = openWorldMap[y][x];
                    const relX = x - player.overworldX;
                    const relY = y - player.overworldY;
                    const pixelX = centerX + relX * MINIMAP_TILE_SIZE;
                    const pixelY = centerY + relY * MINIMAP_TILE_SIZE;
                    
                    switch (tileType) {
                        case MAP_TILES.OBSTACLE_ROCK:
                            minimapCtx.fillStyle = '#718096';
                            minimapCtx.fillRect(pixelX, pixelY, MINIMAP_TILE_SIZE, MINIMAP_TILE_SIZE);
                            break;
                        case MAP_TILES.DECORATION_TREE:
                            minimapCtx.fillStyle = '#38a169';
                            minimapCtx.fillRect(pixelX, pixelY, MINIMAP_TILE_SIZE, MINIMAP_TILE_SIZE);
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            minimapCtx.fillStyle = '#48bb78';
                            minimapCtx.fillRect(pixelX, pixelY, MINIMAP_TILE_SIZE, MINIMAP_TILE_SIZE);
                            break;
                    }
                }
            }
            
            // Draw enemies on minimap
            if (openWorldEnemies) {
                openWorldEnemies.forEach(enemy => {
                    if (!enemy.isAliveOverworld) return;
                    
                    const relX = enemy.overworldX - player.overworldX;
                    const relY = enemy.overworldY - player.overworldY;
                    const pixelX = centerX + relX * MINIMAP_TILE_SIZE;
                    const pixelY = centerY + relY * MINIMAP_TILE_SIZE;
                    
                    // Only draw if enemy is within visible area
                    if (Math.abs(relX) <= viewportSize && Math.abs(relY) <= viewportSize) {
                        minimapCtx.fillStyle = '#e53e3e';
                        minimapCtx.fillRect(pixelX - 1, pixelY - 1, MINIMAP_TILE_SIZE + 2, MINIMAP_TILE_SIZE + 2);
                    }
                });
            }
            
            // Draw other players on minimap
            for (const playerId in otherPlayers) {
                const otherPlayer = otherPlayers[playerId];
                if (otherPlayer.mapId !== OPEN_WORLD_ID) continue;
                
                const relX = otherPlayer.x - player.overworldX;
                const relY = otherPlayer.y - player.overworldY;
                const pixelX = centerX + relX * MINIMAP_TILE_SIZE;
                const pixelY = centerY + relY * MINIMAP_TILE_SIZE;
                
                // Only draw if player is within visible area
                if (Math.abs(relX) <= viewportSize && Math.abs(relY) <= viewportSize) {
                    minimapCtx.fillStyle = '#4299e1';
                    minimapCtx.fillRect(pixelX - 1, pixelY - 1, MINIMAP_TILE_SIZE + 2, MINIMAP_TILE_SIZE + 2);
                }
            }
            
            // Draw player at center (always visible)
            minimapCtx.fillStyle = '#48bb78';
            minimapCtx.fillRect(centerX - 2, centerY - 2, 4, 4);
            
            // Draw player direction indicator
            minimapCtx.strokeStyle = '#48bb78';
            minimapCtx.lineWidth = 2;
            minimapCtx.beginPath();
            minimapCtx.moveTo(centerX, centerY);
            minimapCtx.lineTo(centerX, centerY - 6);
            minimapCtx.stroke();
        }

        // Draw regular map on minimap
        function drawRegularMapMinimap() {
            if (!mapData || GRID_COLS === 0 || GRID_ROWS === 0) return;
            
            // Draw background
            minimapCtx.fillStyle = '#2d3748';
            minimapCtx.fillRect(0, 0, minimapCanvas.width, minimapCanvas.height);
            
            // Calculate scale to fit entire map in minimap
            const scaleX = minimapCanvas.width / GRID_COLS;
            const scaleY = minimapCanvas.height / GRID_ROWS;
            const tileScale = Math.min(scaleX, scaleY, 4); // Max 4px per tile
            
            const offsetX = (minimapCanvas.width - GRID_COLS * tileScale) / 2;
            const offsetY = (minimapCanvas.height - GRID_ROWS * tileScale) / 2;
            
            // Draw terrain
            for (let y = 0; y < GRID_ROWS; y++) {
                for (let x = 0; x < GRID_COLS; x++) {
                    if (!mapData[y] || !mapData[y][x]) continue;
                    
                    const tileType = mapData[y][x];
                    const pixelX = offsetX + x * tileScale;
                    const pixelY = offsetY + y * tileScale;
                    
                    switch (tileType) {
                        case MAP_TILES.OBSTACLE_ROCK:
                            minimapCtx.fillStyle = '#718096';
                            minimapCtx.fillRect(pixelX, pixelY, tileScale, tileScale);
                            break;
                        case MAP_TILES.DECORATION_TREE:
                            minimapCtx.fillStyle = '#38a169';
                            minimapCtx.fillRect(pixelX, pixelY, tileScale, tileScale);
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            minimapCtx.fillStyle = '#48bb78';
                            minimapCtx.fillRect(pixelX, pixelY, tileScale, tileScale);
                            break;
                    }
                }
            }
            
            // Draw enemies on minimap
            if (enemies) {
                enemies.forEach(enemy => {
                    if (!enemy.isAliveOverworld || enemy.mapId !== currentMapId) return;
                    
                    const pixelX = offsetX + enemy.overworldX * tileScale;
                    const pixelY = offsetY + enemy.overworldY * tileScale;
                    
                    minimapCtx.fillStyle = '#e53e3e';
                    minimapCtx.fillRect(pixelX - 1, pixelY - 1, tileScale + 2, tileScale + 2);
                });
            }
            
            // Draw other players on minimap
            for (const playerId in otherPlayers) {
                const otherPlayer = otherPlayers[playerId];
                if (otherPlayer.mapId !== currentMapId) continue;
                
                const pixelX = offsetX + otherPlayer.x * tileScale;
                const pixelY = offsetY + otherPlayer.y * tileScale;
                
                minimapCtx.fillStyle = '#4299e1';
                minimapCtx.fillRect(pixelX - 1, pixelY - 1, tileScale + 2, tileScale + 2);
            }
            
            // Draw player
            const playerPixelX = offsetX + player.overworldX * tileScale;
            const playerPixelY = offsetY + player.overworldY * tileScale;
            
            minimapCtx.fillStyle = '#48bb78';
            minimapCtx.fillRect(playerPixelX - 2, playerPixelY - 2, tileScale + 4, tileScale + 4);
        }        // --- Party System Variables ---
        let currentParty = null; // Current party data: { id, leader, members: [], invites: [] }
        let pendingPartyInvites = []; // Array of incoming party invites: [{ from: playerId, fromName: playerName, partyId: id }]
          // --- Floating UI Messages System ---
        let floatingMessages = []; // Array of floating messages: [{ x, y, text, color, duration, playerId, type }]

        // Function to add a floating message above a player
        function addFloatingMessage(playerX, playerY, text, color = '#60a5fa', duration = 3000, playerId = null, type = 'party-invite') {
            const messageId = Date.now() + Math.random();
            const message = {
                id: messageId,
                x: playerX,
                y: playerY,
                text: text,
                color: color,
                duration: duration,
                playerId: playerId,
                type: type,
                startTime: Date.now(),
                alpha: 1.0
            };
            
            floatingMessages.push(message);
            
            // Auto-remove after duration
            setTimeout(() => {
                floatingMessages = floatingMessages.filter(msg => msg.id !== messageId);
            }, duration);
            
            return messageId;
        }

        // Function to remove floating messages for a specific player
        function removeFloatingMessagesForPlayer(playerId) {
            floatingMessages = floatingMessages.filter(msg => msg.playerId !== playerId);
        }

        // Function to draw floating messages
        function drawFloatingMessages() {
            const now = Date.now();
            
            floatingMessages.forEach(message => {
                const elapsed = now - message.startTime;
                const progress = elapsed / message.duration;
                
                if (progress < 1) {
                    // Calculate fade out effect in the last 20% of duration
                    const fadeStart = 0.8;
                    let alpha = 1.0;
                    if (progress > fadeStart) {
                        alpha = 1.0 - ((progress - fadeStart) / (1.0 - fadeStart));
                    }
                    
                    // Calculate position (move up slightly over time)
                    const yOffset = -25 - (progress * 10);
                    
                    // Convert grid coordinates to pixel coordinates if we're in overworld
                    let pixelX, pixelY;
                    if (gameState === 'overworld') {
                        if (currentMapId === OPEN_WORLD_ID) {
                            // Open world coordinate system
                            const halfW = Math.floor(cameraWidth / 2);
                            const halfH = Math.floor(cameraHeight / 2);
                            const camLeft = Math.max(0, Math.min(player.overworldX - halfW, OPEN_WORLD_SIZE - cameraWidth));
                            const camTop = Math.max(0, Math.min(player.overworldY - halfH, OPEN_WORLD_SIZE - cameraHeight));
                            
                            const relX = message.x - camLeft;
                            const relY = message.y - camTop;
                            
                            // Only draw if within camera view
                            if (relX >= 0 && relX < cameraWidth && relY >= 0 && relY < cameraHeight) {
                                pixelX = relX * TILE_SIZE + TILE_SIZE / 2;
                                pixelY = relY * TILE_SIZE + yOffset;
                            } else {
                                return; // Skip drawing if outside camera view
                            }
                        } else {
                            // Regular map coordinate system
                            pixelX = message.x * TILE_SIZE + TILE_SIZE / 2;
                            pixelY = message.y * TILE_SIZE + yOffset;
                        }
                    } else {
                        return; // Don't draw in combat mode
                    }
                    
                    // Draw the message
                    ctx.save();
                    ctx.globalAlpha = alpha;
                    ctx.fillStyle = message.color;
                    ctx.font = 'bold 12px Inter, sans-serif';
                    ctx.textAlign = 'center';
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 3;
                    
                    // Draw text outline for better visibility
                    ctx.strokeText(message.text, pixelX, pixelY);
                    ctx.fillText(message.text, pixelX, pixelY);
                    
                    ctx.restore();
                }
            });
        }


        // --- Autentica√ß√£o: Modal de Login/Cadastro ---
        const authModal = document.getElementById('auth-modal');
        function showAuthModal() { authModal.style.display = 'flex'; }
        function hideAuthModal() { authModal.style.display = 'none'; }
        function setAuthError(msg) { const err = document.getElementById('auth-error'); err.textContent = msg; err.style.display = 'block'; }
        function clearAuthError() { const err = document.getElementById('auth-error'); err.textContent = ''; err.style.display = 'none'; }        function saveSession(token, username) { localStorage.setItem('sessionToken', token); localStorage.setItem('username', username); }
        function clearSession() { localStorage.removeItem('sessionToken'); localStorage.removeItem('username'); }
        function getSession() { return { token: localStorage.getItem('sessionToken'), username: localStorage.getItem('username') }; }
        
        // Session cleanup function for server-side cleanup before clearing local session
        async function cleanupSession() {
            const session = getSession();
            if (!session.username) {
                console.log('üîß No session to cleanup');
                return;
            }
            
            try {
                console.log(`üßπ Cleaning up session for user: ${session.username}`);
                const response = await fetch('/api/cleanup-session', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ login: session.username })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('‚úÖ Session cleanup successful:', data.message);
                } else {
                    const errorData = await response.text();
                    console.warn('‚ö†Ô∏è Session cleanup failed:', errorData);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Session cleanup error (non-critical):', error.message);
                // Don't throw - cleanup errors shouldn't prevent logout/reload
            }
        }

        // Login
        document.getElementById('login-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            clearAuthError();
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            try {
                const res = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ login: username, password })
                });
                if (res.ok) {
                    const data = await res.json();
                    saveSession(data.token, username);
                    player.name = username;
                    localPlayerId = username; // Multiplayer: Define o ID do jogador local
                    hideAuthModal();
                    startGameAfterAuth();
                } else {
                    const errorData = await res.json().catch(() => ({ error: 'Usu√°rio ou senha inv√°lidos.' }));
                    setAuthError(errorData.error || 'Usu√°rio ou senha inv√°lidos.');
                }
            } catch (error) {
                // console.error("Erro no login:", error);
                setAuthError('Erro de conex√£o ao tentar fazer login.');
            }
        });

        // Cadastro
        document.getElementById('register-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            clearAuthError();
            const username = document.getElementById('register-username').value.trim();
            const password = document.getElementById('register-password').value;
            try {
                const res = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ login: username, password })
                });
                if (res.ok) {
                    // Ap√≥s cadastro, faz login autom√°tico
                    const loginRes = await fetch('/api/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ login: username, password })
                    });
                    if (loginRes.ok) {
                        const loginData = await loginRes.json();
                        saveSession(loginData.token, username);
                        player.name = username;
                        localPlayerId = username; // Multiplayer: Define o ID do jogador local
                        hideAuthModal();
                        startGameAfterAuth();
                    } else {
                        setAuthError('Erro ao fazer login autom√°tico ap√≥s cadastro.');
                    }
                } else {
                    let msg = 'Erro ao cadastrar.';
                    try { const err = await res.json(); if (err && err.error) { msg = err.error; } } catch {}
                    setAuthError(msg);
                }
            } catch (error) {
                // console.error("Erro no cadastro:", error);
                setAuthError('Erro de conex√£o ao tentar cadastrar.');
            }
        });

        // Logout (bot√£o no painel do jogador)
        function addLogoutButton() {
            let btn = document.getElementById('logout-btn');
            if (!btn) {
                btn = document.createElement('button');
                btn.id = 'logout-btn';
                btn.textContent = 'Sair';
                btn.className = 'action-button w-full bg-red-600 hover:bg-red-700 mt-3';                btn.onclick = async () => {
                    // No save before logout - SIMPLIFIED: Only save after combat
                    // showSaveNotification('Saving progress before logout...');
                    // await savePlayerData('logout');
                    
                    if (socket && localPlayerId) { // Multiplayer: Notifica o servidor sobre a sa√≠da
                        socket.emit('playerDisconnecting', { playerId: localPlayerId, mapId: currentMapId });
                    }
                    clearSession();
                    localPlayerId = null;
                    otherPlayers = {};
                    showAuthModal();
                    location.reload(); // Recarrega a p√°gina para limpar o estado do jogo
                };
                playerInfoOverworldPanel.appendChild(btn);
            }
        }

        // Bloqueia inicializa√ß√£o do jogo at√© autenticar
        let gameInitialized = false;        function startGameAfterAuth() {
            if (gameInitialized) return;
            gameInitialized = true;
            player.name = getSession().username || 'Aventureiro';
            if (!localPlayerId && player.name !== 'Aventureiro') { // Garante que localPlayerId seja definido
                localPlayerId = player.name;
            }            addLogoutButton();
              // Initialize auto-save system
            hookAutoSaveTriggers();
            startPeriodicSave();
            initializeSaveUI();
            
            // Initialize party system UI
            setupPartyUI();
            updatePartyUI();
            
            // Load player data immediately after authentication
            console.log('üéÆ Starting game after auth, loading player data...');
            loadPlayerData();
            
            initGame(); // initGame agora tamb√©m configura os listeners do socket
            // Load the map once after auth so we have initial map data
            loadMap(currentMapId);
        }        // --- Elementos do DOM ---
        let canvas, ctx, gameContainer; // Declare variables but don't initialize them yet
        let combatHotbarElement, chatInput, chatMessages, gameLogMessage, statusInfoDisplay;
        let playerNameOverworldDisplay, playerHPOverworldDisplay, playerGoldOverworldDisplay;
        let playerAPCombatDisplay, playerMPCombatDisplay, combatUiPanel, playerInfoOverworldPanel;
        let moveButton, attackButton, endTurnButton;

        // Ao carregar a p√°gina, verifica sess√£o
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize DOM elements after DOM is fully loaded
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            gameContainer = document.getElementById('game-container');
            combatHotbarElement = document.getElementById('combat-hotbar'); 
            chatInput = document.getElementById('chat-input');
            chatMessages = document.getElementById('chat-messages');
            gameLogMessage = document.getElementById('gameLogMessage');
            statusInfoDisplay = document.getElementById('statusInfo');

            playerNameOverworldDisplay = document.getElementById('playerNameOverworld');
            playerHPOverworldDisplay = document.getElementById('playerHPOverworld');
            playerGoldOverworldDisplay = document.getElementById('playerGoldOverworld');
            
            playerAPCombatDisplay = document.getElementById('playerAPCombat');
            playerMPCombatDisplay = document.getElementById('playerMPCombat');
            combatUiPanel = document.getElementById('combat-ui-panel');
            playerInfoOverworldPanel = document.getElementById('player-info-overworld');

            moveButton = document.getElementById('moveButton');
            attackButton = document.getElementById('attackButton');
            endTurnButton = document.getElementById('endTurnButton');
            
            // Verify canvas and context are properly initialized
            if (!canvas) {
                console.error('‚ùå Canvas element not found!');
                return;
            }
            if (!ctx) {
                console.error('‚ùå Canvas context not found!');
                return;
            }
            console.log('‚úÖ Canvas and context initialized successfully');
            
            const session = getSession();
            if (session.token && session.username) {
                localPlayerId = session.username; // Multiplayer: Define o ID do jogador local
                hideAuthModal();
                startGameAfterAuth();
            } else {
                showAuthModal();
            }        });

        // --- Configura√ß√µes do Jogo ---
        const TILE_SIZE = 40; 
        let GRID_COLS, GRID_ROWS; 
        
        let gameState = 'overworld'; 
        const HOTBAR_SLOTS = 5; 
        let currentMapId = 'open_world'; // Mapa inicial - Open World
        let lastAiUpdateTime = 0;
        const AI_UPDATE_INTERVAL = 500; 

        // --- Open World (grande) ---
        const OPEN_WORLD_ID = 'open_world';
        const OPEN_WORLD_SIZE = 200;
        let openWorldMap = null; // 2D array
        let openWorldEnemies = [];
        let cameraX = 0, cameraY = 0;
        let cameraWidth = 0, cameraHeight = 0;

        // --- Dados do Mapa Overworld ---
        const MAP_TILES = {
            EMPTY: 0,
            OBSTACLE_ROCK: 1,
            DECORATION_TREE: 2,
            DECORATION_BUSH: 3,
        };        const mapConnections = {
            // Tutorial maps removed - game starts in open world
        };

        let mapData = [];        function generateMapFor(mapId) {
            // Multiplayer: Now using server-generated map data when available
            // The client will receive map layout from server via 'mapState' event
              if (mapId === OPEN_WORLD_ID) {
                // Don't generate open world locally anymore - wait for server data
                // The server will send the persistent map layout via mapState event
                if (!openWorldMap) {
                    // Temporary fallback while waiting for server data
                    console.log('‚è≥ Waiting for server map data for open world...');
                    openWorldMap = [];
                    for (let r = 0; r < OPEN_WORLD_SIZE; r++) {
                        openWorldMap[r] = [];
                        for (let c = 0; c < OPEN_WORLD_SIZE; c++) {
                            openWorldMap[r][c] = MAP_TILES.EMPTY; // Empty until server sends data
                        }
                    }
                    openWorldEnemies = []; // Will be populated by server data
                }
                mapData = openWorldMap;
                console.log('üåç Open world map prepared - awaiting server data...');
            } else { // Mapas menores
                mapData = [];
                if (GRID_ROWS <= 0 || GRID_COLS <= 0) return; 
                for (let r = 0; r < GRID_ROWS; r++) {
                    mapData[r] = [];
                    for (let c = 0; c < GRID_COLS; c++) mapData[r][c] = MAP_TILES.EMPTY;
                }
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        if (r === 0 || r === GRID_ROWS - 1 || c === 0 || c === GRID_COLS - 1) {
                            const connections = mapConnections[mapId] || {};
                            let isConnectionTile = false;
                            if (r === 0 && connections.up) isConnectionTile = true;
                            else if (r === GRID_ROWS - 1 && connections.down) isConnectionTile = true;
                            else if (c === 0 && connections.left) isConnectionTile = true;
                            else if (c === GRID_COLS - 1 && connections.right) isConnectionTile = true;
                            if (!isConnectionTile) mapData[r][c] = MAP_TILES.OBSTACLE_ROCK;
                        }
                    }
                }
                let rockDensity = 0.05, decorDensity = 0.1;
                if (mapId === 'mapa_chefe') { rockDensity = 0.1; decorDensity = 0.05; }
                for (let r = 1; r < GRID_ROWS - 1; r++) { 
                    for (let c = 1; c < GRID_COLS - 1; c++) {
                        let isEntitySpawn = (r === player.overworldY && c === player.overworldX);
                        if (!isEntitySpawn) {
                            for (const enemy of enemies) { // Usa a lista 'enemies' para mapas normais
                                if (enemy.mapId === mapId && enemy.isAliveOverworld && enemy.overworldY === r && enemy.overworldX === c) {
                                    isEntitySpawn = true; break;
                                }
                            }
                        }
                        if (isEntitySpawn) continue; 
                        if (Math.random() < rockDensity) mapData[r][c] = MAP_TILES.OBSTACLE_ROCK;
                        else if (Math.random() < decorDensity) mapData[r][c] = Math.random() < 0.5 ? MAP_TILES.DECORATION_TREE : MAP_TILES.DECORATION_BUSH;
                    }
                }
                if (isValidOverworldTile(player.overworldX, player.overworldY) && mapData[player.overworldY]) { 
                    mapData[player.overworldY][player.overworldX] = MAP_TILES.EMPTY;
                }
                enemies.forEach(enemy => {
                    if (enemy.mapId === mapId && enemy.isAliveOverworld && isValidOverworldTile(enemy.overworldX, enemy.overworldY)) {
                        if(mapData[enemy.overworldY]) mapData[enemy.overworldY][enemy.overworldX] = MAP_TILES.EMPTY;
                    }
                });
            }
        }


        let player = {
            overworldX: 1, overworldY: 1, 
            gridX: 0, gridY: 0,
            size: TILE_SIZE * 0.8,
            color: 'deepskyblue', // Cor padr√£o do jogador local
            hp: 100, maxHp: 100,
            ap: 6, maxAp: 6,
            mp: 3, maxMp: 3,
            attackPower: 15,
            attackRange: 2, 
            isAlive: true,
            name: "Aventureiro",
            gold: 0,
        };
        let enemies = [ 
            // Tutorial enemies removed - game starts in open world
            // Only combat-only enemies remain for special encounters
            { id: -1, mapId: 'combate_apenas', overworldX: -1, overworldY: -1, isAliveOverworld: false, combatStats: { size: TILE_SIZE * 0.7, color: 'crimson', hp: 50, maxHp: 50, ap: 4, maxAp: 4, mp: 2, maxMp: 2, attackPower: 8, attackRange: 1, name: "Guarda Goblin" } },
        ];
        let activeCombatEnemy = null; 

        let currentTurn = 'player'; 
        let selectedAction = null; 
        let highlightedTiles = []; 

        // --- Inicializa√ß√£o ---
        function initGame() {
            if (!ctx) {
                // console.error("Contexto do canvas n√£o encontrado. O jogo n√£o pode ser iniciado.");
                return;
            }
            resizeCanvas(); 
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleGlobalKeyDown); 
            canvas.addEventListener('click', handleCanvasClick);
            moveButton.addEventListener('click', () => setSelectedAction('move'));
            attackButton.addEventListener('click', () => setSelectedAction('attack'));
            endTurnButton.addEventListener('click', endPlayerTurn);
            chatInput.addEventListener('keypress', handleChatInput);            createHotbarSlots(); 
            initMinimap(); // Initialize minimap functionality

            // Multiplayer: Configurar listeners do Socket.IO
            setupSocketListeners();

            gameLoop(); 
        }

        // Multiplayer: Fun√ß√£o para configurar listeners do Socket.IO
        function setupSocketListeners() {
            if (!socket) {
                // console.error("Socket n√£o inicializado.");
                return;
            }

            // Enhanced connection handling
            socket.on('connect', () => {
                console.log('üîó Connected to server');
                showSaveNotification('Connected to server');
                
                // Authenticate with server
                const session = getSession();
                if (session.token && session.username) {
                    socket.emit('authenticate', {
                        login: session.username,
                        sessionToken: session.token
                    });
                }
                
                if (localPlayerId) { 
                    loadMap(currentMapId); 
                }
            });            socket.on('disconnect', (reason) => {
                console.log('‚ùå Disconnected from server:', reason);
                addChatMessage('[Sistema]', 'Conex√£o perdida. Tentando reconectar...');
                otherPlayers = {}; 
                
                // Don't attempt to save on disconnect as connection is already lost
                console.log('üíæ Skipping save on disconnect to prevent connection errors');
            });

            socket.on('reconnect', (attemptNumber) => {
                console.log('üîÑ Reconnected to server after', attemptNumber, 'attempts');
                showSaveNotification('Reconnected to server!');
                addChatMessage('[Sistema]', 'Conex√£o reestabelecida!');
                
                // Re-authenticate after reconnection
                const session = getSession();
                if (session.token && session.username) {
                    socket.emit('authenticate', {
                        login: session.username,
                        sessionToken: session.token
                    });
                }
            });

            socket.on('reconnect_error', (error) => {
                console.error('‚ùå Reconnection failed:', error);
                addChatMessage('[Sistema]', 'Falha ao reconectar. Tente atualizar a p√°gina.');
            });            socket.on('mapState', (data) => {
                if (data.mapId === currentMapId) {
                    otherPlayers = {}; 
                    data.players.forEach(p => {
                        if (p.playerId !== localPlayerId) {
                            otherPlayers[p.playerId] = {
                                x: p.x,
                                y: p.y,
                                name: p.name || `Jogador ${p.playerId.substring(0,4)}`,
                                color: p.color || '#cccccc', 
                                mapId: p.mapId 
                            };
                        }
                    });
                    
                    // Apply server-provided map layout and enemies data
                    if (data.mapLayoutData) {
                        console.log('‚úÖ Received server map layout for', currentMapId);
                        if (currentMapId === OPEN_WORLD_ID) {
                            openWorldMap = data.mapLayoutData;
                            mapData = openWorldMap;
                        } else {
                            mapData = data.mapLayoutData;
                        }
                    }
                      // Apply server-provided enemies data
                    if (data.enemies) {
                        console.log('‚úÖ Received server enemies data for', currentMapId, '- Count:', data.enemies.length);
                        console.log('[DEBUG] First enemy loot data:', data.enemies[0]?.combatStats?.loot);                        if (currentMapId === OPEN_WORLD_ID) {
                            // Enemies are now properly distributed on the server
                            openWorldEnemies = [];
                            data.enemies.forEach(e => {
                                openWorldEnemies.push({
                                    id: e.id,
                                    overworldX: e.overworldX,
                                    overworldY: e.overworldY,
                                    isAliveOverworld: e.isAliveOverworld,
                                    aggroRange: e.aggroRange,
                                    combatStats: e.combatStats,
                                    inCombat: e.inCombat || false,
                                    combatPlayerId: e.combatPlayerId || null
                                });
                            });
                            console.log('[DEBUG] First openWorldEnemy loot:', openWorldEnemies[0]?.combatStats?.loot);
                            // Additional debug: Test combat simulation
                            if (openWorldEnemies.length > 0) {
                                console.log('[DEBUG] Enemy 0 full combatStats:', openWorldEnemies[0].combatStats);
                                const testLoot = openWorldEnemies[0].combatStats.loot;
                                console.log('[DEBUG] Test loot extraction:', testLoot);
                                console.log('[DEBUG] Test loot gold value:', testLoot?.gold);
                            }
                        } else {
                            // Update enemies list for regular maps
                            enemies = enemies.filter(e => e.mapId !== currentMapId);                            data.enemies.forEach(serverEnemy => {
                                enemies.push({
                                    id: serverEnemy.id,
                                    mapId: currentMapId,
                                    overworldX: serverEnemy.overworldX,
                                    overworldY: serverEnemy.overworldY,
                                    isAliveOverworld: serverEnemy.isAliveOverworld,
                                    aggroRange: serverEnemy.aggroRange,
                                    combatStats: serverEnemy.combatStats,
                                    inCombat: serverEnemy.inCombat || false,
                                    combatPlayerId: serverEnemy.combatPlayerId || null
                                });
                            });
                        }
                    }
                    
                    console.log('üìä Map state updated for', currentMapId, '- Players:', Object.keys(otherPlayers).length);
                }
            });

            socket.on('playerJoined', (newPlayerData) => {
                if (newPlayerData.mapId === currentMapId && newPlayerData.playerId !== localPlayerId) {
                    otherPlayers[newPlayerData.playerId] = {
                        x: newPlayerData.x,
                        y: newPlayerData.y,
                        name: newPlayerData.name || `Jogador ${newPlayerData.playerId.substring(0,4)}`,
                        color: newPlayerData.color || '#cccccc',
                        mapId: newPlayerData.mapId
                    };
                    addChatMessage('[Sistema]', `${otherPlayers[newPlayerData.playerId].name} entrou no mapa.`);
                    // console.log('Jogador entrou:', newPlayerData.playerId, "em", newPlayerData.mapId);
                }
            });

            socket.on('playerMoved', (moveData) => {
                if (moveData.mapId === currentMapId && moveData.playerId !== localPlayerId) {
                    if (otherPlayers[moveData.playerId]) {
                        otherPlayers[moveData.playerId].x = moveData.x;
                        otherPlayers[moveData.playerId].y = moveData.y;
                    } else {
                        otherPlayers[moveData.playerId] = {
                            x: moveData.x, y: moveData.y, name: `Jogador ${moveData.playerId.substring(0,4)}`, color: '#cccccc', mapId: moveData.mapId
                        };
                    }
                    // console.log('Jogador moveu:', moveData.playerId, "para", moveData.x, moveData.y);
                }
            });

            socket.on('playerLeft', (leaveData) => {
                if (leaveData.mapId === currentMapId && otherPlayers[leaveData.playerId]) {
                    addChatMessage('[Sistema]', `${otherPlayers[leaveData.playerId].name || 'Um jogador'} saiu do mapa.`);
                    delete otherPlayers[leaveData.playerId];
                    // console.log('Jogador saiu:', leaveData.playerId);
                }
            });
            
            socket.on('chatMessage', (data) => {
                if (data.senderId !== localPlayerId) { 
                    addChatMessage(data.senderName, data.message);
                }
            });            socket.on('combatStarted', (data) => {
                console.log(`[DEBUG] Received combatStarted event:`, data);
                const { opponent } = data;
                activeCombatEnemy = opponent;
                gameState = 'combat';
                logGameMessage(`Combate iniciado com ${opponent.combatStats.name}!`, 3000);
                initiateCombat(opponent);
            });

            // Handle enemy combat status changes for multiplayer visibility
            socket.on('enemyCombatStatusChanged', (data) => {
                const { enemyId, inCombat, combatPlayerId } = data;
                console.log(`[COMBAT] Enemy ${enemyId} combat status changed: inCombat=${inCombat}, player=${combatPlayerId}`);
                
                // Update enemy combat status in both enemy lists
                if (currentMapId === OPEN_WORLD_ID) {
                    const enemy = openWorldEnemies.find(e => e.id === enemyId);
                    if (enemy) {
                        enemy.inCombat = inCombat;
                        enemy.combatPlayerId = combatPlayerId;
                    }
                } else {
                    const enemy = enemies.find(e => e.id === enemyId && e.mapId === currentMapId);
                    if (enemy) {
                        enemy.inCombat = inCombat;
                        enemy.combatPlayerId = combatPlayerId;
                    }
                }            });

            // Handle enemy defeated broadcast from server
            socket.on('enemyDefeated', (data) => {
                const { enemyId, mapId } = data;
                console.log(`[ENEMY DEFEATED] Enemy ${enemyId} defeated in map ${mapId} - removing from local game world`);
                
                if (mapId === currentMapId) {
                    if (currentMapId === OPEN_WORLD_ID) {
                        // Immediately remove defeated open world enemy
                        openWorldEnemies = openWorldEnemies.filter(e => e.id !== enemyId);
                        console.log(`[ENEMY DEFEATED] Open world enemy ${enemyId} removed from local game world`);
                    } else {
                        // Immediately remove defeated regular map enemy
                        enemies = enemies.filter(e => !(e.id === enemyId && e.mapId === currentMapId));
                        console.log(`[ENEMY DEFEATED] Regular map enemy ${enemyId} removed from local game world`);
                    }
                }
            });

            // Server-side monster position updates
            socket.on('monsterPositionUpdate', (data) => {
                if (data.mapId === currentMapId) {
                    data.monsters.forEach(monsterUpdate => {
                        // Update open world enemies
                        if (currentMapId === OPEN_WORLD_ID) {
                            const enemy = openWorldEnemies.find(e => e.id === monsterUpdate.id);
                            if (enemy) {
                                enemy.overworldX = monsterUpdate.overworldX;
                                enemy.overworldY = monsterUpdate.overworldY;
                            }
                        } else {
                            // Update regular map enemies
                            const enemy = enemies.find(e => e.id === monsterUpdate.id && e.mapId === currentMapId);
                            if (enemy) {
                                enemy.overworldX = monsterUpdate.overworldX;
                                enemy.overworldY = monsterUpdate.overworldY;
                            }
                        }
                    });
                }
            });// Enhanced Auto-Save Integration
            socket.on('authenticationSuccess', () => {
                console.log('‚úÖ Authentication successful via socket');
                // Only load data if it hasn't been loaded yet (fallback protection)
                if (player.gold === undefined || player.gold === 0) {
                    console.log('üîÑ Loading player data via socket authentication success...');
                    loadPlayerData();
                } else {
                    console.log('üìä Player data already loaded, skipping duplicate load');
                }
            });

            socket.on('authenticationFailed', (data) => {
                console.log('‚ùå Authentication failed:', data);
                const { message, code, userExists, login } = data;
                
                if (code === 'TOKEN_MISMATCH') {
                    console.log('üîß Token mismatch detected, cleaning up session...');
                    cleanupSession().then(() => {
                        alert('Session expired. Please login again.');
                        clearSession();
                        location.reload();
                    }).catch(err => {
                        console.error('Failed to cleanup session:', err);
                        alert('Session error. Please login again.');
                        clearSession();
                        location.reload();
                    });
                } else if (code === 'USER_NOT_FOUND') {
                    console.log('üë§ User not found, attempting to create user...');
                    createUser(login).then(() => {
                        alert('User created successfully. Please login again.');
                        clearSession();
                        location.reload();
                    }).catch(err => {
                        console.error('Failed to create user:', err);
                        alert('Failed to create user. Please contact support.');
                        clearSession();
                        location.reload();
                    });
                } else {
                    alert(message || 'Authentication failed. Please login again.');
                    clearSession();
                    location.reload();
                }
            });

            socket.on('playerStatsUpdate', (stats) => {
                // Update local player statistics
                playerStatistics = stats;
                updateStatsDisplay();
            });

            socket.on('saveConfirmation', (data) => {
                const { triggerType, message } = data;
                showSaveNotification(message || `Progress saved (${triggerType})`);
            });            socket.on('sessionInvalidated', (data) => {
                alert(data.message || 'Your session has been invalidated.');
                clearSession();
                location.reload();
            });

            // --- Party System Socket Handlers ---
            socket.on('partyCreated', (data) => {
                console.log('üéâ Party created:', data);
                currentParty = data.party;
                updatePartyUI();
                logGameMessage(`Party criada! Voc√™ √© o l√≠der.`, 3000);
            });            socket.on('partyInviteReceived', (data) => {
                console.log('üì© [PARTY DEBUG] Party invite received:', data);
                console.log('üì© [PARTY DEBUG] Current pending invites before:', pendingPartyInvites.length);
                const { from, fromName, partyId } = data;
                
                // Add to pending invites if not already present
                const existingInvite = pendingPartyInvites.find(invite => invite.from === from && invite.partyId === partyId);
                console.log('üì© [PARTY DEBUG] Existing invite check:', existingInvite ? 'FOUND' : 'NOT FOUND');
                
                if (!existingInvite) {
                    pendingPartyInvites.push({ from, fromName, partyId });
                    console.log('üì© [PARTY DEBUG] Added invite to pending list. New count:', pendingPartyInvites.length);
                    updatePartyUI();
                    logGameMessage(`${fromName} te convidou para uma party!`, 4000);
                } else {
                    console.log('üì© [PARTY DEBUG] Invite already exists, skipping');
                }
            });

            socket.on('partyInviteAccepted', (data) => {
                console.log('‚úÖ Party invite accepted:', data);
                currentParty = data.party;
                updatePartyUI();
                logGameMessage(`${data.playerName} entrou na party!`, 3000);
            });

            socket.on('partyInviteDeclined', (data) => {
                console.log('‚ùå Party invite declined:', data);
                logGameMessage(`${data.playerName} recusou o convite para a party.`, 3000);
            });

            socket.on('partyJoined', (data) => {
                console.log('üéâ Joined party:', data);
                currentParty = data.party;
                updatePartyUI();
                logGameMessage(`Voc√™ entrou na party de ${data.party.leaderName}!`, 3000);
            });

            socket.on('partyLeft', (data) => {
                console.log('üö™ Left party:', data);
                currentParty = null;
                updatePartyUI();
                logGameMessage(`Voc√™ saiu da party.`, 3000);
            });

            socket.on('partyMemberJoined', (data) => {
                console.log('üëã Party member joined:', data);
                if (currentParty) {
                    const { playerId, playerName } = data;
                    if (!currentParty.members.find(m => m.id === playerId)) {
                        currentParty.members.push({ id: playerId, name: playerName });
                        updatePartyUI();
                        logGameMessage(`${playerName} entrou na party!`, 3000);
                    }
                }
            });

            socket.on('partyMemberLeft', (data) => {
                console.log('üëã Party member left:', data);
                if (currentParty) {
                    const { playerId, playerName } = data;
                    currentParty.members = currentParty.members.filter(m => m.id !== playerId);
                    
                    // If we were the leader and left, clear party
                    if (playerId === localPlayerId) {
                        currentParty = null;
                    } else if (currentParty.leader === playerId) {
                        // Leader left, update leader if provided
                        if (data.newLeader) {
                            currentParty.leader = data.newLeader;
                            currentParty.leaderName = data.newLeaderName;
                        }
                    }
                    
                    updatePartyUI();
                    logGameMessage(`${playerName} saiu da party.`, 3000);
                }
            });

            socket.on('partyDisbanded', (data) => {
                console.log('üí• Party disbanded:', data);
                currentParty = null;
                updatePartyUI();
                logGameMessage(`A party foi dissolvida.`, 3000);
            });            socket.on('partyError', (data) => {
                console.log('‚ùå [PARTY DEBUG] Party error received:', data);
                logGameMessage(`Erro na party: ${data.message}`, 4000);
            });

            socket.on('partyInviteSent', (data) => {
                console.log('üì§ [PARTY DEBUG] Party invite sent confirmation:', data);
                logGameMessage(`Convite enviado para ${data.targetName}!`, 3000);
            });
        }


        function loadMap(mapId, entrySide) {
            const oldMapId = currentMapId;
            currentMapId = mapId;
            otherPlayers = {}; // Multiplayer: Limpa os jogadores do mapa antigo ao mudar de mapa

            if (mapId === OPEN_WORLD_ID) {
                player.overworldX = Math.floor(OPEN_WORLD_SIZE / 2);
                player.overworldY = Math.floor(OPEN_WORLD_SIZE / 2);
                cameraX = player.overworldX; 
                cameraY = player.overworldY;
                cameraWidth = Math.floor(canvas.width / TILE_SIZE);
                cameraHeight = Math.floor(canvas.height / TILE_SIZE);
            } else {
                if (GRID_COLS <= 0 || GRID_ROWS <= 0) { 
                    player.overworldX = 0; player.overworldY = 0;
                } else if (entrySide) {
                    switch(entrySide) {
                        case 'left': player.overworldX = GRID_COLS - 2; break;
                        case 'right': player.overworldX = 1; break;
                        case 'up': player.overworldY = GRID_ROWS - 2; break;
                        case 'down': player.overworldY = 1; break;
                        default: 
                            player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                            player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
                            break;
                    }
                    player.overworldX = Math.max(1, Math.min(player.overworldX, GRID_COLS - 2)); 
                    player.overworldY = Math.max(1, Math.min(player.overworldY, GRID_ROWS - 2));
                } else { 
                    player.overworldX = 1; player.overworldY = 1;
                }
            }
            generateMapFor(currentMapId); 
            updateUIBasedOnState();
            updatePlayerOverworldInfo();

            // Multiplayer: Notifica o servidor sobre a mudan√ßa de mapa
            if (socket && localPlayerId && gameInitialized) {
                if (oldMapId && oldMapId !== currentMapId) { 
                    socket.emit('leaveMap', { playerId: localPlayerId, mapId: oldMapId });
                }
                socket.emit('joinMap', {
                    mapId: currentMapId,
                    playerId: localPlayerId,
                    x: player.overworldX,
                    y: player.overworldY,
                    name: player.name,
                    color: player.color 
                });
                // console.log(`Emitindo joinMap: ${currentMapId}, Player: ${localPlayerId}`);
            }
        }

        function resizeCanvas() {
            if (!gameContainer || gameContainer.clientWidth === 0 || gameContainer.clientHeight === 0) {
                canvas.width = canvas.width || 320; 
                canvas.height = canvas.height || 240;
                if (ctx) { 
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(0,0,255,0.5)'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.fillText("Aguardando dimens√µes...", 10, 20);
                }
                return; 
            }
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            GRID_COLS = Math.floor(canvas.width / TILE_SIZE);
            GRID_ROWS = Math.floor(canvas.height / TILE_SIZE);
            GRID_COLS = Math.max(1, GRID_COLS); 
            GRID_ROWS = Math.max(1, GRID_ROWS);

            if (currentMapId === OPEN_WORLD_ID) {
                cameraWidth = Math.floor(canvas.width / TILE_SIZE);
                cameraHeight = Math.floor(canvas.height / TILE_SIZE);
            } else {
                if (GRID_COLS > 0 && GRID_ROWS > 0) {
                    player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                    player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
                    enemies.forEach(enemy => {
                        if (enemy.mapId === currentMapId) { 
                            enemy.overworldX = Math.max(0, Math.min(enemy.overworldX, GRID_COLS - 1));
                            enemy.overworldY = Math.max(0, Math.min(enemy.overworldY, GRID_ROWS - 1));
                        }
                    });
                } else { 
                    player.overworldX = 0; player.overworldY = 0;
                    enemies.forEach(enemy => { enemy.overworldX = 0; enemy.overworldY = 0; });
                }
            }
            if (gameInitialized) {
                 // Don't re-join the map on resize (that teleports the player!)
                 // Just regenerate the in-memory map and update the UI
                 generateMapFor(currentMapId);
                 updateUIBasedOnState();
            }
        }

        // --- L√≥gica de Estados de Jogo e UI ---
        function updateUIBasedOnState() {
            if (gameState === 'overworld') {
                combatUiPanel.style.display = 'none';
                combatHotbarElement.style.display = 'none'; 
                playerInfoOverworldPanel.style.display = 'block';
                statusInfoDisplay.textContent = `Explorando: ${currentMapId === OPEN_WORLD_ID ? 'Mundo Aberto' : currentMapId}`;
                statusInfoDisplay.className = 'text-slate-400';
                selectedAction = null; 
                highlightedTiles = []; 
            } else if (gameState === 'combat') {
                combatUiPanel.style.display = 'block';
                combatHotbarElement.style.display = 'flex'; 
                playerInfoOverworldPanel.style.display = 'none';
                updateTurnInfo(); 
            }
        }
        
        function createHotbarSlots() {
            combatHotbarElement.innerHTML = ''; 
            for (let i = 1; i <= HOTBAR_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.classList.add('hotbar-slot');
                const slotNumber = document.createElement('span');
                slotNumber.classList.add('slot-number');
                slotNumber.textContent = i;
                slot.appendChild(slotNumber);
                slot.addEventListener('click', () => handleHotbarClick(i));
                combatHotbarElement.appendChild(slot);
            }
        }

        function handleHotbarClick(slotNumber) {
            if (gameState !== 'combat' || currentTurn !== 'player' || !player.isAlive) return;
            logGameMessage(`Slot ${slotNumber} da hotbar clicado (sem a√ß√£o ainda).`, 2000);
        }        function initiateCombat(enemyData) {
            activeCombatEnemy = JSON.parse(JSON.stringify(enemyData)); 
            gameState = 'combat';
            logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name}!`, 3000);
            
            // Notify server that combat started with this enemy
            if (socket && localPlayerId) {
                socket.emit('enemyCombatStarted', {
                    enemyId: enemyData.id,
                    mapId: currentMapId,
                    playerId: localPlayerId
                });
            }
            
            player.gridX = (GRID_COLS > 1) ? 1 : 0; 
            player.gridY = GRID_ROWS > 0 ? Math.floor(GRID_ROWS / 2) : 0; 
            player.gridY = Math.max(0, Math.min(player.gridY, GRID_ROWS > 0 ? GRID_ROWS - 1 : 0));

            player.ap = player.maxAp;
            player.mp = player.maxMp;

            activeCombatEnemy.gridX = (GRID_COLS > 2) ? GRID_COLS - 2 : Math.max(0, GRID_COLS -1); 
            activeCombatEnemy.gridY = GRID_ROWS > 0 ? Math.floor(GRID_ROWS / 2) : 0;
            activeCombatEnemy.gridY = Math.max(0, Math.min(activeCombatEnemy.gridY, GRID_ROWS > 0 ? GRID_ROWS - 1 : 0));

            activeCombatEnemy.hp = activeCombatEnemy.combatStats.maxHp; 
            activeCombatEnemy.ap = activeCombatEnemy.combatStats.ap; 
            activeCombatEnemy.mp = activeCombatEnemy.combatStats.mp;
            activeCombatEnemy.isAliveCombat = true; 
            
            updateUIBasedOnState();
            startPlayerTurn();
        }        function endCombat(victory) {
            // Handle multi-enemy combat end
            if (activeCombatEnemies && activeCombatEnemies.length > 0) {
                // Store all enemy data before clearing the combat state
                const allCombatEnemyData = activeCombatEnemies.map(enemy => ({
                    id: enemy.id,
                    combatStats: enemy.combatStats
                }));
                
                // Notify server that combat ended with all enemies
                if (socket && localPlayerId) {
                    allCombatEnemyData.forEach(enemyData => {
                        socket.emit('enemyCombatEnded', {
                            enemyId: enemyData.id,
                            mapId: currentMapId,
                            victory: victory
                        });
                    });
                }
                
                if (victory) {
                    let totalGold = 0;
                    let totalExperience = 0;
                    let defeatedEnemyNames = [];
                    
                    // Process rewards from all defeated enemies
                    allCombatEnemyData.forEach(enemyData => {
                        const loot = enemyData.combatStats.loot || {gold: 0};
                        const experience = enemyData.combatStats.experience || 10;
                        
                        totalGold += loot.gold;
                        totalExperience += experience;
                        defeatedEnemyNames.push(enemyData.combatStats.name);
                        
                        // Mark enemy as dead in overworld
                        const originalEnemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                        const originalEnemy = originalEnemyList.find(e => e.id === enemyData.id);
                        if (originalEnemy) originalEnemy.isAliveOverworld = false;
                    });
                    
                    console.log(`[DEBUG] Multi-enemy victory - ${defeatedEnemyNames.length} enemies defeated`);
                    console.log(`[DEBUG] Total gold reward: ${totalGold}, Total experience: ${totalExperience}`);
                    console.log(`[DEBUG] Player gold before: ${player.gold}`);
                    
                    // Award total rewards
                    player.gold += totalGold;
                    player.hp = player.maxHp;
                    
                    // Display victory message
                    if (defeatedEnemyNames.length > 1) {
                        logGameMessage(`Voc√™ derrotou ${defeatedEnemyNames.join(', ')}! Recebeu ${totalGold}g e ${totalExperience} XP.`, 4000);
                    } else {
                        logGameMessage(`Voc√™ derrotou ${defeatedEnemyNames[0]}! Recebeu ${totalGold}g e ${totalExperience} XP.`, 3000);
                    }
                    
                    console.log(`[DEBUG] Player gold after: ${player.gold}`);
                    
                    // Handle experience and level up
                    const oldLevel = player.level;
                    player.experience += totalExperience;
                    
                    if (player.experience >= player.experienceToNext) {
                        const newLevel = player.level + 1;
                        player.level = newLevel;
                        player.experience = 0;
                        player.experienceToNext = Math.floor(player.experienceToNext * 1.5);
                        player.skillPoints += 2;
                        logGameMessage(`üéâ Level Up! You are now level ${newLevel}!`, 4000);
                    }                    // Trigger auto-save for each defeated enemy in multi-enemy combat
                    allCombatEnemyData.forEach(enemyData => {
                        const damageDealt = player.attackPower || 10;
                        triggerCombatVictorySave(enemyData, damageDealt);
                        
                        // Notify server that this enemy was defeated
                        if (socket && localPlayerId) {
                            socket.emit('enemyDefeated', {
                                enemyId: enemyData.id,
                                mapId: currentMapId,
                                playerData: {
                                    damageDealt: damageDealt,
                                    gold: player.gold,
                                    experience: player.experience,
                                    level: player.level
                                }
                            });
                        }
                    });
                }
                
                // Clear multi-enemy combat state
                activeCombatEnemies = [];
                currentEnemyTurnIndex = 0;
            } else {
                // Handle single enemy combat (fallback)
                const combatEnemyData = activeCombatEnemy ? {
                    id: activeCombatEnemy.id,
                    combatStats: activeCombatEnemy.combatStats
                } : null;
                
                // Notify server that combat ended with this enemy
                if (socket && localPlayerId && combatEnemyData) {
                    socket.emit('enemyCombatEnded', {
                        enemyId: combatEnemyData.id,
                        mapId: currentMapId,
                        victory: victory
                    });
                }
                
                if (victory && combatEnemyData) {
                    const loot = combatEnemyData.combatStats.loot || {gold: 0};
                    console.log(`[DEBUG] Enemy defeated:`, combatEnemyData.combatStats.name);
                    console.log(`[DEBUG] Enemy loot data:`, loot);
                    console.log(`[DEBUG] Player gold before:`, player.gold);
                    logGameMessage(`Voc√™ derrotou ${combatEnemyData.combatStats.name}! Recebeu ${loot.gold}g.`, 3000);
                    player.gold += loot.gold;
                    console.log(`[DEBUG] Player gold after:`, player.gold);
                      // Trigger auto-save for combat victory - ONLY SAVE TRIGGER
                    const damageDealt = player.attackPower || 10;
                    triggerCombatVictorySave(combatEnemyData, damageDealt);
                    
                    // Notify server that this enemy was defeated
                    if (socket && localPlayerId) {
                        socket.emit('enemyDefeated', {
                            enemyId: combatEnemyData.id,
                            mapId: currentMapId,
                            playerData: {
                                damageDealt: damageDealt,
                                gold: player.gold,
                                experience: player.experience,
                                level: player.level
                            }
                        });
                    }

                    // Mark enemy as dead in overworld
                    const originalEnemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                    const originalEnemy = originalEnemyList.find(e => e.id === combatEnemyData.id);
                    if(originalEnemy) originalEnemy.isAliveOverworld = false; 
                    
                    player.hp = player.maxHp; 
                    
                    // Check for experience gain and level up
                    const experienceGained = combatEnemyData.combatStats.experience || 10;
                    const oldLevel = player.level;
                    player.experience += experienceGained;
                    
                    if (player.experience >= player.experienceToNext) {
                        const newLevel = player.level + 1;
                        player.level = newLevel;
                        player.experience = 0;
                        player.experienceToNext = Math.floor(player.experienceToNext * 1.5);
                        player.skillPoints += 2;
                        logGameMessage(`üéâ Level Up! You are now level ${newLevel}!`, 4000);
                    }
                }
            }
            
            // Reset combat state
            activeCombatEnemy = null;
            gameState = 'overworld';
            updateUIBasedOnState();
            updatePlayerOverworldInfo();
        }


        // --- L√≥gica de Turnos (Combate) ---
        function startPlayerTurn() {
            currentTurn = 'player';
            selectedAction = null;
            highlightedTiles = [];
            updatePlayerCombatInfo();
            updateTurnInfo();
            enableActionButtons(true);
        }

        function endPlayerTurn() {
            if (currentTurn !== 'player' || gameState !== 'combat' || !player.isAlive) return; 
            selectedAction = null;
            highlightedTiles = [];
            enableActionButtons(false);
            setTimeout(startEnemyTurn, 500); 
        }        function startEnemyTurn() {
            // Check if combat should end
            if (gameState !== 'combat' || !player.isAlive) {
                if (!player.isAlive) {
                    endCombat(false); 
                } else {
                    gameState = 'overworld'; 
                }
                return;
            }

            // Check if all enemies are defeated
            const aliveEnemies = activeCombatEnemies && activeCombatEnemies.length > 0 ? 
                activeCombatEnemies.filter(enemy => enemy && enemy.hp > 0) :
                (activeCombatEnemy && activeCombatEnemy.hp > 0 ? [activeCombatEnemy] : []);
                
            if (aliveEnemies.length === 0) {
                endCombat(true);
                return;
            }

            currentTurn = 'enemy';
            
            // Multi-enemy turn system
            if (activeCombatEnemies && activeCombatEnemies.length > 0) {
                processMultiEnemyTurns(aliveEnemies);
            } else if (activeCombatEnemy && activeCombatEnemy.hp > 0) {
                // Fallback for single enemy combat
                processSingleEnemyTurn(activeCombatEnemy);
            }
        }

        function processMultiEnemyTurns(aliveEnemies) {
            let enemyIndex = 0;
            
            function processNextEnemyTurn() {
                if (enemyIndex >= aliveEnemies.length) {
                    // All enemies have taken their turns, start player turn
                    player.ap = player.maxAp; 
                    player.mp = player.maxMp;
                    setTimeout(startPlayerTurn, 1000);
                    return;
                }
                
                const enemy = aliveEnemies[enemyIndex];
                if (enemy && enemy.hp > 0) {
                    updateTurnInfo(enemy.combatStats.name);
                    processSingleEnemyTurn(enemy, () => {
                        enemyIndex++;
                        setTimeout(processNextEnemyTurn, 800); // Small delay between enemy turns
                    });
                } else {
                    enemyIndex++;
                    setTimeout(processNextEnemyTurn, 100);
                }
            }
            
            processNextEnemyTurn();
        }

        function processSingleEnemyTurn(enemy, callback = null) {
            if (!enemy || enemy.hp <= 0 || !player.isAlive) {
                if (callback) callback();
                return;
            }

            enemy.ap = enemy.combatStats.maxAp; 
            enemy.mp = enemy.combatStats.maxMp; 

            let actionTakenThisTurn = false; 
            const distToPlayer = getGridDistance(enemy.gridX, enemy.gridY, player.gridX, player.gridY);

            // Attack if in range
            if (distToPlayer <= enemy.combatStats.attackRange && enemy.ap > 0) {
                player.hp -= enemy.combatStats.attackPower;
                enemy.ap--; 
                actionTakenThisTurn = true;
                if (player.hp <= 0) { 
                    player.hp = 0; 
                    player.isAlive = false; 
                }
                logGameMessage(`${enemy.combatStats.name} ataca ${player.name} causando ${enemy.combatStats.attackPower} de dano! HP Jogador: ${player.hp}`, 2500);
                updatePlayerOverworldInfo(); 
                if (!player.isAlive) {
                    logGameMessage(`${player.name} foi derrotado!`, 4000);
                    setTimeout(() => endCombat(false), 1500);
                    return; 
                }
            }
            
            // Move towards player if not in attack range
            if (!actionTakenThisTurn && enemy.mp > 0 && distToPlayer > 0) { 
                let bestMove = {x: enemy.gridX, y: enemy.gridY};
                let currentMinDistanceToPlayer = distToPlayer;
                let foundValidMove = false;
                
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue; 
                        const newX = enemy.gridX + dx;
                        const newY = enemy.gridY + dy;
                        if (isValidCombatTile(newX, newY) && !isCombatTileOccupied(newX, newY, enemy)) {
                            const distanceToPlayerFromNewPos = getGridDistance(newX, newY, player.gridX, player.gridY);
                            if (distanceToPlayerFromNewPos < currentMinDistanceToPlayer) {
                                currentMinDistanceToPlayer = distanceToPlayerFromNewPos;
                                bestMove = {x: newX, y: newY};
                                foundValidMove = true;
                            }
                        }
                    }
                }
                
                if(foundValidMove){ 
                    enemy.gridX = bestMove.x;
                    enemy.gridY = bestMove.y;
                    enemy.mp--;
                    actionTakenThisTurn = true; 
                    logGameMessage(`${enemy.combatStats.name} moveu-se.`, 1500);
                }
            }
            
            // Continue to next turn
            if (callback) {
                callback();
            } else {
                // Single enemy mode - restore player and start player turn
                player.ap = player.maxAp; 
                player.mp = player.maxMp;
                setTimeout(startPlayerTurn, 1000); 
            }
        }
          function isCombatTileOccupied(gridX, gridY, selfEntity = null) {
            // Check player position
            if (player.isAlive && player.gridX === gridX && player.gridY === gridY && player !== selfEntity) return true;
              // Check all enemies in multi-enemy combat
            if (activeCombatEnemies && activeCombatEnemies.length > 0) {
                for (const enemy of activeCombatEnemies) {
                    if (enemy && enemy.hp > 0 && enemy.gridX === gridX && enemy.gridY === gridY && enemy !== selfEntity) {
                        return true;
                    }
                }
            }
            
            return false;
        }        // Player movement function
        function movePlayer(dx, dy) {
            try {
                if (!player.isAlive || gameState !== 'overworld') return;
                
                // Store previous position for multiplayer sync
                const prevPlayerX = player.overworldX;
                const prevPlayerY = player.overworldY;
                
                if (currentMapId === OPEN_WORLD_ID) { // Open World
                    const newX = player.overworldX + dx;
                    const newY = player.overworldY + dy;
                    
                    if (!isValidOpenWorldTile(newX, newY)) return;
                    
                    // Check collision with enemies
                    for (const enemy of openWorldEnemies) {
                        if (enemy.isAliveOverworld && enemy.overworldX === newX && enemy.overworldY === newY) {
                            initiateOpenWorldCombat(enemy);
                            return;
                        }
                    }
                    
                    // Multiplayer: Check collision with other players in open world - TRIGGER PARTY INVITATION
                    for (const pId in otherPlayers) {
                        if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === newX && otherPlayers[pId].y === newY) {
                            triggerPartyInvitation(otherPlayers[pId], pId);
                            return; // Block movement but trigger party invitation
                        }
                    }
                    
                    // Check terrain collision
                    if (openWorldMap && openWorldMap[newY] && openWorldMap[newY][newX] !== MAP_TILES.OBSTACLE_ROCK) {
                        player.overworldX = newX;
                        player.overworldY = newY;
                        cameraX = player.overworldX;
                        cameraY = player.overworldY;
                    }
                } else { // Regular maps
                    const newOverworldX = player.overworldX + dx;
                    const newOverworldY = player.overworldY + dy;
                    const connections = mapConnections[currentMapId] || {};
                    
                    // Check map transitions
                    if (newOverworldX >= GRID_COLS && connections.right) { loadMap(connections.right, 'right'); return; }
                    if (newOverworldX < 0 && connections.left) { loadMap(connections.left, 'left'); return; }
                    if (newOverworldY >= GRID_ROWS && connections.down) { loadMap(connections.down, 'down'); return; }
                    if (newOverworldY < 0 && connections.up) { loadMap(connections.up, 'up'); return; }
                    if (!isValidOverworldTile(newOverworldX, newOverworldY)) return; 
                    
                    // Check collision with enemies
                    for (const enemy of enemies) {
                        if (enemy.isAliveOverworld && enemy.mapId === currentMapId && enemy.overworldX === newOverworldX && enemy.overworldY === newOverworldY) {
                            initiateCombat(enemy);
                            return; 
                        }
                    }
                      // Multiplayer: Check collision with other players in regular maps - TRIGGER PARTY INVITATION
                    for (const pId in otherPlayers) {
                        if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === newOverworldX && otherPlayers[pId].y === newOverworldY) {
                            triggerPartyInvitation(otherPlayers[pId], pId);
                            return; // Block movement but trigger party invitation
                        }
                    }
                    
                    // Check terrain collision
                    if (mapData && mapData.length > newOverworldY && mapData[newOverworldY] && mapData[newOverworldY].length > newOverworldX && mapData[newOverworldY][newOverworldX] !== MAP_TILES.OBSTACLE_ROCK) {
                        player.overworldX = newOverworldX;
                        player.overworldY = newOverworldY;
                    }
                }
                
                // Multiplayer: Emit movement if position changed
                if ((player.overworldX !== prevPlayerX || player.overworldY !== prevPlayerY) && socket && localPlayerId) {
                    socket.emit('playerMoved', {
                        playerId: localPlayerId,
                        mapId: currentMapId,
                        x: player.overworldX,
                        y: player.overworldY
                    });
                }
            } catch (error) {
                console.error('‚ùå Error in movePlayer:', error);
            }
        }

        // --- Open World Camera/Tile helpers ---
        function isValidOpenWorldTile(x, y) {
            return x >= 0 && x < OPEN_WORLD_SIZE && y >= 0 && y < OPEN_WORLD_SIZE;
        }        function initiateOpenWorldCombat(enemyData) {
            // Find nearby enemies within 3 tiles of the primary enemy
            const nearbyEnemies = findNearbyEnemies(enemyData, 3);
            const allCombatEnemies = [enemyData, ...nearbyEnemies];
            
            // Limit to maximum 4 enemies total for balanced combat
            const maxEnemies = 4;
            if (allCombatEnemies.length > maxEnemies) {
                allCombatEnemies.splice(maxEnemies);
            }
            
            // Set up primary enemy
            activeCombatEnemy = JSON.parse(JSON.stringify(allCombatEnemies[0]));
            activeCombatEnemies = allCombatEnemies.map(enemy => JSON.parse(JSON.stringify(enemy)));
            
            gameState = 'combat';
            
            if (allCombatEnemies.length > 1) {
                logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name} e ${allCombatEnemies.length - 1} aliados!`, 3000);
            } else {
                logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name}!`, 3000);
            }
            
            // Notify server about all enemies entering combat
            if (socket && localPlayerId) {
                allCombatEnemies.forEach(enemy => {
                    socket.emit('enemyCombatStarted', {
                        enemyId: enemy.id,
                        mapId: currentMapId,
                        playerId: localPlayerId
                    });
                });
            }
            
            // Position player
            player.gridX = 1;
            player.gridY = Math.floor(GRID_ROWS / 2);
            player.ap = player.maxAp;
            player.mp = player.maxMp;
            
            // Position all enemies in combat grid
            positionEnemiesInCombat(activeCombatEnemies);
            
            updateUIBasedOnState();
            startPlayerTurn();
        }

        // --- Multi-Enemy Combat System ---
        let activeCombatEnemies = []; // Array to store all enemies in current combat
        let currentEnemyTurnIndex = 0; // Track which enemy's turn it is

        function findNearbyEnemies(primaryEnemy, maxDistance) {
            const nearbyEnemies = [];
            
            openWorldEnemies.forEach(enemy => {
                // Skip the primary enemy and dead enemies



                if (enemy.id !== primaryEnemy.id && enemy.isAliveOverworld) {
                    const distance = getGridDistance(
                        primaryEnemy.overworldX, 
                        primaryEnemy.overworldY,
                        enemy.overworldX, 
                        enemy.overworldY
                    );
                    
                    if (distance <= maxDistance) {
                        nearbyEnemies.push(enemy);
                    }
                }
            });
            
            // Sort by distance (closest first)
            nearbyEnemies.sort((a, b) => {
                const distA = getGridDistance(primaryEnemy.overworldX, primaryEnemy.overworldY, a.overworldX, a.overworldY);
                const distB = getGridDistance(primaryEnemy.overworldX, primaryEnemy.overworldY, b.overworldX, b.overworldY);
                return distA - distB;
            });
            
            return nearbyEnemies;
        }

        function positionEnemiesInCombat(enemies) {
            const rightSide = GRID_COLS - 2; // Right side of combat grid
            const centerY = Math.floor(GRID_ROWS / 2);
            
            enemies.forEach((enemy, index) => {
                const combatEnemy = activeCombatEnemies[index];
                
                // Position enemies in a formation on the right side
                if (index === 0) {
                    // Primary enemy in center
                    combatEnemy.gridX = rightSide;
                    combatEnemy.gridY = centerY;
                } else if (index === 1) {
                    // Second enemy above primary
                    combatEnemy.gridX = rightSide;
                    combatEnemy.gridY = Math.max(0, centerY - 1);
                } else if (index === 2) {
                    // Third enemy below primary
                    combatEnemy.gridX = rightSide;
                    combatEnemy.gridY = Math.min(GRID_ROWS - 1, centerY + 1);
                } else if (index === 3) {
                    // Fourth enemy behind others
                    combatEnemy.gridX = Math.max(0, rightSide - 1);
                    combatEnemy.gridY = centerY;
                }
                
                // Initialize combat stats
                combatEnemy.hp = combatEnemy.combatStats.maxHp;
                combatEnemy.ap = combatEnemy.combatStats.ap; 
                combatEnemy.mp = combatEnemy.combatStats.mp;
                combatEnemy.isAliveCombat = true;
            });
        }

        function handleCombatKeyDown(e) {
            switch (e.key.toLowerCase()) {
                case '1': e.preventDefault(); setSelectedAction('move'); break;
                case '2': e.preventDefault(); setSelectedAction('attack'); break;
                case ' ': e.preventDefault(); endPlayerTurn(); break;
                case 'w': case 'arrowup':
                case 's': case 'arrowdown':
                case 'a': case 'arrowleft':
                case 'd': case 'arrowright':
                    if (selectedAction === 'move') {
                        e.preventDefault();
                        let dx = 0, dy = 0;
                        if (e.key === 'w' || e.key === 'arrowup') dy = -1;
                        if (e.key === 's' || e.key === 'arrowdown') dy = 1;
                        if (e.key === 'a' || e.key === 'arrowleft') dx = -1;
                        if (e.key === 'd' || e.key === 'arrowright') dx = 1;
                        handleMoveActionCombat(player.gridX + dx, player.gridY + dy);
                    }
                    break;
            }
        }

        function setSelectedAction(action) {
            if (currentTurn !== 'player' || !player.isAlive || gameState !== 'combat') return;
            if (selectedAction === action) selectedAction = null; 
            else selectedAction = action;
            updateHighlightedTiles();
            moveButton.classList.toggle('selected-action', selectedAction === 'move');
            attackButton.classList.toggle('selected-action', selectedAction === 'attack');
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const gridX = Math.floor((event.clientX - rect.left) / TILE_SIZE);
            const gridY = Math.floor((event.clientY - rect.top) / TILE_SIZE);

            if (gameState === 'overworld') {
                if (!isValidOverworldTile(gridX, gridY)) return; 
                const targetEnemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                for (const enemy of targetEnemyList) {
                    if (enemy.isAliveOverworld && 
                        ((currentMapId !== OPEN_WORLD_ID && enemy.mapId === currentMapId) || currentMapId === OPEN_WORLD_ID) &&
                        enemy.overworldX === gridX && enemy.overworldY === gridY) {
                        if (currentMapId === OPEN_WORLD_ID) initiateOpenWorldCombat(enemy);
                        else initiateCombat(enemy); 
                        return;
                    }
                }
            } else if (gameState === 'combat') {
                if (currentTurn !== 'player' || !player.isAlive || !selectedAction) return;
                if (!isValidCombatTile(gridX, gridY)) return;
                if (selectedAction === 'move') handleMoveActionCombat(gridX, gridY);
                else if (selectedAction === 'attack') handleAttackActionCombat(gridX, gridY);            } else if (gameState === 'overworld' && player.isAlive) {
                // Overworld clicking is now only for general interactions
                // Party invitations are now handled by bumping into players
            }
        }

        function handleMoveActionCombat(targetGridX, targetGridY) {
            const distance = getGridDistance(player.gridX, player.gridY, targetGridX, targetGridY);
            if (player.mp >= distance && distance > 0 && !isCombatTileOccupied(targetGridX, targetGridY)) {
                player.gridX = targetGridX;
                player.gridY = targetGridY;
                player.mp -= distance; 
                if (player.mp <= 0) selectedAction = null; 
                updatePlayerCombatInfo();
                updateHighlightedTiles();
            }
        }        function handleAttackActionCombat(targetGridX, targetGridY) {
            // Find which enemy is at the target position
            let targetEnemy = null;
            
            // Check in multi-enemy combat first
            if (activeCombatEnemies && activeCombatEnemies.length > 0) {
                targetEnemy = activeCombatEnemies.find(enemy => 
                    enemy && enemy.hp > 0 && enemy.gridX === targetGridX && enemy.gridY === targetGridY
                );
            } else if (activeCombatEnemy && activeCombatEnemy.hp > 0 && 
                      activeCombatEnemy.gridX === targetGridX && activeCombatEnemy.gridY === targetGridY) {
                // Fallback for single enemy combat
                targetEnemy = activeCombatEnemy;
            }
            
            if (targetEnemy) {
                const distance = getGridDistance(player.gridX, player.gridY, targetGridX, targetGridY);
                if (distance <= player.attackRange && player.ap > 0) { 
                    targetEnemy.hp -= player.attackPower;
                    player.ap--;
                    logGameMessage(`Atacou ${targetEnemy.combatStats.name}! Dano: ${player.attackPower}.`, 2000);
                    
                    if (targetEnemy.hp <= 0) {
                        targetEnemy.hp = 0;
                        logGameMessage(`${targetEnemy.combatStats.name} foi derrotado!`, 2000);
                        
                        // Check if all enemies are defeated
                        const aliveEnemies = activeCombatEnemies ? 
                            activeCombatEnemies.filter(enemy => enemy && enemy.hp > 0) : 
                            (activeCombatEnemy && activeCombatEnemy.hp > 0 ? [activeCombatEnemy] : []);
                        
                        if (aliveEnemies.length === 0) {
                            setTimeout(() => endCombat(true), 1000); 
                        }
                    }
                    
                    if (player.ap <= 0) selectedAction = null; 
                    updatePlayerCombatInfo();
                    updateHighlightedTiles();
                } else {
                    logGameMessage("Fora de alcance ou sem AP!", 1500);
                }
            } else {
                logGameMessage("Nenhum inimigo nesta posi√ß√£o!", 1500);
            }
        }
        
        function updateHighlightedTiles() { 
            highlightedTiles = [];
            if (!selectedAction || gameState !== 'combat' || !player.isAlive) return; 
            const range = (selectedAction === 'move') ? player.mp : player.attackRange;
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const dist = getGridDistance(player.gridX, player.gridY, c, r);
                    if (dist > 0 && dist <= range) {
                        if (selectedAction === 'move' && !isCombatTileOccupied(c,r)) highlightedTiles.push({ x: c, y: r, type: 'move' });
                        else if (selectedAction === 'attack') highlightedTiles.push({ x: c, y: r, type: 'attack' });
                    }
                }
            }
        }
        
        function updateOverworldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld' || !player.isAlive) return;
            lastAiUpdateTime = now;

            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);

                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) { 
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        
                        let movedThisTick = false;

                        if (dx !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX + dx;
                            let nextY = enemy.overworldY; 

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true; 
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEnemy = false;
                                for ( const otherEnemy of enemies) {
                                    if (otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                for (const pId in otherPlayers) {
                                     if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEnemy) {
                                    enemy.overworldX = nextX;
                                    movedThisTick = true;
                                }
                            }
                        }

                        if (dy !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX; 
                            let nextY = enemy.overworldY + dy;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEnemy = false;
                                for (const otherEnemy of enemies) {
                                    if ( otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                for (const pId in otherPlayers) {
                                     if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEnemy) {
                                    enemy.overworldY = nextY;
                                    movedThisTick = true;
                                }
                            }
                        }
                    }
                }
            });        }        // --- Desenho ---
        function gameLoop() {
            if (!ctx) {
                return; 
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (gameState === 'overworld') {
                if (currentMapId === OPEN_WORLD_ID) {
                    // Server handles monster AI now - removed updateOpenWorldAI()
                    drawOpenWorld();
                } else {
                    // Server handles monster AI now - removed updateOverworldAI()
                    drawOverworld();
                }            } else if (gameState === 'combat') {
                drawCombat();
            }
            
            // Draw floating messages (for party invitations, etc.)
            drawFloatingMessages();
            
            // Draw minimap overlay
            drawMinimap();
            
            requestAnimationFrame(gameLoop);
        }

        // Client-side AI functions removed - now handled server-side
        /*
        function updateOpenWorldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld' || !player.isAlive) return;
            lastAiUpdateTime = now;

            openWorldEnemies.forEach(enemy => {
                if (enemy.isAliveOverworld) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);

                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) {
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        let movedThisTick = false;

                        if (dx !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX + dx;
                            let nextY = enemy.overworldY;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateOpenWorldCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOpenWorldTile(nextX, nextY) && openWorldMap[nextY] && openWorldMap[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOther = false;
                                for (const otherE of openWorldEnemies) { if (otherE !== enemy && otherE.isAliveOverworld && otherE.overworldX === nextX && otherE.overworldY === nextY) { isOccupiedByOther = true; break; } }
                                if (!isOccupiedByOther) {
                                     for (const pId in otherPlayers) { if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) { isOccupiedByOther = true; break;}}
                                }
                                if (!isOccupiedByOther) {
                                    enemy.overworldX = nextX;
                                    movedThisTick = true;
                                }
                            }
                        }

                        if (dy !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX; 
                            let nextY = enemy.overworldY + dy;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateOpenWorldCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOpenWorldTile(nextX, nextY) && openWorldMap[nextY] && openWorldMap[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOther = false;
                                for (const otherE of openWorldEnemies) { if (otherE !== enemy && otherE.isAliveOverworld && otherE.overworldX === nextX && otherE.overworldY === nextY) { isOccupiedByOther = true; break; } }
                                if (!isOccupiedByOther) {
                                     for (const pId in otherPlayers) { if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) { isOccupiedByOther = true; break;}}
                                }
                                if (!isOccupiedByOther) {
                                    enemy.overworldY = nextY;
                                    movedThisTick = true;
                                }
                            }
                        }
                    }
                }
            });
        }

        function updateOverworldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld' || !player.isAlive) return;
            lastAiUpdateTime = now;

            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);

                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) { 
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        
                        let movedThisTick = false;

                        if (dx !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX + dx;
                            let nextY = enemy.overworldY; 

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true; 
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEnemy = false;
                                for ( const otherEnemy of enemies) {
                                    if (otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                for (const pId in otherPlayers) {
                                     if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEnemy) {
                                    enemy.overworldX = nextX;
                                    movedThisTick = true;
                                }
                            }
                        }

                        if (dy !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX; 
                            let nextY = enemy.overworldY + dy;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEnemy = false;
                                for (const otherEnemy of enemies) {
                                    if ( otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                for (const pId in otherPlayers) {
                                     if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                        isOccupiedByOtherEnemy = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEnemy) {
                                    enemy.overworldY = nextY;
                                    movedThisTick = true;
                                }
                            }
                        }
                    }
                }
            });        }
        */

        function drawOpenWorld() {
            let halfW = Math.floor(cameraWidth / 2);
            let halfH = Math.floor(cameraHeight / 2);
            let camLeft = Math.max(0, Math.min(player.overworldX - halfW, OPEN_WORLD_SIZE - cameraWidth));
            let camTop = Math.max(0, Math.min(player.overworldY - halfH, OPEN_WORLD_SIZE - cameraHeight));

            for (let r = 0; r < cameraHeight; r++) {
                for (let c = 0; c < cameraWidth; c++) {
                    let mapY = camTop + r;
                    let mapX = camLeft + c;
                    if (!isValidOpenWorldTile(mapX, mapY) || !openWorldMap || !openWorldMap[mapY]) continue; // Check if openWorldMap and row exist

                    const tileType = openWorldMap[mapY][mapX];
                    const x = c * TILE_SIZE, y = r * TILE_SIZE;
                    switch (tileType) {
                        case MAP_TILES.OBSTACLE_ROCK: ctx.fillStyle = '#848b98'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case MAP_TILES.DECORATION_TREE:
                            ctx.fillStyle = '#225336'; ctx.fillRect(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.5, TILE_SIZE * 0.6, TILE_SIZE * 0.5); 
                            ctx.fillStyle = '#38a169'; ctx.beginPath(); ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE * 0.35, TILE_SIZE * 0.35, 0, Math.PI * 2); ctx.fill(); 
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            ctx.fillStyle = '#48bb78'; ctx.beginPath();
                            ctx.arc(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.7, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5, TILE_SIZE * 0.25, 0, Math.PI * 2); ctx.fill();
                            break;
                    }
                }
            }            openWorldEnemies.forEach(enemy => {
                if (enemy.isAliveOverworld) {
                    // Hide enemy if it's in combat with another player
                    if (enemy.inCombat && enemy.combatPlayerId && enemy.combatPlayerId !== localPlayerId) {
                        return; // Skip drawing this enemy
                    }
                    
                    let relX = enemy.overworldX - camLeft;
                    let relY = enemy.overworldY - camTop;
                    if (relX >= 0 && relX < cameraWidth && relY >= 0 && relY < cameraHeight) {
                        drawOverworldEntity(relX, relY, enemy.combatStats.color, enemy.combatStats.size, enemy.combatStats.name, true);
                    }
                }
            });
            // Multiplayer: Desenhar outros jogadores no mundo aberto
            for (const playerId in otherPlayers) {
                const p = otherPlayers[playerId];
                if (p.mapId === OPEN_WORLD_ID) {
                    let relX = p.x - camLeft;
                    let relY = p.y - camTop;
                    if (relX >= 0 && relX < cameraWidth && relY >= 0 && relY < cameraHeight) {
                        drawOverworldEntity(relX, relY, p.color, TILE_SIZE * 0.8, p.name);
                    }
                }
            }
            let relPX = player.overworldX - camLeft;
            let relPY = player.overworldY - camTop;
            if (relPX >= 0 && relPX < cameraWidth && relPY >= 0 && relPY < cameraHeight) {
                drawOverworldEntity(relPX, relPY, player.color, player.size, player.name);
            }
        }

        function drawOverworldEntity(gridX, gridY, color, size, name = null, isEnemy = false) {
            const pixelX = gridX * TILE_SIZE + (TILE_SIZE - size) / 2;
            const pixelY = gridY * TILE_SIZE + (TILE_SIZE - size) / 2;
            ctx.fillStyle = color;
            ctx.fillRect(pixelX, pixelY, size, size);

            if (name) {
                ctx.fillStyle = isEnemy ? '#fca5a5' : '#93c5fd'; // Cor diferente para nome de inimigo e jogador
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(name, pixelX + size / 2, pixelY - 5);
            }
        }

        function drawOverworld() {
            drawGrid(); 
            drawMapElements();            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    // Hide enemy if it's in combat with another player
                    if (enemy.inCombat && enemy.combatPlayerId && enemy.combatPlayerId !== localPlayerId) {
                        return; // Skip drawing this enemy
                    }
                    
                    drawOverworldEntity(enemy.overworldX, enemy.overworldY, enemy.combatStats.color, enemy.combatStats.size, enemy.combatStats.name, true); 
                }
            });
            // Multiplayer: Desenhar outros jogadores em mapas normais
            for (const playerId in otherPlayers) {
                const p = otherPlayers[playerId];
                if (p.mapId === currentMapId && p.playerId !== localPlayerId) { // Garante que n√£o desenhe o jogador local como "outro"
                    drawOverworldEntity(p.x, p.y, p.color, TILE_SIZE * 0.8, p.name);
                }
            }
            if (player.isAlive) drawOverworldEntity(player.overworldX, player.overworldY, player.color, player.size, player.name);
        }
        
        function drawMapElements() {
            if (!mapData || mapData.length === 0 || GRID_ROWS === 0 || GRID_COLS === 0) {
                return;
            }
            for (let r = 0; r < GRID_ROWS; r++) {
                if (!mapData[r]) continue; 
                for (let c = 0; c < GRID_COLS; c++) {
                    const tileType = mapData[r][c];
                    const x = c * TILE_SIZE, y = r * TILE_SIZE;
                    switch ( tileType) {
                        case MAP_TILES.OBSTACLE_ROCK: ctx.fillStyle = '#848b98'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case MAP_TILES.DECORATION_TREE:
                            ctx.fillStyle = '#225336'; ctx.fillRect(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.5, TILE_SIZE * 0.6, TILE_SIZE * 0.5); 
                            ctx.fillStyle = '#38a169'; ctx.beginPath(); ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE * 0.35, TILE_SIZE * 0.35, 0, Math.PI * 2); ctx.fill(); 
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            ctx.fillStyle = '#48bb78'; ctx.beginPath();
                            ctx.arc(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.7, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5, TILE_SIZE * 0.25, 0, Math.PI * 2); ctx.fill();
                            break;                    }
                }
            }
        }

        // drawOverworldEntity j√° foi definida e modificada para incluir nome e flag 'isEnemy'
        function drawCombat() {
            drawGrid();
            drawHighlightedTiles();
            
            // Draw all enemies in multi-enemy combat
            if (activeCombatEnemies && activeCombatEnemies.length > 0) {
                activeCombatEnemies.forEach(enemy => {
                    if (enemy && enemy.hp > 0) {
                        drawCombatCharacter(enemy, true);
                    }
                });
            } else if (activeCombatEnemy && activeCombatEnemy.hp > 0) {
                // Fallback for single enemy combat
                drawCombatCharacter(activeCombatEnemy, true);
            }
            
            if (player.isAlive) drawCombatCharacter(player, false);
        }

        function drawGrid() { 
            if (GRID_COLS <=0 || GRID_ROWS <=0) return; 
            ctx.strokeStyle = '#4a5568'; ctx.lineWidth = 0.5; 
            for (let c = 0; c < GRID_COLS; c++) for (let r = 0; r < GRID_ROWS; r++) ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
        
        function drawHighlightedTiles() { highlightedTiles.forEach(tile => { ctx.fillStyle = tile.type === 'move' ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 0, 0, 0.2)'; ctx.fillRect(tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE); }); }

        function drawCombatCharacter(charData, isEnemy) {
            const entity = isEnemy ? charData : player;
            const combatStats = isEnemy ? entity.combatStats : player; 
            const displayColor = isEnemy ? (entity.colorFlash || combatStats.color) : player.color;
            const displaySize = combatStats.size;

            const pixelX = entity.gridX * TILE_SIZE + (TILE_SIZE - displaySize) / 2;
            const pixelY = entity.gridY * TILE_SIZE + (TILE_SIZE - displaySize) / 2;
            ctx.fillStyle = displayColor;
            ctx.fillRect(pixelX, pixelY, displaySize, displaySize);
            const hp = entity.hp, maxHp = combatStats.maxHp;
            const hpBarWidth = displaySize, hpBarHeight = 6, hpBarX = pixelX, hpBarY = pixelY - hpBarHeight - 3, hpRatio = maxHp > 0 ? hp / maxHp : 0;
            ctx.fillStyle = '#4b5563'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
            ctx.fillStyle = isEnemy ? 'red' : 'limegreen'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpRatio, hpBarHeight);
            // Multiplayer: Desenhar nome do personagem em combate
            if (combatStats.name) {
                ctx.fillStyle = isEnemy ? '#fca5a5' : '#93c5fd';
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(combatStats.name, pixelX + displaySize / 2, hpBarY - 3);
            }
        }

        // --- Utilit√°rios ---
        function isValidOverworldTile(gridX, gridY) { return gridX >= 0 && gridX < GRID_COLS && gridY >= 0 && gridY < GRID_ROWS; }
        function isValidCombatTile(gridX, gridY) { return gridX >= 0 && gridX < GRID_COLS && gridY >= 0 && gridY < GRID_ROWS; }
        function getGridDistance(x1, y1, x2, y2) { return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2)); } 
        function logGameMessage(message, duration = 3000) { gameLogMessage.textContent = message; gameLogMessage.classList.remove('hidden'); if (gameLogMessage.timeoutId) clearTimeout(gameLogMessage.timeoutId); gameLogMessage.timeoutId = setTimeout(() => gameLogMessage.classList.add('hidden'), duration); }
        function updatePlayerOverworldInfo() { playerNameOverworldDisplay.textContent = player.name; playerHPOverworldDisplay.textContent = `${player.hp}/${player.maxHp}`; playerGoldOverworldDisplay.textContent = player.gold; }
        function updatePlayerCombatInfo() { playerAPCombatDisplay.textContent = `${player.ap}/${player.maxAp}`; playerMPCombatDisplay.textContent = `${player.mp}/${player.maxMp}`; }
        function updateTurnInfo(enemyName = null) { 
            if (gameState === 'combat') { 
                if (currentTurn === 'player') {
                    statusInfoDisplay.textContent = "Seu Turno!";
                    statusInfoDisplay.className = 'text-green-400 font-semibold';
                } else {
                    // Use provided enemy name, or fall back to activeCombatEnemy name, or default to 'Inimigo'
                    const displayName = enemyName || (activeCombatEnemy ? activeCombatEnemy.combatStats.name : 'Inimigo');
                    statusInfoDisplay.textContent = `Turno de ${displayName}...`;
                    statusInfoDisplay.className = 'text-red-400 font-semibold';
                }
            } 
        }
        function enableActionButtons(enabled) { moveButton.disabled = !enabled; attackButton.disabled = !enabled; endTurnButton.disabled = !enabled; if (!enabled) { moveButton.classList.remove('selected-action'); attackButton.classList.remove('selected-action');} }
        
        function handleChatInput(event) { 
            if (event.key === 'Enter' && chatInput.value.trim() !== '') { 
                const message = chatInput.value.trim();
                console.log(`[DEBUG] Sending chat message: ${message}`);
                addChatMessage(player.name, message); // Mostra a mensagem localmente imediatamente

                // Multiplayer: Envia mensagem para o servidor
                if (socket && localPlayerId) {
                    socket.emit('chatMessage', {
                        senderId: localPlayerId,
                        senderName: player.name,
                        message: message,
                        mapId: currentMapId // Envia o mapId para que o servidor possa rotear para a sala correta
                    });
                    console.log(`[DEBUG] Emitted chatMessage event to server: ${message}`);
                } else {
                    console.log(`[DEBUG] Socket or localPlayerId is not defined`);
                }
                chatInput.value = ''; 
                event.stopPropagation(); 
            } 
        }
        function addChatMessage(sender, message) { const p = document.createElement('p'); const esc = (str) => { const d=document.createElement('div'); d.appendChild(document.createTextNode(str)); return d.innerHTML; }; p.innerHTML = `<span class="font-semibold ${sender === player.name ? 'text-green-300' : 'text-sky-300'}">[${esc(sender)}]:</span> ${esc(message)}`; chatMessages.appendChild(p); chatMessages.scrollTop = chatMessages.scrollHeight; }

        // --- Patch: Remove defeated open world monsters ---
        const _oldEndCombat = endCombat;
        endCombat = function(victory) {
            if (currentMapId === OPEN_WORLD_ID && activeCombatEnemy && victory) {
                const idx = openWorldEnemies.findIndex(e => e.id === activeCombatEnemy.id);
                if (idx !== -1) openWorldEnemies[idx].isAliveOverworld = false;
            }
            _oldEndCombat.apply(this, arguments);
        }        // --- Enhanced Player Data Management System ---
        let lastSaveTime = 0;
        let saveNotificationTimeout = null;

        // Player Data Management Functions
        async function loadPlayerData() {
            try {
                const session = getSession();
                if (!session.username) return;

                console.log('[LOAD DEBUG] Loading player data for:', session.username);
                const response = await fetch(`/api/load-progress/${session.username}`);
                if (response.ok) {
                    const data = await response.json();
                    console.log('[LOAD DEBUG] Data received from server:', data);
                    
                    // Load player progress
                    if (data.progress) {
                        console.log('[LOAD DEBUG] Progress data found:', data.progress);
                        console.log('[LOAD DEBUG] Gold in progress data:', data.progress.gold);
                        applyPlayerProgress(data.progress);
                    } else {
                        console.log('[LOAD DEBUG] No progress data found');
                    }
                    
                    // Load player statistics
                    if (data.statistics) {
                        playerStatistics = data.statistics;
                        updateStatsDisplay();
                    }
                    
                    console.log('‚úÖ Player data loaded successfully');
                    console.log('[LOAD DEBUG] Final player gold after loading:', player.gold);
                    showSaveNotification('Game data loaded!');
                } else {
                    console.warn('‚ö†Ô∏è Failed to load player data, starting with defaults');
                }
            } catch (error) {
                console.error('‚ùå Error loading player data:', error);
            }
        }function applyPlayerProgress(progress) {
            console.log('[LOAD DEBUG] Applying player progress:', progress);
            console.log('[LOAD DEBUG] Progress gold value:', progress.gold);
            console.log('[LOAD DEBUG] Player gold before loading:', player.gold);
            
            // Apply loaded progress to player object
            if (progress.hp !== undefined) player.hp = progress.hp;
            if (progress.maxHp !== undefined) player.maxHp = progress.maxHp;
            if (progress.ap !== undefined) player.ap = progress.ap;
            if (progress.maxAp !== undefined) player.maxAp = progress.maxAp;
            if (progress.mp !== undefined) player.mp = progress.mp;
            if (progress.maxMp !== undefined) player.maxMp = progress.maxMp;
            if (progress.attackPower !== undefined) player.attackPower = progress.attackPower;
            if (progress.attackRange !== undefined) player.attackRange = progress.attackRange;
            if (progress.gold !== undefined) {
                player.gold = progress.gold;
                console.log('[LOAD DEBUG] Gold loaded successfully:', player.gold);
            } else {
                console.log('[LOAD DEBUG] No gold data in progress, keeping current:', player.gold);
            }
            if (progress.overworldX !== undefined) player.overworldX = progress.overworldX;
            if (progress.overworldY !== undefined) player.overworldY = progress.overworldY;
            if (progress.mapId !== undefined) currentMapId = progress.mapId;
            if (progress.level !== undefined) player.level = progress.level;
            if (progress.experience !== undefined) player.experience = progress.experience;
            if (progress.experienceToNext !== undefined) player.experienceToNext = progress.experienceToNext;
            if (progress.skillPoints !== undefined) player.skillPoints = progress.skillPoints;
            
            // Apply skills
            if (progress.strength !== undefined) player.strength = progress.strength;
            if (progress.vitality !== undefined) player.vitality = progress.vitality;
            if (progress.agility !== undefined) player.agility = progress.agility;
            if (progress.intelligence !== undefined) player.intelligence = progress.intelligence;
            if (progress.luck !== undefined) player.luck = progress.luck;
            
            // Apply equipment
            if (progress.weapon !== undefined) player.weapon = progress.weapon;
            if (progress.armor !== undefined) player.armor = progress.armor;
            if (progress.helmet !== undefined) player.helmet = progress.helmet;
            if (progress.boots !== undefined) player.boots = progress.boots;
            if (progress.ring !== undefined) player.ring = progress.ring;
            if (progress.amulet !== undefined) player.amulet = progress.amulet;
            
            // Apply other data
            if (progress.skins) player.skins = progress.skins;
            if (progress.currentSkin !== undefined) player.currentSkin = progress.currentSkin;
            if (progress.inventory) player.inventory = progress.inventory;
            if (progress.spells) player.spells = progress.spells;
            
            updatePlayerOverworldInfo();
        }

        async function savePlayerData(triggerType = 'manual', additionalData = {}) {
            try {
                const session = getSession();
                if (!session.username) return false;

                const currentTime = Date.now();
                
                // Prevent too frequent saves (unless critical triggers)
                const criticalTriggers = ['levelUp', 'combatVictory', 'disconnect'];
                if (!criticalTriggers.includes(triggerType) && currentTime - lastSaveTime < 5000) {
                    return false;
                }

                const progressData = {
                    hp: player.hp,
                    maxHp: player.maxHp,
                    ap: player.ap,
                    maxAp: player.maxAp,
                    mp: player.mp,
                    maxMp: player.maxMp,
                    attackPower: player.attackPower,
                    attackRange: player.attackRange,
                    gold: player.gold,
                    overworldX: player.overworldX,
                    overworldY: player.overworldY,
                    mapId: currentMapId,
                    level: player.level,
                    experience: player.experience,
                    experienceToNext: player.experienceToNext,
                    skillPoints: player.skillPoints,
                    strength: player.strength,
                    vitality: player.vitality,
                    agility: player.agility,
                    intelligence: player.intelligence,
                    luck: player.luck,
                    weapon: player.weapon,
                    armor: player.armor,
                    helmet: player.helmet,
                    boots: player.boots,
                    ring: player.ring,
                    amulet: player.amulet,
                    skins: player.skins,
                    currentSkin: player.currentSkin,
                    inventory: player.inventory,
                    spells: player.spells,
                    ...additionalData
                };

                const response = await fetch('/api/save-progress', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        login: session.username,
                        progress: progressData,
                        triggerType: triggerType
                    })
                });

                if (response.ok) {
                    lastSaveTime = currentTime;
                    console.log(`‚úÖ Progress saved (${triggerType})`);
                    
                    if (triggerType !== 'periodicSave') {
                        showSaveNotification(`Progress saved! (${triggerType})`);
                    }
                    
                    return true;
                } else {
                    console.error('‚ùå Failed to save progress:', await response.text());
                    return false;
                }
            } catch (error) {
                console.error('‚ùå Error saving player data:', error);
                return false;
            }
        }        // Level up trigger function (for auto-save integration)
        function triggerLevelUpSave(newLevel, experienceGained, skillPointsEarned) {
            try {
                console.log(`üéâ Level up triggered: Level ${newLevel}, XP: ${experienceGained}, SP: ${skillPointsEarned}`);
                
                // In the simplified save system, this will be blocked by the server
                // Only included for UI consistency and potential future features
                savePlayerData('levelUp', {
                    triggerData: {
                        newLevel,
                        experienceGained,
                        skillPointsEarned,
                        timestamp: Date.now()
                    }
                });
                
                return true;
            } catch (error) {
                console.error('‚ùå Error in triggerLevelUpSave:', error);
                return false;
            }
        }

        // Auto-save trigger hook function (mostly disabled due to simplified save system)
        function hookAutoSaveTriggers() {
            // The auto-save system is mostly disabled on the server side
            // Only combat victory saves are allowed, which are already handled in the combat system
            console.log('üîó Auto-save triggers hooked (simplified system - only combat saves enabled)');
            
            // Hook level up trigger (for UI notification only, server blocks the save)
            const originalLevelUp = triggerLevelUpSave;
            if (typeof triggerLevelUpSave === 'function') {
                window.triggerLevelUpSave = function(newLevel, experienceGained, skillPointsEarned) {
                    console.log('üéâ Level up triggered (save will be blocked by server)');
                    return originalLevelUp.call(this, newLevel, experienceGained, skillPointsEarned);
                };
            }
            
            // Note: Combat victory saves are already hooked in the combat system
            // Item acquisition and other triggers are disabled server-side
        }

        // Periodic save function (disabled due to simplified save system)
        function startPeriodicSave() {
            // The periodic save system is disabled on the server side
            // Only combat victory saves are allowed
            console.log('‚è∞ Periodic save system initialized (disabled - only combat saves allowed)');
            
            // We could start a periodic save here, but the server will block it
            // The server-side AUTO_SAVE_CONFIG.triggers.periodicSave is set to false
            
            // For now, just log that the system is disabled
            setInterval(() => {
                console.log('üíæ Periodic save check (disabled by server configuration)');
            }, 60000); // Log every minute that periodic saves are disabled
        }

        // Initialize save UI elements (for simplified save system)
        function initializeSaveUI() {
            try {
                console.log('üíæ Initializing save UI...');
                
                // Find save-related UI elements
                const autoSaveIndicator = document.getElementById('auto-save-indicator');
                const lastSaveTime = document.getElementById('last-save-time');
                
                // Update save indicator to reflect simplified system
                if (autoSaveIndicator) {
                    autoSaveIndicator.textContent = 'üîÑ Combat-only saves';
                    autoSaveIndicator.title = 'Only combat victory saves are enabled in this simplified system';
                }
                
                // Initialize last save time
                if (lastSaveTime) {
                    lastSaveTime.textContent = '√öltimo save: nunca';
                }
                
                console.log('‚úÖ Save UI initialized successfully');
            } catch (error) {
                console.error('‚ùå Error initializing save UI:', error);
            }        }

        // Save notification function
        function showSaveNotification(message) {
            try {
                const saveStatusEl = document.getElementById('save-status');
                const lastSaveTimeEl = document.getElementById('last-save-time');
                
                if (lastSaveTimeEl) {
                    lastSaveTimeEl.textContent = `√öltimo save: ${new Date().toLocaleTimeString()}`;
                }
                
                // Clear any existing notification timeout
                if (saveNotificationTimeout) {
                    clearTimeout(saveNotificationTimeout);
                }
                
                // Show temporary notification
                if (saveStatusEl) {
                    const originalContent = saveStatusEl.innerHTML;
                    saveStatusEl.innerHTML = `<span class="text-green-400">‚úÖ ${message}</span>`;
                    
                    // Revert back to original after 3 seconds
                    saveNotificationTimeout = setTimeout(() => {
                        saveStatusEl.innerHTML = originalContent;
                    }, 3000);
                }
                
                console.log(`üíæ ${message}`);
            } catch (error) {
                console.error('‚ùå Error showing save notification:', error);
            }
        }

        // Combat victory save trigger function
        function triggerCombatVictorySave(enemyData, damageDealt) {
            try {
                console.log(`‚öîÔ∏è Combat victory save triggered for enemy:`, enemyData);
                
                // Trigger save with combat data
                savePlayerData('combatVictory', {
                    triggerData: {
                        enemyId: enemyData.id,
                        enemyName: enemyData.combatStats?.name || enemyData.name,
                        damageDealt,
                        timestamp: Date.now()
                    }
                });
                
                return true;
            } catch (error) {
                console.error('‚ùå Error in triggerCombatVictorySave:', error);
                return false;
            }
        }

        // Global key handler function
        function handleGlobalKeyDown(e) {
            try {
                // Don't handle keys if user is typing in chat
                if (document.activeElement === chatInput) {
                    return;
                }
                
                // Handle different game states
                if (gameState === 'overworld') {
                    handleOverworldKeyDown(e);
                } else if (gameState === 'combat') {
                    handleCombatKeyDown(e);
                }
                
                // Global shortcuts that work in any state
                switch(e.key) {
                    case 'Enter':
                        e.preventDefault();
                        chatInput.focus();
                        break;
                    case 'Escape':
                        e.preventDefault();
                        if (document.activeElement === chatInput) {
                            chatInput.blur();
                        }
                        break;
                }
            } catch (error) {
                console.error('‚ùå Error in handleGlobalKeyDown:', error);
            }
        }

        // Overworld key handler function
        function handleOverworldKeyDown(e) {
            try {
                if (!player.isAlive) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        e.preventDefault();
                        movePlayer(0, -1);
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        e.preventDefault();
                        movePlayer(0, 1);
                        break;
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        e.preventDefault();
                        movePlayer(-1, 0);
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        e.preventDefault();
                        movePlayer(1, 0);
                        break;
                }
            } catch (error) {
                console.error('‚ùå Error in handleOverworldKeyDown:', error);
            }
        }        // Setup party UI elements and event listeners
        function setupPartyUI() {
            try {
                console.log('üéâ Setting up party UI...');
                
                // Get UI elements
                const leavePartyBtn = document.getElementById('leave-party-btn');
                
                // Leave party button
                if (leavePartyBtn) {
                    leavePartyBtn.onclick = () => {
                        if (socket && localPlayerId && currentParty) {
                            socket.emit('leaveParty', {
                                playerId: localPlayerId,
                                partyId: currentParty.id
                            });
                        }
                    };
                }
                
                console.log('‚úÖ Party UI setup completed successfully');
            } catch (error) {
                console.error('‚ùå Error setting up party UI:', error);
            }
        }        // Update party UI based on current party state
        function updatePartyUI() {
            try {
                console.log('üîÑ [PARTY DEBUG] Updating party UI - Current party:', currentParty ? currentParty.id : 'NONE');
                console.log('üîÑ [PARTY DEBUG] Pending invites count:', pendingPartyInvites.length);
                
                const noPartyState = document.getElementById('no-party-state');
                const partyState = document.getElementById('party-state');
                const partyInvites = document.getElementById('party-invites');
                const partyMembersList = document.getElementById('party-members-list');
                const partyInvitesList = document.getElementById('party-invites-list');
                
                console.log('üîç [PARTY DEBUG] UI Elements found:', {
                    noPartyState: !!noPartyState,
                    partyState: !!partyState,
                    partyInvites: !!partyInvites,
                    partyInvitesList: !!partyInvitesList
                });
                  if (!currentParty) {
                    // Show no party state
                    if (noPartyState) noPartyState.style.display = 'block';
                    if (partyState) partyState.style.display = 'none';
                } else {
                    // Show party state
                    if (noPartyState) noPartyState.style.display = 'none';
                    if (partyState) partyState.style.display = 'block';
                    
                    // Update party members list
                    if (partyMembersList && currentParty.members) {
                        partyMembersList.innerHTML = '';
                        
                        currentParty.members.forEach(member => {
                            const memberDiv = document.createElement('div');
                            memberDiv.className = 'flex items-center justify-between p-2 bg-gray-700 rounded text-xs';
                            
                            const isLeader = member.id === currentParty.leader;
                            const isMe = member.id === localPlayerId;
                            
                            let memberName = member.name;
                            if (isLeader) memberName += ' üëë';
                            if (isMe) memberName += ' (Voc√™)';
                            
                            memberDiv.innerHTML = `
                                <span>${memberName}</span>
                                ${isLeader && !isMe ? `<button class="text-red-400 hover:text-red-300 ml-2" onclick="kickPartyMember('${member.id}')">‚ùå</button>` : ''}
                            `;
                            
                            partyMembersList.appendChild(memberDiv);
                        });
                    }
                }
                
                // ALWAYS update party invites regardless of current party state
                // This is the key fix - party invites should show even when not in a party
                console.log('üîç [PARTY DEBUG] Updating party invites section...');
                if (partyInvites && partyInvitesList) {
                    if (pendingPartyInvites && pendingPartyInvites.length > 0) {
                        console.log('‚úÖ [PARTY DEBUG] Showing party invites - Count:', pendingPartyInvites.length);
                        partyInvites.style.display = 'block';
                        partyInvitesList.innerHTML = '';
                        
                        pendingPartyInvites.forEach((invite, index) => {
                            console.log(`üì© [PARTY DEBUG] Processing invite ${index + 1}:`, invite);
                            const inviteDiv = document.createElement('div');
                            inviteDiv.className = 'flex items-center justify-between p-2 bg-gray-700 rounded text-xs';
                            
                            inviteDiv.innerHTML = `
                                <span>${invite.fromName}</span>
                                <div class="flex gap-1">
                                    <button class="text-green-400 hover:text-green-300" onclick="acceptPartyInvite('${invite.from}', '${invite.partyId}')">‚úÖ</button>
                                    <button class="text-red-400 hover:text-red-300" onclick="declinePartyInvite('${invite.from}', '${invite.partyId}')">‚ùå</button>
                                </div>
                            `;
                            
                            partyInvitesList.appendChild(inviteDiv);
                        });
                    } else {
                        console.log('‚ùå [PARTY DEBUG] No pending invites - hiding section');
                        partyInvites.style.display = 'none';
                    }
                } else {
                    console.log('‚ùå [PARTY DEBUG] Party invites UI elements not found!');
                }
                  console.log('üîÑ Party UI updated successfully');
            } catch (error) {
                console.error('‚ùå Error updating party UI:', error);
            }
        }

        // Bump cooldown variables
        let lastBumpTime = {};
        const BUMP_COOLDOWN = 3000; // 3 seconds cooldown between bumps

        // Function to trigger party invitation when players bump into each other
        function triggerPartyInvitation(otherPlayer, playerId) {
            try {
                console.log(`ü§ù Triggering party invitation with player: ${otherPlayer.name} (ID: ${playerId})`);
                
                // Check bump cooldown to prevent spam
                const now = Date.now();
                if (lastBumpTime[playerId] && (now - lastBumpTime[playerId]) < BUMP_COOLDOWN) {
                    return; // Still in cooldown
                }
                
                // Update last bump time
                lastBumpTime[playerId] = now;
                
                // Add floating message
                addFloatingMessage(
                    otherPlayer.x, 
                    otherPlayer.y, 
                    'invite to party', 
                    '#60a5fa', // Blue color
                    2000, // 2 second duration
                    playerId,
                    'party-invite'
                );
                
                // Handle party invitation logic
                if (socket && localPlayerId) {
                    if (currentParty && currentParty.leader === localPlayerId) {
                        // Player is party leader - invite to existing party
                        socket.emit('inviteToParty', {
                            playerId: localPlayerId,
                            partyId: currentParty.id,
                            targetPlayerName: otherPlayer.name
                        });
                        logGameMessage(`Convite enviado para ${otherPlayer.name}!`, 3000);
                    } else if (!currentParty) {
                        // Player is not in a party - create party and invite
                        socket.emit('createPartyAndInvite', {
                            playerId: localPlayerId,
                            targetPlayerName: otherPlayer.name
                        });
                        logGameMessage(`Party criada e convite enviado para ${otherPlayer.name}!`, 3000);
                    } else {
                        // Player is in party but not leader
                        logGameMessage(`Apenas o l√≠der da party pode convidar jogadores!`, 3000);
                    }
                }            } catch (error) {
                console.error('‚ùå Error triggering party invitation:', error);
            }
        }

        // Global helper functions for party invite management (must be accessible globally)
        window.acceptPartyInvite = function(fromPlayerId, partyId) {
            if (socket && localPlayerId) {
                socket.emit('acceptPartyInvite', {
                    playerId: localPlayerId,
                    partyId: partyId,
                    fromPlayerId: fromPlayerId
                });
                
                // Remove from pending invites
                pendingPartyInvites = pendingPartyInvites.filter(invite => 
                    invite.from !== fromPlayerId || invite.partyId !== partyId
                );
                updatePartyUI();
            }
        };

        window.declinePartyInvite = function(fromPlayerId, partyId) {
            if (socket && localPlayerId) {
                socket.emit('declinePartyInvite', {
                    playerId: localPlayerId,
                    partyId: partyId,
                    fromPlayerId: fromPlayerId
                });
                
                // Remove from pending invites
                pendingPartyInvites = pendingPartyInvites.filter(invite => 
                    invite.from !== fromPlayerId || invite.partyId !== partyId
                );
                updatePartyUI();
            }
        };

        window.kickPartyMember = function(targetPlayerId) {
            if (socket && localPlayerId && currentParty && currentParty.leader === localPlayerId) {
                socket.emit('kickFromParty', {
                    playerId: localPlayerId,
                    partyId: currentParty.id,
                    targetPlayerId: targetPlayerId
                });
            }
        };; // End of DOMContentLoaded event listener

    </script>
</body>
</html>