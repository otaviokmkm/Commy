<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMORPG Tático com Overworld</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: #1a202c; /* cinza escuro Tailwind */
            color: #e2e8f0; /* ardósia clara Tailwind */
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
        }
        #game-and-ui-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 1200px;
        }
        #main-content-area {
            display: flex;
            flex-direction: row; /* Para UI lateral */
            gap: 1rem;
            width: 100%;
            justify-content: center;
            align-items: flex-start; /* Alinha o painel lateral com o topo do game-container */
        }
        #game-area-wrapper { /* Novo wrapper para canvas e hotbar */
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 70vw; /* Ajustar conforme necessário */
            max-width: 800px;
        }
        #game-container {
            width: 100%; /* Ocupa toda a largura do game-area-wrapper */
            max-height: 600px; /* Mantém uma altura máxima */
            background-color: #2d3748; 
            border: 2px solid #4a5568;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            position: relative;
            aspect-ratio: 4 / 3; /* Exemplo de aspect ratio, ajuste conforme necessário */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 0.375rem;
            cursor: pointer;
            background-color: #374151; 
        }
        #combat-hotbar {
            display: none; /* Inicialmente escondida */
            justify-content: center;
            gap: 0.5rem; /* Espaço entre os slots */
            padding: 0.5rem;
            background-color: #2d3748; /* Cor similar aos painéis */
            border: 1px solid #4a5568;
            border-top: none; /* Para parecer conectado ao game-container se posicionado abaixo */
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
            width: 100%; /* Ocupa toda a largura do game-area-wrapper */
            box-sizing: border-box;
            margin-top: -1px; 
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            background-color: #1a202c; 
            border: 1px solid #4a5568; 
            border-radius: 0.25rem; 
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem; 
            color: #a0aec0; 
            cursor: pointer;
            position: relative; 
        }
        .hotbar-slot .slot-number {
            position: absolute;
            top: 2px;
            right: 4px;
            font-size: 0.65rem;
            color: #718096; 
        }

        #right-ui-panel {
            width: 25vw;
            max-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        .ui-panel {
            background-color: #2d3748;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            padding: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        #chat-messages {
            background-color: #1e293b;
            padding: 0.5rem;
            border-radius: 0.375rem;
            height: 100px;
            overflow-y: auto;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
        }
        #chat-input {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            border: 1px solid #4a5568;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .game-message {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 0.375rem;
            font-size: 0.9em;
            z-index: 100;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
            text-align: center;
        }
        .action-button {
            background-color: #38a169; 
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            text-align: center;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            font-weight: 600;
        }
        .action-button:hover {
            background-color: #2f855a; 
        }
        .action-button:disabled {
            background-color: #4a5568; 
            cursor: not-allowed;
        }
        .selected-action {
            background-color: #dd6b20; 
        }
        .selected-action:hover {
            background-color: #c05621; 
        }
        .combat-ui {
            display: none;
        }
    </style>
</head>
<body class="bg-gray-900 text-slate-200 flex flex-col items-center min-h-screen p-4">
    <div id="auth-modal" style="position:fixed;top:0;left:0;width:100vw;height:100vh;background:rgba(20,23,35,0.96);display:flex;align-items:center;justify-content:center;z-index:9999;">
        <div class="bg-gray-800 rounded-lg shadow-xl p-8 w-full max-w-xs flex flex-col items-center">
            <h2 class="text-2xl font-bold text-emerald-400 mb-4">Entrar no Jogo</h2>
            <form id="login-form" class="w-full flex flex-col gap-2">
                <input id="login-username" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Usuário" autocomplete="username" required>
                <input id="login-password" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Senha" type="password" autocomplete="current-password" required>
                <button type="submit" class="action-button w-full">Entrar</button>
            </form>
            <div class="text-slate-400 text-sm my-2">ou</div>
            <form id="register-form" class="w-full flex flex-col gap-2">
                <input id="register-username" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Novo usuário" autocomplete="username" required>
                <input id="register-password" class="p-2 rounded bg-gray-700 text-slate-200" placeholder="Senha" type="password" autocomplete="new-password" required>
                <button type="submit" class="action-button w-full bg-sky-600 hover:bg-sky-700">Cadastrar</button>
            </form>
            <div id="auth-error" class="text-red-400 text-sm mt-2" style="display:none"></div>
        </div>
    </div>

    <header class="mb-6 text-center">
        <h1 class="text-4xl font-bold text-emerald-400">MMORPG Tático</h1>
        <p class="text-slate-400" id="statusInfo">Explorando o mundo...</p>
    </header>

    <div id="game-and-ui-wrapper">
        <div id="main-content-area">
            <div id="game-area-wrapper">
                <div id="game-container" class="shadow-2xl">
                    <canvas id="gameCanvas"></canvas>
                    <div id="gameLogMessage" class="game-message hidden"></div>
                </div>
                <div id="combat-hotbar">
                    </div>
            </div>

            <div id="right-ui-panel">
                <div id="player-info-overworld" class="ui-panel">
                        <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Jogador</h2>
                        <p><strong>Nome:</strong> <span id="playerNameOverworld">Aventureiro</span></p>
                        <p><strong>HP:</strong> <span id="playerHPOverworld">100/100</span></p>
                        <p><strong>Ouro:</strong> <span id="playerGoldOverworld">0</span>g</p>
                        <p class="text-xs mt-2">Setas: Mover. Encoste em inimigos para lutar.</p>
                </div>

                <div id="combat-ui-panel" class="ui-panel combat-ui">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Combate</h2>
                    <div id="player-stats-combat" class="text-sm space-y-1">
                        <p><strong>AP:</strong> <span id="playerAPCombat">0/0</span></p>
                        <p><strong>MP:</strong> <span id="playerMPCombat">0/0</span></p>
                    </div>
                    <div class="mt-3 space-y-2">
                        <button id="moveButton" class="action-button w-full">Mover (1)</button>
                        <button id="attackButton" class="action-button w-full">Atacar (2)</button>
                        <button id="endTurnButton" class="action-button w-full bg-sky-600 hover:bg-sky-700">Passar Turno (Espaço)</button>
                    </div>
                </div>

                <div id="chat-box-container" class="ui-panel">
                    <h2 class="text-lg font-semibold border-b border-slate-600 pb-1 mb-2 text-emerald-300">Chat</h2>
                    <div id="chat-messages">
                        <p><span class="font-bold text-yellow-400">[Sistema]:</span> Bem-vindo! Vá para a direita para avançar de mapa.</p>
                    </div>
                    <input type="text" id="chat-input" placeholder="Digite sua mensagem..." class="focus:outline-none focus:border-emerald-500">
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Multiplayer: Socket.IO instance ---
        const socket = io(); 
        let localPlayerId = null; 
        let otherPlayers = {}; 


        // --- Autenticação: Modal de Login/Cadastro ---
        const authModal = document.getElementById('auth-modal');
        function showAuthModal() { authModal.style.display = 'flex'; }
        function hideAuthModal() { authModal.style.display = 'none'; }
        function setAuthError(msg) { const err = document.getElementById('auth-error'); err.textContent = msg; err.style.display = 'block'; }
        function clearAuthError() { const err = document.getElementById('auth-error'); err.textContent = ''; err.style.display = 'none'; }
        function saveSession(token, username) { localStorage.setItem('sessionToken', token); localStorage.setItem('username', username); }
        function clearSession() { localStorage.removeItem('sessionToken'); localStorage.removeItem('username'); }
        function getSession() { return { token: localStorage.getItem('sessionToken'), username: localStorage.getItem('username') }; }

        // Login
        document.getElementById('login-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            clearAuthError();
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            try {
                const res = await fetch('/api/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ login: username, password })
                });
                if (res.ok) {
                    const data = await res.json();
                    saveSession(data.token, username);
                    player.name = username;
                    localPlayerId = username; 
                    hideAuthModal();
                    startGameAfterAuth();
                } else {
                    const errorData = await res.json().catch(() => ({ error: 'Usuário ou senha inválidos.' }));
                    setAuthError(errorData.error || 'Usuário ou senha inválidos.');
                }
            } catch (error) {
                setAuthError('Erro de conexão ao tentar fazer login.');
            }
        });

        // Cadastro
        document.getElementById('register-form').addEventListener('submit', async (e) => {
            e.preventDefault();
            clearAuthError();
            const username = document.getElementById('register-username').value.trim();
            const password = document.getElementById('register-password').value;
            try {
                const res = await fetch('/api/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ login: username, password })
                });
                if (res.ok) {
                    const loginRes = await fetch('/api/login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ login: username, password })
                    });
                    if (loginRes.ok) {
                        const loginData = await loginRes.json();
                        saveSession(loginData.token, username);
                        player.name = username;
                        localPlayerId = username; 
                        hideAuthModal();
                        startGameAfterAuth();
                    } else {
                        setAuthError('Erro ao fazer login automático após cadastro.');
                    }
                } else {
                    let msg = 'Erro ao cadastrar.';
                    try { const err = await res.json(); if (err && err.error) { msg = err.error; } } catch {}
                    setAuthError(msg);
                }
            } catch (error) {
                setAuthError('Erro de conexão ao tentar cadastrar.');
            }
        });

        function addLogoutButton() {
            let btn = document.getElementById('logout-btn');
            if (!btn) {
                btn = document.createElement('button');
                btn.id = 'logout-btn';
                btn.textContent = 'Sair';
                btn.className = 'action-button w-full bg-red-600 hover:bg-red-700 mt-3';
                btn.onclick = async () => {
                    if (socket && localPlayerId) { 
                        socket.emit('playerDisconnecting', { playerId: localPlayerId, mapId: currentMapId });
                    }
                    clearSession();
                    localPlayerId = null;
                    otherPlayers = {};
                    showAuthModal();
                    location.reload(); 
                };
                playerInfoOverworldPanel.appendChild(btn);
            }
        }

        let gameInitialized = false;
        function startGameAfterAuth() {
            if (gameInitialized) return;
            gameInitialized = true;
            player.name = getSession().username || 'Aventureiro';
            if (!localPlayerId && player.name !== 'Aventureiro') { 
                localPlayerId = player.name;
            }
            addLogoutButton();
            initGame(); 
        }

        document.addEventListener('DOMContentLoaded', () => {
            const session = getSession();
            if (session.token && session.username) {
                localPlayerId = session.username; 
                hideAuthModal();
                startGameAfterAuth();
            } else {
                showAuthModal();
            }
        });

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const combatHotbarElement = document.getElementById('combat-hotbar'); 
        const chatInput = document.getElementById('chat-input');
        const chatMessages = document.getElementById('chat-messages');
        const gameLogMessage = document.getElementById('gameLogMessage');
        const statusInfoDisplay = document.getElementById('statusInfo');
        const playerNameOverworldDisplay = document.getElementById('playerNameOverworld');
        const playerHPOverworldDisplay = document.getElementById('playerHPOverworld');
        const playerGoldOverworldDisplay = document.getElementById('playerGoldOverworld');
        const playerAPCombatDisplay = document.getElementById('playerAPCombat');
        const playerMPCombatDisplay = document.getElementById('playerMPCombat');
        const combatUiPanel = document.getElementById('combat-ui-panel');
        const playerInfoOverworldPanel = document.getElementById('player-info-overworld');
        const moveButton = document.getElementById('moveButton');
        const attackButton = document.getElementById('attackButton');
        const endTurnButton = document.getElementById('endTurnButton');

        const TILE_SIZE = 40; 
        let GRID_COLS, GRID_ROWS; 
        let gameState = 'overworld'; 
        const HOTBAR_SLOTS = 5; 
        let currentMapId = 'mapa1'; 
        let lastAiUpdateTime = 0;
        const AI_UPDATE_INTERVAL = 500; 
        const OPEN_WORLD_ID = 'open_world';
        const OPEN_WORLD_SIZE = 200;
        let openWorldMap = null; 
        let openWorldEnemies = []; // Inimigos específicos do mundo aberto
        let cameraX = 0, cameraY = 0;
        let cameraWidth = 0, cameraHeight = 0;

        const MAP_TILES = { EMPTY: 0, OBSTACLE_ROCK: 1, DECORATION_TREE: 2, DECORATION_BUSH: 3 };
        const mapConnections = {
            'mapa1': { right: 'mapa2' },
            'mapa2': { left: 'mapa1', right: 'mapa_chefe' },
            'mapa_chefe': { left: 'mapa2' }
        };

        let mapData = []; 
        // Cache para os layouts de mapa gerados (ou recebidos do servidor)
        const mapLayoutCache = {};

        const mapInitialEnemies = {
            mapa1: [
                { id: 1, originalOverworldX: 8, originalOverworldY: 5, data: { combatStats: { maxHp: 100 }, aggroRange: 5 } },
                // Add more enemies here
            ],
            mapa2: [],
            mapa_chefe: [],
        };


        function generateMapFor(mapId, serverMapLayout = null) {
            // Se o servidor fornecer um layout, use-o (para persistência e sincronização)
            if (serverMapLayout) {
                if (mapId === OPEN_WORLD_ID) {
                    openWorldMap = serverMapLayout;
                } else {
                    mapLayoutCache[mapId] = serverMapLayout;
                }
                mapData = serverMapLayout;
                // console.log(`Mapa ${mapId} carregado do servidor.`);
                return;
            }

            // Se já existe um layout em cache para este mapaId (exceto open_world que tem seu próprio cache)
            if (mapId !== OPEN_WORLD_ID && mapLayoutCache[mapId]) {
                mapData = mapLayoutCache[mapId];
                // console.log(`Mapa ${mapId} carregado do cache do cliente.`);
                return;
            }
            
            // Geração local como fallback ou para mapas não persistentes entre sessões (se não vier do servidor)
            if (mapId === OPEN_WORLD_ID) {
                if (!openWorldMap) { // Gera o mapa do mundo aberto apenas uma vez por sessão do cliente
                    openWorldMap = [];
                    for (let r = 0; r < OPEN_WORLD_SIZE; r++) {
                        openWorldMap[r] = [];
                        for (let c = 0; c < OPEN_WORLD_SIZE; c++) {
                            if (r === 0 || r === OPEN_WORLD_SIZE - 1 || c === 0 || c === OPEN_WORLD_SIZE - 1) {
                                openWorldMap[r][c] = MAP_TILES.OBSTACLE_ROCK;
                            } else if (Math.random() < 0.07) {
                                openWorldMap[r][c] = MAP_TILES.OBSTACLE_ROCK;
                            } else if (Math.random() < 0.10) {
                                openWorldMap[r][c] = Math.random() < 0.5 ? MAP_TILES.DECORATION_TREE : MAP_TILES.DECORATION_BUSH;
                            } else {
                                openWorldMap[r][c] = MAP_TILES.EMPTY;
                            }
                        }
                    }
                    // Inimigos do mundo aberto são gerados aqui também, mas idealmente o servidor gerenciaria seus estados e respawns.
                    openWorldEnemies = []; 
                    for (let i = 0; i < 40; i++) {
                        let placed = false;
                        while (!placed) {
                            let x = 2 + Math.floor(Math.random() * (OPEN_WORLD_SIZE - 4));
                            let y = 2 + Math.floor(Math.random() * (OPEN_WORLD_SIZE - 4));
                            // Garante que o inimigo não spawne em cima de um obstáculo já definido
                            if (openWorldMap[y] && openWorldMap[y][x] === MAP_TILES.EMPTY) {
                                openWorldEnemies.push({
                                    id: 1000 + i, 
                                    originalOverworldX: x, originalOverworldY: y, // Guarda posição original para respawn
                                    overworldX: x, overworldY: y,
                                    aggroRange: 5 + Math.floor(Math.random() * 5),
                                    isAliveOverworld: true,
                                    combatStats: {
                                        size: TILE_SIZE * 0.9, color: ['#eab308', '#f87171', '#34d399', '#818cf8'][i % 4], 
                                        hp: 60 + Math.floor(Math.random() * 60), maxHp: 60 + Math.floor(Math.random() * 60), 
                                        ap: 4 + Math.floor(Math.random() * 3), maxAp: 4 + Math.floor(Math.random() * 3), 
                                        mp: 2 + Math.floor(Math.random() * 2), maxMp: 2 + Math.floor(Math.random() * 2), 
                                        attackPower: 10 + Math.floor(Math.random() * 10), attackRange: 1, 
                                        name: 'Monstro Selvagem', loot: { gold: 10 + Math.floor(Math.random() * 20) }
                                    }
                                });
                                placed = true;
                            }
                        }
                    }
                    // console.log(`Mapa ${OPEN_WORLD_ID} gerado localmente.`);
                }
                mapData = openWorldMap;
            } else { // Mapas menores
                const newMapLayout = [];
                if (GRID_ROWS <= 0 || GRID_COLS <= 0) return; 
                for (let r = 0; r < GRID_ROWS; r++) {
                    newMapLayout[r] = [];
                    for (let c = 0; c < GRID_COLS; c++) newMapLayout[r][c] = MAP_TILES.EMPTY;
                }
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        if (r === 0 || r === GRID_ROWS - 1 || c === 0 || c === GRID_COLS - 1) {
                            const connections = mapConnections[mapId] || {};
                            let isConnectionTile = false;
                            if (r === 0 && connections.up) isConnectionTile = true;
                            else if (r === GRID_ROWS - 1 && connections.down) isConnectionTile = true;
                            else if (c === 0 && connections.left) isConnectionTile = true;
                            else if (c === GRID_COLS - 1 && connections.right) isConnectionTile = true;
                            if (!isConnectionTile) newMapLayout[r][c] = MAP_TILES.OBSTACLE_ROCK;
                        }
                    }
                }
                let rockDensity = 0.05, decorDensity = 0.1;
                if (mapId === 'mapa_chefe') { rockDensity = 0.1; decorDensity = 0.05; }
                for (let r = 1; r < GRID_ROWS - 1; r++) {
                    for (let c = 1; c < GRID_COLS - 1; c++) {
                        let isEntitySpawn = (r === player.overworldY && c === player.overworldX);
                        if (!isEntitySpawn) {
                            for (const enemy of enemies) { 
                                if (enemy.mapId === mapId && enemy.isAliveOverworld && enemy.overworldY === r && enemy.overworldX === c) {
                                    isEntitySpawn = true; break;
                                }
                            }
                        }
                        if (isEntitySpawn) continue; 
                        if (Math.random() < rockDensity) newMapLayout[r][c] = MAP_TILES.OBSTACLE_ROCK;
                        else if (Math.random() < decorDensity) newMapLayout[r][c] = Math.random() < 0.5 ? MAP_TILES.DECORATION_TREE : MAP_TILES.DECORATION_BUSH;
                    }
                }
                if (isValidOverworldTile(player.overworldX, player.overworldY) && newMapLayout[player.overworldY]) { 
                    newMapLayout[player.overworldY][player.overworldX] = MAP_TILES.EMPTY;
                }
                enemies.forEach(enemy => {
                    if (enemy.mapId === mapId && enemy.isAliveOverworld && isValidOverworldTile(enemy.overworldX, enemy.overworldY)) {
                        if(newMapLayout[enemy.overworldY]) newMapLayout[enemy.overworldY][enemy.overworldX] = MAP_TILES.EMPTY;
                    }
                });
                mapData = newMapLayout;
                mapLayoutCache[mapId] = newMapLayout; // Cacheia o layout gerado localmente
                // console.log(`Mapa ${mapId} gerado e cacheado localmente.`);
            }
        }


        let player = {
            overworldX: 1, overworldY: 1, 
            gridX: 0, gridY: 0,
            size: TILE_SIZE * 0.8,
            color: 'deepskyblue', 
            hp: 100, maxHp: 100,
            ap: 60, maxAp: 60,
            mp: 30, maxMp: 30,
            attackPower: 15,
            attackRange: 2, 
            isAlive: true,
            name: "Aventureiro",
            gold: 0,
        };

        // Inimigos: Adicionar originalOverworldX/Y para respawn
        let enemies = JSON.parse(JSON.stringify(mapInitialEnemies[mapId] || [])).map(enemyConfig => ({
            id: enemyConfig.id,
            originalOverworldX: enemyConfig.originalOverworldX,
            originalOverworldY: enemyConfig.originalOverworldY,
            overworldX: enemyConfig.originalOverworldX,
            overworldY: enemyConfig.originalOverworldY,
            isAliveOverworld: true,
            hp: enemyConfig.data.combatStats.maxHp,
            combatStats: enemyConfig.data.combatStats,
            aggroRange: enemyConfig.data.aggroRange,
            respawnTimer: null,
        }));
        let activeCombatEnemy = null; 

        let currentTurn = 'player'; 
        let selectedAction = null; 
        let highlightedTiles = []; 

        function initGame() {
            if (!ctx) { return; }
            resizeCanvas(); 
            window.addEventListener('resize', resizeCanvas);
            window.addEventListener('keydown', handleGlobalKeyDown); 
            canvas.addEventListener('click', handleCanvasClick);
            moveButton.addEventListener('click', () => setSelectedAction('move'));
            attackButton.addEventListener('click', () => setSelectedAction('attack'));
            endTurnButton.addEventListener('click', endPlayerTurn);
            chatInput.addEventListener('keypress', handleChatInput);
            createHotbarSlots(); 
            setupSocketListeners();
            gameLoop(); 
        }

        function setupSocketListeners() {
            if (!socket) { return; }
            socket.on('connect', () => {
                if (localPlayerId) { loadMap(currentMapId); }
            });
            socket.on('mapState', (data) => {
                if (data.mapId === currentMapId) {
                    otherPlayers = {}; 
                    data.players.forEach(p => {
                        if (p.playerId !== localPlayerId) {
                            otherPlayers[p.playerId] = { x: p.x, y: p.y, name: p.name || `P-${p.playerId.slice(0,4)}`, color: p.color || '#ccc', mapId: p.mapId };
                        }
                    });
                    // Multiplayer: Atualizar 'mapData' ou 'openWorldMap' se o servidor enviar layout/seed
                    if (data.mapLayout) { // Assumindo que o servidor pode enviar 'mapLayout'
                        if (currentMapId === OPEN_WORLD_ID) {
                            openWorldMap = data.mapLayout;
                        } else {
                            mapLayoutCache[currentMapId] = data.mapLayout;
                        }
                        mapData = data.mapLayout;
                        // console.log(`Layout do mapa ${currentMapId} recebido do servidor e aplicado.`);
                    }
                    // Multiplayer: Atualizar estado dos inimigos com base nos dados do servidor
                    if (data.enemies) { // Assumindo que o servidor envia uma lista de inimigos com seu estado
                        const currentEnemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                        data.enemies.forEach(serverEnemy => {
                            const clientEnemy = currentEnemyList.find(e => e.id === serverEnemy.id);
                            if (clientEnemy) {
                                clientEnemy.isAliveOverworld = serverEnemy.isAliveOverworld;
                                clientEnemy.overworldX = serverEnemy.overworldX;
                                clientEnemy.overworldY = serverEnemy.overworldY;
                                clientEnemy.combatStats.hp = serverEnemy.hp; // Sincronizar HP atual
                            } else if (currentMapId === OPEN_WORLD_ID) { // Adicionar novo inimigo do mundo aberto se não existir
                                openWorldEnemies.push({ ...serverEnemy, originalOverworldX: serverEnemy.overworldX, originalOverworldY: serverEnemy.overworldY });
                            }
                        });
                    }
                }
            });
            socket.on('playerJoined', (newPlayerData) => {
                if (newPlayerData.mapId === currentMapId && newPlayerData.playerId !== localPlayerId) {
                    otherPlayers[newPlayerData.playerId] = { x: newPlayerData.x, y: newPlayerData.y, name: newPlayerData.name || `P-${newPlayerData.playerId.slice(0,4)}`, color: newPlayerData.color || '#ccc', mapId: newPlayerData.mapId };
                    addChatMessage('[Sistema]', `${otherPlayers[newPlayerData.playerId].name} entrou no mapa.`);
                }
            });
            socket.on('playerMoved', (moveData) => {
                if (moveData.mapId === currentMapId && moveData.playerId !== localPlayerId) {
                    if (otherPlayers[moveData.playerId]) {
                        otherPlayers[moveData.playerId].x = moveData.x;
                        otherPlayers[moveData.playerId].y = moveData.y;
                    } else {
                        otherPlayers[moveData.playerId] = { x: moveData.x, y: moveData.y, name: `P-${moveData.playerId.slice(0,4)}`, color: '#ccc', mapId: moveData.mapId };
                    }
                }
            });
            socket.on('playerLeft', (leaveData) => {
                if (leaveData.mapId === currentMapId && otherPlayers[leaveData.playerId]) {
                    addChatMessage('[Sistema]', `${otherPlayers[leaveData.playerId].name || 'Um jogador'} saiu.`);
                    delete otherPlayers[leaveData.playerId];
                }
            });
            socket.on('chatMessage', (data) => {
                if (data.senderId !== localPlayerId) { 
                    addChatMessage(data.senderName, data.message);
                }
            });
            socket.on('enemyRespawned', (respawnedEnemyData) => {
                if (respawnedEnemyData.mapId === currentMapId) {
                    const enemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                    const enemyToRespawn = enemyList.find(e => e.id === respawnedEnemyData.id);
                    if (enemyToRespawn) {
                        enemyToRespawn.isAliveOverworld = true;
                        enemyToRespawn.overworldX = respawnedEnemyData.overworldX || enemyToRespawn.originalOverworldX; // Usa posição do servidor ou original
                        enemyToRespawn.overworldY = respawnedEnemyData.overworldY || enemyToRespawn.originalOverworldY;
                        enemyToRespawn.combatStats.hp = enemyToRespawn.combatStats.maxHp; // Restaura HP
                        logGameMessage(`${enemyToRespawn.combatStats.name} reapareceu!`, 2000);
                    } else if (currentMapId === OPEN_WORLD_ID) { // Se for um inimigo do mundo aberto que não estava na lista (pode acontecer)
                        openWorldEnemies.push({
                            ...respawnedEnemyData, // Assume que o servidor envia todos os dados necessários
                            originalOverworldX: respawnedEnemyData.overworldX,
                            originalOverworldY: respawnedEnemyData.overworldY,
                            isAliveOverworld: true
                        });
                         logGameMessage(`${respawnedEnemyData.combatStats.name} reapareceu!`, 2000);
                    }
                }
            });
            socket.on('disconnect', () => {
                addChatMessage('[Sistema]', 'Você foi desconectado.');
                otherPlayers = {}; 
            });
        }

        function loadMap(mapId, entrySide) {
            const oldMapId = currentMapId;
            currentMapId = mapId;
            otherPlayers = {}; 

            if (mapId === OPEN_WORLD_ID) {
                player.overworldX = Math.floor(OPEN_WORLD_SIZE / 2);
                player.overworldY = Math.floor(OPEN_WORLD_SIZE / 2);
                cameraX = player.overworldX; 
                cameraY = player.overworldY;
                cameraWidth = Math.floor(canvas.width / TILE_SIZE);
                cameraHeight = Math.floor(canvas.height / TILE_SIZE);
                // Para o mundo aberto, a geração/cache é tratada em generateMapFor
                generateMapFor(currentMapId); 
            } else {
                if (GRID_COLS <= 0 || GRID_ROWS <= 0) { 
                    player.overworldX = 0; player.overworldY = 0;
                } else if (entrySide) {
                    switch(entrySide) {
                        case 'left': player.overworldX = GRID_COLS - 2; break;
                        case 'right': player.overworldX = 1; break;
                        case 'up': player.overworldY = GRID_ROWS - 2; break;
                        case 'down': player.overworldY = 1; break;
                        default: 
                            player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                            player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
                            break;
                    }
                    player.overworldX = Math.max(1, Math.min(player.overworldX, GRID_COLS - 2)); 
                    player.overworldY = Math.max(1, Math.min(player.overworldY, GRID_ROWS - 2));
                } else { 
                    player.overworldX = 1; player.overworldY = 1;
                }
                // Gera (ou carrega do cache) o mapa menor
                generateMapFor(currentMapId); 
            }
            updateUIBasedOnState();
            updatePlayerOverworldInfo();

            if (socket && localPlayerId && gameInitialized) {
                if (oldMapId && oldMapId !== currentMapId) { 
                    socket.emit('leaveMap', { playerId: localPlayerId, mapId: oldMapId });
                }
                socket.emit('joinMap', {
                    mapId: currentMapId,
                    playerId: localPlayerId,
                    x: player.overworldX,
                    y: player.overworldY,
                    name: player.name,
                    color: player.color 
                });
            }
        }

        function resizeCanvas() {
            if (!gameContainer || gameContainer.clientWidth === 0 || gameContainer.clientHeight === 0) {
                canvas.width = canvas.width || 320; 
                canvas.height = canvas.height || 240;
                if (ctx) { 
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'rgba(0,0,255,0.5)'; 
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = 'white';
                    ctx.fillText("Aguardando dimensões...", 10, 20);
                }
                return; 
            }
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            GRID_COLS = Math.floor(canvas.width / TILE_SIZE);
            GRID_ROWS = Math.floor(canvas.height / TILE_SIZE);
            GRID_COLS = Math.max(1, GRID_COLS); 
            GRID_ROWS = Math.max(1, GRID_ROWS);

            if (currentMapId === OPEN_WORLD_ID) {
                cameraWidth = Math.floor(canvas.width / TILE_SIZE);
                cameraHeight = Math.floor(canvas.height / TILE_SIZE);
            } else {
                if (GRID_COLS > 0 && GRID_ROWS > 0) {
                    player.overworldX = Math.max(0, Math.min(player.overworldX, GRID_COLS - 1));
                    player.overworldY = Math.max(0, Math.min(player.overworldY, GRID_ROWS - 1));
                    enemies.forEach(enemy => {
                        if (enemy.mapId === currentMapId) { 
                            enemy.overworldX = Math.max(0, Math.min(enemy.overworldX, GRID_COLS - 1));
                            enemy.overworldY = Math.max(0, Math.min(enemy.overworldY, GRID_ROWS - 1));
                        }
                    });
                } else { 
                    player.overworldX = 0; player.overworldY = 0;
                    enemies.forEach(enemy => { enemy.overworldX = 0; enemy.overworldY = 0; });
                }
            }
            if (gameInitialized) {
                 loadMap(currentMapId); 
            }
        }

        function updateUIBasedOnState() {
            if (gameState === 'overworld') {
                combatUiPanel.style.display = 'none';
                combatHotbarElement.style.display = 'none'; 
                playerInfoOverworldPanel.style.display = 'block';
                statusInfoDisplay.textContent = `Explorando: ${currentMapId === OPEN_WORLD_ID ? 'Mundo Aberto' : currentMapId}`;
                statusInfoDisplay.className = 'text-slate-400';
                selectedAction = null; 
                highlightedTiles = []; 
            } else if (gameState === 'combat') {
                combatUiPanel.style.display = 'block';
                combatHotbarElement.style.display = 'flex'; 
                playerInfoOverworldPanel.style.display = 'none';
                updateTurnInfo(); 
            }
        }
        
        function createHotbarSlots() {
            combatHotbarElement.innerHTML = ''; 
            for (let i = 1; i <= HOTBAR_SLOTS; i++) {
                const slot = document.createElement('div');
                slot.classList.add('hotbar-slot');
                const slotNumber = document.createElement('span');
                slotNumber.classList.add('slot-number');
                slotNumber.textContent = i;
                slot.appendChild(slotNumber);
                slot.addEventListener('click', () => handleHotbarClick(i));
                combatHotbarElement.appendChild(slot);
            }
        }

        function handleHotbarClick(slotNumber) {
            if (gameState !== 'combat' || currentTurn !== 'player' || !player.isAlive) return;
            logGameMessage(`Slot ${slotNumber} da hotbar clicado (sem ação ainda).`, 2000);
        }

        function initiateCombat(enemyData) {
            activeCombatEnemy = JSON.parse(JSON.stringify(enemyData)); 
            gameState = 'combat';
            logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name}!`, 3000);
            
            player.gridX = (GRID_COLS > 1) ? 1 : 0; 
            player.gridY = GRID_ROWS > 0 ? Math.floor(GRID_ROWS / 2) : 0; 
            player.gridY = Math.max(0, Math.min(player.gridY, GRID_ROWS > 0 ? GRID_ROWS - 1 : 0));

            player.ap = player.maxAp;
            player.mp = player.maxMp;

            activeCombatEnemy.gridX = (GRID_COLS > 2) ? GRID_COLS - 2 : Math.max(0, GRID_COLS -1); 
            activeCombatEnemy.gridY = GRID_ROWS > 0 ? Math.floor(GRID_ROWS / 2) : 0;
            activeCombatEnemy.gridY = Math.max(0, Math.min(activeCombatEnemy.gridY, GRID_ROWS > 0 ? GRID_ROWS - 1 : 0));

            activeCombatEnemy.hp = activeCombatEnemy.combatStats.maxHp; 
            activeCombatEnemy.ap = activeCombatEnemy.combatStats.ap || activeCombatEnemy.combatStats.maxAp; 
            activeCombatEnemy.mp = activeCombatEnemy.combatStats.mp || activeCombatEnemy.combatStats.maxMp;
            activeCombatEnemy.isAliveCombat = true; 
            
            updateUIBasedOnState();
            startPlayerTurn();
        }

        function endCombat(victory) {
            if (victory) {
                const loot = activeCombatEnemy.combatStats.loot || {gold: 0};
                logGameMessage(`Você derrotou ${activeCombatEnemy.combatStats.name}! Recebeu ${loot.gold}g.`, 3000);
                player.gold += loot.gold;
                
                const enemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                const originalEnemy = enemyList.find(e => e.id === activeCombatEnemy.id);
                if(originalEnemy) {
                    originalEnemy.isAliveOverworld = false; 
                    // Multiplayer: O cliente pode notificar o servidor, ou o servidor gerencia respawn timers.
                    // socket.emit('requestEnemyRespawn', { enemyId: originalEnemy.id, mapId: currentMapId });
                }
                
                player.hp = player.maxHp; 
                if (activeCombatEnemy.combatStats.name === 'Rei Goblin') {
                    setTimeout(() => {
                        logGameMessage('Você derrotou o Rei Goblin! O portal para o mundo aberto se abre...', 3500);
                        setTimeout(() => {
                            currentMapId = OPEN_WORLD_ID; 
                            gameState = 'overworld';
                            loadMap(OPEN_WORLD_ID); 
                        }, 3500);
                    }, 1000);
                    activeCombatEnemy = null;
                    return;
                }
            } else {
                logGameMessage("Você foi derrotado...", 5000);
                player.hp = Math.max(1, Math.floor(player.maxHp / 2)); 
                loadMap('mapa1', null); 
            }
            activeCombatEnemy = null;
            gameState = 'overworld';
            updateUIBasedOnState();
            updatePlayerOverworldInfo();
        }

        function startPlayerTurn() {
            currentTurn = 'player';
            selectedAction = null;
            highlightedTiles = [];
            updatePlayerCombatInfo();
            updateTurnInfo();
            enableActionButtons(true);
        }

        function endPlayerTurn() {
            if (currentTurn !== 'player' || gameState !== 'combat' || !player.isAlive) return; 
            selectedAction = null;
            highlightedTiles = [];
            enableActionButtons(false);
            setTimeout(startEnemyTurn, 500); 
        }

        function startEnemyTurn() {
            if (gameState !== 'combat' || !activeCombatEnemy || activeCombatEnemy.hp <= 0 || !player.isAlive) {
                if (player.isAlive && activeCombatEnemy && activeCombatEnemy.hp <= 0) {
                    endCombat(true); 
                } else if (!player.isAlive) {
                    endCombat(false); 
                } else {
                    if (activeCombatEnemy && activeCombatEnemy.hp <=0) endCombat(true); 
                    else gameState = 'overworld'; 
                }
                return;
            }

            currentTurn = 'enemy';
            updateTurnInfo();
            
            const enemy = activeCombatEnemy;
            enemy.ap = enemy.combatStats.maxAp; 
            enemy.mp = enemy.combatStats.maxMp; 

            let actionTakenThisTurn = false; 
            const distToPlayer = getGridDistance(enemy.gridX, enemy.gridY, player.gridX, player.gridY);

            if (distToPlayer <= enemy.combatStats.attackRange && enemy.ap > 0) {
                player.hp -= enemy.combatStats.attackPower;
                enemy.ap--; 
                actionTakenThisTurn = true;
                if (player.hp <= 0) { player.hp = 0; player.isAlive = false; }
                logGameMessage(`${enemy.combatStats.name} ataca ${player.name} causando ${enemy.combatStats.attackPower} de dano! HP Jogador: ${player.hp}`, 2500);
                updatePlayerOverworldInfo(); 
                if (!player.isAlive) {
                    logGameMessage(`${player.name} foi derrotado!`, 4000);
                    setTimeout(() => endCombat(false), 1500);
                    return; 
                }
            }
            if (!actionTakenThisTurn && enemy.mp > 0 && distToPlayer > 0) { 
                let bestMove = {x: enemy.gridX, y: enemy.gridY};
                let currentMinDistanceToPlayer = distToPlayer;
                let foundValidMove = false;
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        if (dx === 0 && dy === 0) continue; 
                        const newX = enemy.gridX + dx;
                        const newY = enemy.gridY + dy;
                        if (isValidCombatTile(newX, newY) && !isCombatTileOccupied(newX,newY, enemy)) {
                            const distanceToPlayerFromNewPos = getGridDistance(newX, newY, player.gridX, player.gridY);
                            if (distanceToPlayerFromNewPos < currentMinDistanceToPlayer) {
                                currentMinDistanceToPlayer = distanceToPlayerFromNewPos;
                                bestMove = {x: newX, y: newY};
                                foundValidMove = true;
                            }
                        }
                    }
                }
                if(foundValidMove){ 
                    enemy.gridX = bestMove.x;
                    enemy.gridY = bestMove.y;
                    enemy.mp--;
                    actionTakenThisTurn = true; 
                    logGameMessage(`${enemy.combatStats.name} moveu-se.`, 1500);
                }
            } 
            player.ap = player.maxAp; 
            player.mp = player.maxMp;
            setTimeout(startPlayerTurn, 1000); 
        }
        
        function isCombatTileOccupied(gridX, gridY, selfEntity = null) {
            if (player.isAlive && player.gridX === gridX && player.gridY === gridY && player !== selfEntity) return true;
            if (activeCombatEnemy && activeCombatEnemy.hp > 0 && activeCombatEnemy.gridX === gridX && activeCombatEnemy.gridY === gridY && activeCombatEnemy !== selfEntity) return true;
            return false;
        }

        function handleGlobalKeyDown(e) {
            if (document.activeElement === chatInput) return; 
            if (gameState === 'overworld' && player.isAlive) handleOverworldKeyDown(e);
            else if (gameState === 'combat' && player.isAlive && currentTurn === 'player') handleCombatKeyDown(e);
        }

        function handleOverworldKeyDown(e) {
            let dx = 0, dy = 0;
            switch (e.key.toLowerCase()) {
                case 'arrowup': case 'w': dy = -1; break;
                case 'arrowdown': case 's': dy = 1; break;
                case 'arrowleft': case 'a': dx = -1; break;
                case 'arrowright': case 'd': dx = 1; break;
                default: return; 
            }
            e.preventDefault(); 

            const prevPlayerX = player.overworldX;
            const prevPlayerY = player.overworldY;

            if (currentMapId === OPEN_WORLD_ID) {
                const newX = player.overworldX + dx;
                const newY = player.overworldY + dy;
                if (!isValidOpenWorldTile(newX, newY)) return;
                for (const enemy of openWorldEnemies) {
                    if (enemy.isAliveOverworld && enemy.overworldX === newX && enemy.overworldY === newY) {
                        initiateOpenWorldCombat(enemy);
                        return;
                    }
                }
                for (const pId in otherPlayers) {
                    if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === newX && otherPlayers[pId].y === newY) {
                        return; 
                    }
                }
                if (openWorldMap && openWorldMap[newY] && openWorldMap[newY][newX] !== MAP_TILES.OBSTACLE_ROCK) {
                    player.overworldX = newX;
                    player.overworldY = newY;
                    cameraX = player.overworldX;
                    cameraY = player.overworldY;
                }
            } else { 
                const newOverworldX = player.overworldX + dx;
                const newOverworldY = player.overworldY + dy;
                const connections = mapConnections[currentMapId] || {};
                if (newOverworldX >= GRID_COLS && connections.right) { loadMap(connections.right, 'right'); return; }
                if (newOverworldX < 0 && connections.left) { loadMap(connections.left, 'left'); return; }
                if (newOverworldY >= GRID_ROWS && connections.down) { loadMap(connections.down, 'down'); return; }
                if (newOverworldY < 0 && connections.up) { loadMap(connections.up, 'up'); return; }
                if (!isValidOverworldTile(newOverworldX, newOverworldY)) return; 
                for (const enemy of enemies) {
                    if (enemy.isAliveOverworld && enemy.mapId === currentMapId && enemy.overworldX === newOverworldX && enemy.overworldY === newOverworldY) {
                        initiateCombat(enemy);
                        return; 
                    }
                }
                for (const pId in otherPlayers) {
                    if (otherPlayers[pId].mapId === currentMapId && otherPlayers[pId].x === newOverworldX && otherPlayers[pId].y === newOverworldY) {
                        return; 
                    }
                }
                if (mapData && mapData.length > newOverworldY && mapData[newOverworldY] && mapData[newOverworldY].length > newOverworldX && mapData[newOverworldY][newOverworldX] !== MAP_TILES.OBSTACLE_ROCK) {
                    player.overworldX = newOverworldX;
                    player.overworldY = newOverworldY;
                }
            }
            if ((player.overworldX !== prevPlayerX || player.overworldY !== prevPlayerY) && socket && localPlayerId) {
                socket.emit('playerMoved', {
                    playerId: localPlayerId,
                    mapId: currentMapId,
                    x: player.overworldX,
                    y: player.overworldY
                });
            }
        }
        function isValidOpenWorldTile(x, y) {
            return x >= 0 && x < OPEN_WORLD_SIZE && y >= 0 && y < OPEN_WORLD_SIZE;
        }

        function initiateOpenWorldCombat(enemyData) {
            activeCombatEnemy = JSON.parse(JSON.stringify(enemyData));
            gameState = 'combat';
            logGameMessage(`Combate iniciado com ${activeCombatEnemy.combatStats.name}!`, 3000);
            player.gridX = 1;
            player.gridY = Math.floor(GRID_ROWS / 2);
            player.ap = player.maxAp;
            player.mp = player.maxMp;
            activeCombatEnemy.gridX = GRID_COLS - 2;
            activeCombatEnemy.gridY = Math.floor(GRID_ROWS / 2);
            activeCombatEnemy.hp = activeCombatEnemy.combatStats.maxHp;
            activeCombatEnemy.ap = activeCombatEnemy.combatStats.ap; 
            activeCombatEnemy.mp = activeCombatEnemy.combatStats.mp;
            activeCombatEnemy.isAliveCombat = true;
            updateUIBasedOnState();
            startPlayerTurn();
        }

        function handleCombatKeyDown(e) {
            switch (e.key.toLowerCase()) {
                case '1': e.preventDefault(); setSelectedAction('move'); break;
                case '2': e.preventDefault(); setSelectedAction('attack'); break;
                case ' ': e.preventDefault(); endPlayerTurn(); break;
                case 'w': case 'arrowup':
                case 's': case 'arrowdown':
                case 'a': case 'arrowleft':
                case 'd': case 'arrowright':
                    if (selectedAction === 'move') {
                        e.preventDefault();
                        let dx = 0, dy = 0;
                        if (e.key === 'w' || e.key === 'arrowup') dy = -1;
                        if (e.key === 's' || e.key === 'arrowdown') dy = 1;
                        if (e.key === 'a' || e.key === 'arrowleft') dx = -1;
                        if (e.key === 'd' || e.key === 'arrowright') dx = 1;
                        handleMoveActionCombat(player.gridX + dx, player.gridY + dy);
                    }
                    break;
            }
        }

        function setSelectedAction(action) {
            if (currentTurn !== 'player' || !player.isAlive || gameState !== 'combat') return;
            if (selectedAction === action) selectedAction = null; 
            else selectedAction = action;
            updateHighlightedTiles();
            moveButton.classList.toggle('selected-action', selectedAction === 'move');
            attackButton.classList.toggle('selected-action', selectedAction === 'attack');
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const gridX = Math.floor((event.clientX - rect.left) / TILE_SIZE);
            const gridY = Math.floor((event.clientY - rect.top) / TILE_SIZE);

            if (gameState === 'overworld') {
                if (!isValidOverworldTile(gridX, gridY)) return; 
                const targetEnemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                for (const enemy of targetEnemyList) {
                    if (enemy.isAliveOverworld && 
                        ((currentMapId !== OPEN_WORLD_ID && enemy.mapId === currentMapId) || currentMapId === OPEN_WORLD_ID) &&
                        enemy.overworldX === gridX && enemy.overworldY === gridY) {
                        if (currentMapId === OPEN_WORLD_ID) initiateOpenWorldCombat(enemy);
                        else initiateCombat(enemy); 
                        return;
                    }
                }
            } else if (gameState === 'combat') {
                if (currentTurn !== 'player' || !player.isAlive || !selectedAction) return;
                if (!isValidCombatTile(gridX, gridY)) return;
                if (selectedAction === 'move') handleMoveActionCombat(gridX, gridY);
                else if (selectedAction === 'attack') handleAttackActionCombat(gridX, gridY);
            }
        }

        function handleMoveActionCombat(targetGridX, targetGridY) {
            const distance = getGridDistance(player.gridX, player.gridY, targetGridX, targetGridY);
            if (player.mp >= distance && distance > 0 && !isCombatTileOccupied(targetGridX, targetGridY)) {
                player.gridX = targetGridX;
                player.gridY = targetGridY;
                player.mp -= distance; 
                if (player.mp <= 0) selectedAction = null; 
                updatePlayerCombatInfo();
                updateHighlightedTiles();
            }
        }

        function handleAttackActionCombat(targetGridX, targetGridY) {
            if (activeCombatEnemy && activeCombatEnemy.hp > 0 && activeCombatEnemy.gridX === targetGridX && activeCombatEnemy.gridY === targetGridY) {
                const distance = getGridDistance(player.gridX, player.gridY, targetGridX, targetGridY);
                if (distance <= player.attackRange && player.ap > 0) { 
                    activeCombatEnemy.hp -= player.attackPower;
                    player.ap--;
                    logGameMessage(`Atacou ${activeCombatEnemy.combatStats.name}! Dano: ${player.attackPower}.`, 2000);
                    if (activeCombatEnemy.hp <= 0) {
                        activeCombatEnemy.hp = 0;
                        setTimeout(() => endCombat(true), 1000); 
                    }
                    if (player.ap <= 0) selectedAction = null; 
                    updatePlayerCombatInfo();
                    updateHighlightedTiles();
                } else {
                    logGameMessage("Fora de alcance ou sem AP!", 1500);
                }
            }
        }
        
        function updateHighlightedTiles() { 
            highlightedTiles = [];
            if (!selectedAction || gameState !== 'combat' || !player.isAlive) return; 
            const range = (selectedAction === 'move') ? player.mp : player.attackRange;
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    const dist = getGridDistance(player.gridX, player.gridY, c, r);
                    if (dist > 0 && dist <= range) {
                        if (selectedAction === 'move' && !isCombatTileOccupied(c,r)) highlightedTiles.push({ x: c, y: r, type: 'move' });
                        else if (selectedAction === 'attack') highlightedTiles.push({ x: c, y: r, type: 'attack' });
                    }
                }
            }
        }
        
        function updateOverworldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld' || !player.isAlive) return;
            lastAiUpdateTime = now;

            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);

                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) { 
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        
                        let movedThisTick = false;

                        if (dx !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX + dx;
                            let nextY = enemy.overworldY; 

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true; 
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEntity = false;
                                for (const otherEnemy of enemies) {
                                    if (otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEntity = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEntity) {
                                    for (const pId in otherPlayers) {
                                        if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                            isOccupiedByOtherEntity = true; break;
                                        }
                                    }
                                }
                                if (!isOccupiedByOtherEntity) {
                                    enemy.overworldX = nextX;
                                    movedThisTick = true;
                                }
                            }
                        }

                        if (dy !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX; 
                            let nextY = enemy.overworldY + dy;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateCombat(enemy);
                                movedThisTick = true; 
                            } else if (isValidOverworldTile(nextX, nextY) && mapData[nextY] && mapData[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOtherEntity = false;
                                for (const otherEnemy of enemies) {
                                    if (otherEnemy !== enemy && otherEnemy.isAliveOverworld && otherEnemy.mapId === currentMapId && otherEnemy.overworldX === nextX && otherEnemy.overworldY === nextY) {
                                        isOccupiedByOtherEntity = true; break;
                                    }
                                }
                                if (!isOccupiedByOtherEntity) {
                                     for (const pId in otherPlayers) {
                                        if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) {
                                            isOccupiedByOtherEntity = true; break;
                                        }
                                    }
                                }
                                if (!isOccupiedByOtherEntity) {
                                    enemy.overworldY = nextY;
                                    movedThisTick = true;
                                }
                            }
                        }
                    }
                }
            });
        }

        function gameLoop() {
            if (!ctx) { return; }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (gameState === 'overworld') {
                if (currentMapId === OPEN_WORLD_ID) {
                    updateOpenWorldAI();
                    drawOpenWorld();
                } else {
                    updateOverworldAI();
                    drawOverworld();
                }
            } else if (gameState === 'combat') {
                drawCombat();
            }
            requestAnimationFrame(gameLoop);
        }

        function updateOpenWorldAI() {
            const now = Date.now();
            if (now - lastAiUpdateTime < AI_UPDATE_INTERVAL || gameState !== 'overworld' || !player.isAlive) return;
            lastAiUpdateTime = now;

            openWorldEnemies.forEach(enemy => {
                if (enemy.isAliveOverworld) {
                    const distToPlayer = getGridDistance(enemy.overworldX, enemy.overworldY, player.overworldX, player.overworldY);

                    if (distToPlayer <= enemy.aggroRange && distToPlayer > 0) {
                        let dx = Math.sign(player.overworldX - enemy.overworldX);
                        let dy = Math.sign(player.overworldY - enemy.overworldY);
                        let movedThisTick = false;

                        if (dx !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX + dx;
                            let nextY = enemy.overworldY;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateOpenWorldCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOpenWorldTile(nextX, nextY) && openWorldMap[nextY] && openWorldMap[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOther = false;
                                for (const otherE of openWorldEnemies) { if (otherE !== enemy && otherE.isAliveOverworld && otherE.overworldX === nextX && otherE.overworldY === nextY) { isOccupiedByOther = true; break; } }
                                if (!isOccupiedByOther) {
                                     for (const pId in otherPlayers) { if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) { isOccupiedByOther = true; break;}}
                                }
                                if (!isOccupiedByOther) {
                                    enemy.overworldX = nextX;
                                    movedThisTick = true;
                                }
                            }
                        }

                        if (dy !== 0 && !movedThisTick) {
                            let nextX = enemy.overworldX; 
                            let nextY = enemy.overworldY + dy;

                            if (nextX === player.overworldX && nextY === player.overworldY) {
                                initiateOpenWorldCombat(enemy);
                                movedThisTick = true;
                            } else if (isValidOpenWorldTile(nextX, nextY) && openWorldMap[nextY] && openWorldMap[nextY][nextX] !== MAP_TILES.OBSTACLE_ROCK) {
                                let isOccupiedByOther = false;
                                for (const otherE of openWorldEnemies) { if (otherE !== enemy && otherE.isAliveOverworld && otherE.overworldX === nextX && otherE.overworldY === nextY) { isOccupiedByOther = true; break; } }
                                if (!isOccupiedByOther) {
                                     for (const pId in otherPlayers) { if (otherPlayers[pId].mapId === OPEN_WORLD_ID && otherPlayers[pId].x === nextX && otherPlayers[pId].y === nextY) { isOccupiedByOther = true; break;}}
                                }
                                if (!isOccupiedByOther) {
                                    enemy.overworldY = nextY;
                                    movedThisTick = true;
                                }
                            }
                        }
                    }
                }
            });
        }


        function drawOpenWorld() {
            let halfW = Math.floor(cameraWidth / 2);
            let halfH = Math.floor(cameraHeight / 2);
            let camLeft = Math.max(0, Math.min(player.overworldX - halfW, OPEN_WORLD_SIZE - cameraWidth));
            let camTop = Math.max(0, Math.min(player.overworldY - halfH, OPEN_WORLD_SIZE - cameraHeight));

            for (let r = 0; r < cameraHeight; r++) {
                for (let c = 0; c < cameraWidth; c++) {
                    let mapY = camTop + r;
                    let mapX = camLeft + c;
                    if (!isValidOpenWorldTile(mapX, mapY) || !openWorldMap || !openWorldMap[mapY]) continue; 

                    const tileType = openWorldMap[mapY][mapX];
                    const x = c * TILE_SIZE, y = r * TILE_SIZE;
                    switch (tileType) {
                        case MAP_TILES.OBSTACLE_ROCK: ctx.fillStyle = '#848b98'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case MAP_TILES.DECORATION_TREE:
                            ctx.fillStyle = '#225336'; ctx.fillRect(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.5, TILE_SIZE * 0.6, TILE_SIZE * 0.5); 
                            ctx.fillStyle = '#38a169'; ctx.beginPath(); ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE * 0.35, TILE_SIZE * 0.35, 0, Math.PI * 2); ctx.fill(); 
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            ctx.fillStyle = '#48bb78'; ctx.beginPath();
                            ctx.arc(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.7, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5, TILE_SIZE * 0.25, 0, Math.PI * 2); ctx.fill();
                            break;
                    }
                }
            }
            openWorldEnemies.forEach(enemy => {
                if (enemy.isAliveOverworld) {
                    let relX = enemy.overworldX - camLeft;
                    let relY = enemy.overworldY - camTop;
                    if (relX >= 0 && relX < cameraWidth && relY >= 0 && relY < cameraHeight) {
                        drawOverworldEntity(relX, relY, enemy.combatStats.color, enemy.combatStats.size, enemy.combatStats.name, true);
                    }
                }
            });
            for (const playerId in otherPlayers) {
                const p = otherPlayers[playerId];
                if (p.mapId === OPEN_WORLD_ID) {
                    let relX = p.x - camLeft;
                    let relY = p.y - camTop;
                    if (relX >= 0 && relX < cameraWidth && relY >= 0 && relY < cameraHeight) {
                        drawOverworldEntity(relX, relY, p.color, TILE_SIZE * 0.8, p.name);
                    }
                }
            }
            let relPX = player.overworldX - camLeft;
            let relPY = player.overworldY - camTop;
            if (relPX >= 0 && relPX < cameraWidth && relPY >= 0 && relPY < cameraHeight) {
                drawOverworldEntity(relPX, relPY, player.color, player.size, player.name);
            }
        }

        function drawOverworldEntity(gridX, gridY, color, size, name = null, isEnemy = false) {
            const pixelX = gridX * TILE_SIZE + (TILE_SIZE - size) / 2;
            const pixelY = gridY * TILE_SIZE + (TILE_SIZE - size) / 2;
            ctx.fillStyle = color;
            ctx.fillRect(pixelX, pixelY, size, size);

            if (name) {
                ctx.fillStyle = isEnemy ? '#fca5a5' : '#93c5fd'; 
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(name, pixelX + size / 2, pixelY - 5);
            }
        }

        function drawOverworld() {
            drawGrid(); 
            drawMapElements(); 
            enemies.forEach(enemy => {
                if (enemy.isAliveOverworld && enemy.mapId === currentMapId) {
                    drawOverworldEntity(enemy.overworldX, enemy.overworldY, enemy.combatStats.color, enemy.combatStats.size, enemy.combatStats.name, true); 
                }
            });
            for (const playerId in otherPlayers) {
                const p = otherPlayers[playerId];
                if (p.mapId === currentMapId && p.playerId !== localPlayerId) { 
                    drawOverworldEntity(p.x, p.y, p.color, TILE_SIZE * 0.8, p.name);
                }
            }
            if (player.isAlive) drawOverworldEntity(player.overworldX, player.overworldY, player.color, player.size, player.name);
        }
        
        function drawMapElements() {
            if (!mapData || mapData.length === 0 || GRID_ROWS === 0 || GRID_COLS === 0) {
                return;
            }
            for (let r = 0; r < GRID_ROWS; r++) {
                if (!mapData[r]) continue; 
                for (let c = 0; c < GRID_COLS; c++) {
                    const tileType = mapData[r][c];
                    const x = c * TILE_SIZE, y = r * TILE_SIZE;
                    switch (tileType) {
                        case MAP_TILES.OBSTACLE_ROCK: ctx.fillStyle = '#848b98'; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); break;
                        case MAP_TILES.DECORATION_TREE:
                            ctx.fillStyle = '#225336'; ctx.fillRect(x + TILE_SIZE * 0.2, y + TILE_SIZE * 0.5, TILE_SIZE * 0.6, TILE_SIZE * 0.5); 
                            ctx.fillStyle = '#38a169'; ctx.beginPath(); ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE * 0.35, TILE_SIZE * 0.35, 0, Math.PI * 2); ctx.fill(); 
                            break;
                        case MAP_TILES.DECORATION_BUSH:
                            ctx.fillStyle = '#48bb78'; ctx.beginPath();
                            ctx.arc(x + TILE_SIZE * 0.3, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.7, y + TILE_SIZE * 0.7, TILE_SIZE * 0.25, 0, Math.PI * 2);
                            ctx.arc(x + TILE_SIZE * 0.5, y + TILE_SIZE * 0.5, TILE_SIZE * 0.25, 0, Math.PI * 2); ctx.fill();
                            break;
                    }
                }
            }
        }

        function drawCombat() {
            drawGrid();
            drawHighlightedTiles();
            if (activeCombatEnemy && activeCombatEnemy.hp > 0) drawCombatCharacter(activeCombatEnemy, true);
            if (player.isAlive) drawCombatCharacter(player, false);
        }

        function drawGrid() { 
            if (GRID_COLS <=0 || GRID_ROWS <=0) return; 
            ctx.strokeStyle = '#4a5568'; ctx.lineWidth = 0.5; 
            for (let c = 0; c < GRID_COLS; c++) for (let r = 0; r < GRID_ROWS; r++) ctx.strokeRect(c * TILE_SIZE, r * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
        
        function drawHighlightedTiles() { highlightedTiles.forEach(tile => { ctx.fillStyle = tile.type === 'move' ? 'rgba(0, 255, 0, 0.2)' : 'rgba(255, 0, 0, 0.2)'; ctx.fillRect(tile.x * TILE_SIZE, tile.y * TILE_SIZE, TILE_SIZE, TILE_SIZE); }); }

        function drawCombatCharacter(charData, isEnemy) {
            const entity = isEnemy ? charData : player;
            const combatStats = isEnemy ? entity.combatStats : player; 
            const displayColor = isEnemy ? (entity.colorFlash || combatStats.color) : player.color;
            const displaySize = combatStats.size;

            const pixelX = entity.gridX * TILE_SIZE + (TILE_SIZE - displaySize) / 2;
            const pixelY = entity.gridY * TILE_SIZE + (TILE_SIZE - displaySize) / 2;
            ctx.fillStyle = displayColor;
            ctx.fillRect(pixelX, pixelY, displaySize, displaySize);
            const hp = entity.hp, maxHp = combatStats.maxHp;
            const hpBarWidth = displaySize, hpBarHeight = 6, hpBarX = pixelX, hpBarY = pixelY - hpBarHeight - 3, hpRatio = maxHp > 0 ? hp / maxHp : 0;
            ctx.fillStyle = '#4b5563'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
            ctx.fillStyle = isEnemy ? 'red' : 'limegreen'; ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpRatio, hpBarHeight);
            if (combatStats.name) {
                ctx.fillStyle = isEnemy ? '#fca5a5' : '#93c5fd';
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(combatStats.name, pixelX + displaySize / 2, hpBarY - 3);
            }
        }

        // --- Utilitários ---
        function isValidOverworldTile(gridX, gridY) { return gridX >= 0 && gridX < GRID_COLS && gridY >= 0 && gridY < GRID_ROWS; }
        function isValidCombatTile(gridX, gridY) { return gridX >= 0 && gridX < GRID_COLS && gridY >= 0 && gridY < GRID_ROWS; }
        function getGridDistance(x1, y1, x2, y2) { return Math.max(Math.abs(x1 - x2), Math.abs(y1 - y2)); } 
        function logGameMessage(message, duration = 3000) { gameLogMessage.textContent = message; gameLogMessage.classList.remove('hidden'); if (gameLogMessage.timeoutId) clearTimeout(gameLogMessage.timeoutId); gameLogMessage.timeoutId = setTimeout(() => gameLogMessage.classList.add('hidden'), duration); }
        function updatePlayerOverworldInfo() { playerNameOverworldDisplay.textContent = player.name; playerHPOverworldDisplay.textContent = `${player.hp}/${player.maxHp}`; playerGoldOverworldDisplay.textContent = player.gold; }
        function updatePlayerCombatInfo() { playerAPCombatDisplay.textContent = `${player.ap}/${player.maxAp}`; playerMPCombatDisplay.textContent = `${player.mp}/${player.maxMp}`; }
        function updateTurnInfo() { if (gameState === 'combat') { statusInfoDisplay.textContent = currentTurn === 'player' ? "Seu Turno!" : `Turno de ${activeCombatEnemy ? activeCombatEnemy.combatStats.name : 'Inimigo'}...`; statusInfoDisplay.className = currentTurn === 'player' ? 'text-green-400 font-semibold' : 'text-red-400 font-semibold'; } }
        function enableActionButtons(enabled) { moveButton.disabled = !enabled; attackButton.disabled = !enabled; endTurnButton.disabled = !enabled; if (!enabled) { moveButton.classList.remove('selected-action'); attackButton.classList.remove('selected-action');} }
        
        function handleChatInput(event) { 
            if (event.key === 'Enter' && chatInput.value.trim() !== '') { 
                const message = chatInput.value.trim();
                addChatMessage(player.name, message); 
                if (socket && localPlayerId) {
                    socket.emit('chatMessage', {
                        senderId: localPlayerId,
                        senderName: player.name,
                        message: message,
                        mapId: currentMapId 
                    });
                }
                chatInput.value = ''; 
                event.stopPropagation(); 
            } 
        }
        function addChatMessage(sender, message) { const p = document.createElement('p'); const esc = (str) => { const d=document.createElement('div'); d.appendChild(document.createTextNode(str)); return d.innerHTML; }; p.innerHTML = `<span class="font-semibold ${sender === player.name ? 'text-green-300' : 'text-sky-300'}">[${esc(sender)}]:</span> ${esc(message)}`; chatMessages.appendChild(p); chatMessages.scrollTop = chatMessages.scrollHeight; }

        const _oldEndCombat = endCombat;
        endCombat = function(victory) {
            if (activeCombatEnemy && victory) { // Verifique se activeCombatEnemy não é null
                 const enemyList = (currentMapId === OPEN_WORLD_ID) ? openWorldEnemies : enemies;
                 const originalEnemy = enemyList.find(e => e.id === activeCombatEnemy.id);
                 if(originalEnemy) {
                    originalEnemy.isAliveOverworld = false; 
                    // O servidor deve gerenciar o respawn. O cliente pode apenas notificar a derrota.
                    // socket.emit('enemyDefeated', { enemyId: originalEnemy.id, mapId: currentMapId });
                 }
            }
            _oldEndCombat.apply(this, arguments); // Chama a função original de endCombat
        }

    </script>
</body>
</html>
